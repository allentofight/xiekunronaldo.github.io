<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[AllenToFight Blog]]></title>
  <link href="http://xiekunRonaldo.github.io/atom.xml" rel="self"/>
  <link href="http://xiekunRonaldo.github.io/"/>
  <updated>2014-07-27T14:53:37+08:00</updated>
  <id>http://xiekunRonaldo.github.io/</id>
  <author>
    <name><![CDATA[AllenToFight]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[容器-块-迭代器]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/26/rong-qi-kuai-die-dai-qi/"/>
    <updated>2014-07-26T08:51:21+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/26/rong-qi-kuai-die-dai-qi</id>
    <content type="html"><![CDATA[<h4>数组</h4>

<p>来看看数组是怎么用的</p>

<pre><code>a = [ 3.14159, "pie", 99 ] 
a.class # =&gt; Array 
a.length # =&gt; 3 a[0] # =&gt; 3.14159   a[1] # =&gt; "pie" a[2] #=&gt;99  a[3] #=&gt;nil
b = Array.new   b.class # =&gt; Array 
b.length # =&gt; 0 
b[0] = "second" b[1] = "array"  ￼b
a = [ 1, 3, 5, 7, 9 ]   a[-1] # =&gt; 9    a[-2] # =&gt; 7    a[-99] # =&gt; nil
a = [ 1, 3, 5, 7, 9 ] 
a[1,3] #=&gt;[3,5,7] 
a[3, 1] # =&gt; [7] 
a[-3,2] #=&gt;[5,7]
a = [ 1, 3, 5, 7, 9 ]   a[1..3] #=&gt;[3,5,7]  a[1...3] # =&gt; [3, 5]    a[3..3] #=&gt;[7] 
a[-3..-1] # =&gt; [5, 7, 9]

a=[1,3,5,7,9]       #=&gt;[1,3,5,7,9]
a[1] = 'bat'        #=&gt; [1, "bat", 5, 7, 9] a[-3] = 'cat'       #=&gt; [1, "bat", "cat", 7, 9] a[3] =[9,8]         #=&gt; [1, "bat", "cat", [9, 8], 9]    a[6] = 99           #=&gt; [1, "bat", "cat", [9, 8], 9, nil, 99]
a = [ 1, 3, 5, 7, 9 ]       #=&gt;[1,3,5,7,9]  a[2, 2] = 'cat'             #=&gt; [1, 3, "cat", 9]    a[2, 0] = 'dog'             #=&gt; [1, 3, "dog", "cat", 9]     a[1,1]=[9,8, 7]             #=&gt;[1,9,8,7,"dog","cat",9]  a[0..3] = []                #=&gt; ["dog", "cat", 9]   a[5..6] = 99, 98            #=&gt; ["dog", "cat", 9, nil, nil, 99, 98]
</code></pre>

<p>数组有许多有用的方法，使用它们，你能将数组作为栈(stacks),集和(sets),队列(queues),<a href="http://en.wikipedia.org/wiki/Double-ended_queue">dequeues</a>,先进先出的queues
比如,push和pop方法从数组的末端添加和删除元素，所以你能将数组作为栈来使用</p>

<pre><code>stack = []  stack.push "red"    stack.push "green"  stack.push "blue"   stack # =&gt; ["red", "green", "blue"]

stack.pop # =&gt; "blue"   stack.pop # =&gt; "green"  stack.pop # =&gt; "red"    stack #=&gt;[]
</code></pre>

<p>同样地,unshift和shift从数组的起始位置添加和删除元素,结合shift和push，你能构建一个FIFO的队列</p>

<pre><code>queue = []  queue.push "red" 
queue.push "green" 
queue.shift # =&gt; "red" 
queue.shift # =&gt; "green"
</code></pre>

<p>first和last方法返回一个数组的头部和尾部的n个元素</p>

<pre><code>array = [ 1, 2, 3, 4, 5, 6, 7 ] 
array.first(4) # =&gt; [1, 2, 3, 4] 
array.last(4) # =&gt; [4, 5, 6, 7]
</code></pre>

<h4>哈希(字典)</h4>

<p>同数组一样,哈希也是针对数组引用的以索引查询的集合,不过与数组不同的是，数组的下标只能为整形，而哈希的key则可为symbols,strings,regular expression等</p>

<pre><code>h = { 'dog' =&gt; 'canine', 'cat' =&gt; 'feline', 'donkey' =&gt; 'asinine' } h.length # =&gt; 3 h['dog'] # =&gt; "canine"  h['cow'] = 'bovine' h[12] = 'dodecine'  h['cat'] = 99   h           # =&gt; {"dog"=&gt;"canine", "cat"=&gt;99, "donkey"=&gt;"asinine", "cow"=&gt;"bovine",             # .. 12=&gt;"dodecine"}
</code></pre>

<p>从Ruby 1.9开始,如果key是symbols,你可以用以下方式创建hash</p>

<pre><code>h = { :dog =&gt; 'canine', :cat =&gt; 'feline', :donkey =&gt; 'asinine' }
</code></pre>

<p>也可以这么写</p>

<pre><code>h = { dog: 'canine', cat: 'feline', donkey: 'asinine' }####用哈希和数组来完成单词的计数
</code></pre>

<p>现在我们要完成一个demo,给定一段文字，从中计算出每个单词出现的频率
我们将问题分成两步</p>

<ol>
<li><p>将这一段文字作为一个字符串，然后返回此字符串里的单词(保存在数组中)</p>

<pre><code> def words_from_string(string) 
     string.downcase.scan(/[\w']+/)      end
 p words_from_string("But I didn't inhale, he said (emphatically)")
 结果:     ["but", "i", "didn't", "inhale", "he", "said", "emphatically"]
</code></pre></li>
<li><p>为每一个不同的单词都弄一个计数，这个就用hash来实现        def count_frequency(word_list)
         counts = Hash.new(0)            for word in word_list               counts[word] += 1           end         counts      end     p count_frequency([&ldquo;sparky&rdquo;, &ldquo;the&rdquo;, &ldquo;cat&rdquo;, &ldquo;sat&rdquo;, &ldquo;on&rdquo;, &ldquo;the&rdquo;, &ldquo;mat&rdquo;])      produces:       {&ldquo;sparky&rdquo;=>1, &ldquo;the&rdquo;=>2, &ldquo;cat&rdquo;=>1, &ldquo;sat&rdquo;=>1, &ldquo;on&rdquo;=>1, &ldquo;mat&rdquo;=>1}
最后，计算好了hash后，我们要打印出来，这里我们打算按字数出现频率的升序顺序来打印</p>

<pre><code>  sorted = counts.sort_by {|word, count| count}
</code></pre>

<p>综上，我们的程序如下</p>

<pre><code>  require_relative "words_from_string.rb" 
  require_relative "count_frequency.rb"       raw_text = %{The problem breaks down into two parts. First, given some text as a string, return a list of words. That sounds like an array. Then, build a count for each distinct word. That sounds like a use for a hash---we can index it with the word and use the corresponding entry to keep a count.}     word_list = words_from_string(raw_text)     counts    = count_frequency(word_list)      sorted    = counts.sort_by {|word, count| count}        top_five  = sorted.last(5)
</code></pre></li>
</ol>


<p><code>top_five  = sorted.last(5)</code>是一个数组,每一个元素对应着一个key/value的pair,来看看如何遍历它</p>

<pre><code>for i in 0...5 # (this is ugly code--read on 
    word = top_five[i][0] # for a better version) 
    count = top_five[i][1]  puts "#{word}: #{count}"    end produces:   that:  2    sounds:  2  like:  2    the:  3 a: 6####单元测试
</code></pre>

<p>表面上我们对以上的方法进行单元测试
首先是对<code>words_from_string</code></p>

<pre><code>    require_relative 'words_from_string'        require 'test/unit'     class TestWordsFromString &lt; Test::Unit::TestCase            def test_empty_string               assert_equal([], words_from_string("")) assert_equal([], words_from_string(" "))            end         def test_single_word                assert_equal(["cat"], words_from_string("cat")) assert_equal(["cat"], words_from_string(" cat "))           end         def test_many_words             assert_equal(["the", "cat", "sat", "on", "the", "mat"],             words_from_string("the cat sat on the mat"))            end
        def test_ignores_punctuation                assert_equal(["the", "cat's", "mat"],               words_from_string("&lt;the!&gt; cat's, -mat-")) 
        end     end     produces:       Run options:        # Running tests:        ....        Finished tests in 0.006458s, 619.3868 tests/s, 929.0802 assertions/s.       4 tests, 6 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>在测试框架中，所有以test开头的方法都会自动运行我们也能测试计算单词出现次数的方法</p>

<pre><code>    require_relative 'count_frequency'      require 'test/unit'     class TestCountFrequency &lt; Test::Unit::TestCase             def test_empty_list             assert_equal({}, count_frequency([]))           end
            def test_single_word                assert_equal({"cat" =&gt; 1}, count_frequency(["cat"]))            end         def test_two_different_words                assert_equal({"cat" =&gt; 1, "sat" =&gt; 1}, count_frequency(["cat", "sat"]))         end         def test_two_words_with_adjacent_repeat             assert_equal({"cat" =&gt; 2, "sat" =&gt; 1}, count_frequency(["cat", "cat", "sat"]))          end         def test_two_words_with_non_adjacent_repeat             assert_equal({"cat" =&gt; 2, "sat" =&gt; 1}, count_frequency(["cat", "sat", "cat"]))          end         end     produces:       Run options:        # Running tests:        .....       Finished tests in 0.006327s, 790.2639 tests/s, 790.2639 assertions/s.       5 tests, 5 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<h4>块和迭代器</h4>

<p>还记得之前遍历top_five的语句吗,实际上，我们可以按如下方式来遍历数组</p>

<pre><code>top_five.each do |word, count| 
    puts "#{word}: #{count}"    end
</code></pre>

<p>each方法就是一个迭代器-一个不断调用块的方法,实际上相较于以上的方法，很多程序员更愿意写成如下形式</p>

<pre><code>puts top_five.map { |word, count| "#{word}: #{count}" }
</code></pre>

<p>假设有以下程序</p>

<pre><code>square = Shape.new(sides: 4) # 假设 Shape 类在其他地方定义了 # .. lots of code   sum = 0 [1, 2, 3, 4].each do |value|        square = value * value      sum += square   end puts sum现在我们调用
square.draw     //报错
</code></pre>

<p>因为在block里square的值被改变了</p>

<p>我们可以通过将仅作用域仅在块内部的变量放在块的参数列表后面(通过;来分隔)来避免此类现象的发生,如下</p>

<pre><code>[1, 2, 3, 4].each do |value; square|        square = value * value      sum += square   end
</code></pre>

<h5>yield的使用</h5>

<pre><code>def fib_up_to(max) 
    i1, i2 = 1, 1 
    while i1 &lt;= max     yield i1            i1, i2 = i2, i1+i2      end     end # parallel assignment (i1 = 1 and i2 = 1)
fib_up_to(1000) {|f| print f, " " } puts    produces:   1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987注意以下这行的使用
print f, " "
</code></pre>

<p>一个块也能返回一个值，块最后一个表达式的值为yield执行后的值
这就是Array中的find方法工作的原理</p>

<pre><code>class Array 
    def find            each do |value|             return value if yield(value)            end     nil     end     end [1, 3, 5, 7, 9].find {|v| v*v &gt; 30 } # =&gt; 7
</code></pre>

<p>迭代器collect的使用</p>

<pre><code>["H", "A", "L"].collect {|x| x.succ } # =&gt; ["I", "B", "M"]迭代器并不限于访问array和hash中已存在的元素，如我们之前在Fibonacci中看到的,一个迭代器能返回推导后的值,

    yield i1            i1, i2 = i2, i1+i2      end 
</code></pre>

<p> 同样的，这种特性也被Ruby用在输入输出类中,这些类返回了一个迭代器接口，这些接口在I/O流中返回了连续的行(或bytes),如下</p>

<pre><code>f = File.open("testfile") 
f.each do |line|        puts "The line is: #{line}" end f.close
produces:   The line is: This is line one   The line is: This is line two   The line is: This is line three The line is: And so on...
</code></pre>

<p>有时你想跟踪block被调用了多少次，这时你可以试试with_index方法,此方法一般是跟在一个迭代器(如each之后)</p>

<pre><code>f = File.open("testfile") 
f.each.with_index do |line, index|      puts "Line #{index} is: #{line}" 
end f.close produces:   Line 0 is: This is line one Line 1 is: This is line two
</code></pre>

<p>再看一个有用的迭代器</p>

<pre><code>[1,3,5,7].inject(0) {|sum, element| sum+element} # =&gt; 16 
[1,3,5,7].inject(1) {|product, element| product*element} # =&gt; 105
</code></pre>

<p>等价于</p>

<pre><code>[1,3,5,7].inject {|sum, element| sum+element} # =&gt; 16 
[1,3,5,7].inject {|product, element| product*element} # =&gt; 105
</code></pre>

<p>等价于</p>

<pre><code>[1,3,5,7].inject(:+) # =&gt; 16 
[1,3,5,7].inject(:*) # =&gt; 105####Enumberators-外在迭代器
</code></pre>

<p>尽管以上的迭代器有许多好处,不过如果遇到以下情况，你会发现内部迭代器帮不上什么忙</p>

<ol>
<li><p>如果你要将迭代器当作一个对象时(比如代要将迭代器传给一个方法，这个方法需要访问这个迭代器里的每个元素)2. 同时访问两个Collections的元素
幸运的是，Ruby中有一个内置的Enumerator类，实现了外在的迭代器，可以处理以上说的两种情况
你可以对array或hash来调用to_enum方法来创建一个Enumberator对象</p>

<pre><code>  a = [ 1, 3, "cat" ]     h = { dog: "canine", fox: "vulpine" }       # Create Enumerators        enum_a = a.to_enum      enum_h = h.to_enum      enum_a.next # =&gt; 1      enum_h.next # =&gt; [:dog, "canine"] 
  enum_a.next # =&gt; 3      enum_h.next # =&gt; [:fox, "vulpine"]
</code></pre></li>
</ol>


<p>许多内在迭代器方法(产生连接的值传给block，如each) 如果不结合block使用的话将返回一个Enumerator对象</p>

<pre><code>    a = [ 1, 3, "cat" ]     enum_a = a.each # create an Enumerator using an internal iterator       enum_a.next # =&gt; 1 enum_a.next # =&gt; 3Ruby有一个叫做loop的方法，不做任何事情,主要工作就是不断地调用block,通常来说，如果某些条件发生了，block中的代码将跳出循环,但是当你用Enumerator时，loop可以足够聪明地分辨出一个enumerator对象是否遍历了所有的值，如果遍历完了，loop将终止
short_enum = [1, 2, 3].to_enum  long_enum = ('a'..'z').to_enum  loop do     puts "#{short_enum.next} - #{long_enum.next}"   end produces:   1-a 2-b 3-c
</code></pre>

<h4>Enumerators是对象</h4>

<p>Enumberators将某些可执行的代码(迭代的行为)转化成一个对象，这意味着你可以用enumerator来做一些普通的循环无法轻易做到的事情,比如Enumerable模块定义了一个each_with_index方法，这个方法触发了原先的each方法，同时也返回了一个index</p>

<pre><code>result = [] [ 'a', 'b', 'c' ].each_with_index {|item, index| result &lt;&lt; [item, index] }  result # =&gt; [["a", 0], ["b", 1], ["c", 2]]
</code></pre>

<p>如果你想迭代并获取index但又不想用each而想用其他方法来控制迭代又该怎么做呢？比如你想循环string里的每个character,Enumerator派上用场了,如果你不给string的each_char方法一个block,它会返回一个enumerator,然后再调用enumetor的each_with_index方法</p>

<pre><code>result = [] "cat".each_char.each_with_index {|item, index| result &lt;&lt; [item, index] } 
result # =&gt; [["c", 0], ["a", 1], ["t", 2]]
</code></pre>

<p>实际上这是一个很普遍的方法，所以Mats给我们提供了一个方法with_index</p>

<pre><code>result = [] "cat".each_char.with_index {|item, index| result &lt;&lt; [item, index] } 
result # =&gt; [["c", 0], ["a", 1], ["t", 2]]
</code></pre>

<p>我们也可以显式地创建Enumerator对象，这里我们通过调用string的each_char方法来创建，然后我们对enumerator来调用to_s遍历它</p>

<pre><code>enum = "cat".enum_for(:each_char) enum.to_a # =&gt; ["c", "a", "t"]如果我们用来构建enumerator的方法中有参数，我们可以将它们传入enum_for
enum_in_threes = (1..10).enum_for(:each_slice, 3) 
enum_in_threes.to_a # =&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
</code></pre>

<p>Enumerator对象也是可enumerable的(也就是说，适应于可enumerable对象的方法也是适用于enumerator的),比如我们可以用Enumerable的first方法</p>

<pre><code>    triangular_numbers = Enumerator.new do |yielder| 

        number = 0          count = 1           loop do             number += count             count  += 1             yielder.yield number            end         end     p triangular_numbers.first(5)       produces:       [1, 3, 6, 10, 15]####Enumberators Are Generators and Filters
</code></pre>

<p>Generators</p>

<pre><code>triangular_numbers = Enumerator.new do |yielder| number = 0 count = 1   loop do     number += count     count += 1      yielder.yield number    end end 5.times { print triangular_numbers.next, " " } puts produces:   1 3 6 10 15
</code></pre>

<p>Filters</p>

<pre><code>triangular_numbers = Enumerator.new do |yielder| # ...  # as before...  # ...   end def infinite_select(enum, &amp;block) Enumerator.new do |yielder|   enum.each do |value|    yielder.yield(value) if block.call(value)   end end end p infinite_select(triangular_numbers) {|val| val % 10 == 0}.first(5)    produces:   [10, 120, 190, 210, 300]等价于
triangular_numbers = Enumerator.new do |yielder|         # ... as before    end class Enumerator        def infinite_select(&amp;block)         Enumerator.new do |yielder| 
            self.each do |value|                        yielder.yield(value) if block.call(value) 
            end         end 
    end end p triangular_numbers       .infinite_select {|val| val % 10 == 0}      .infinite_select {|val| val.to_s =~ /3/ }       .first(5)    produces:   [300, 630, 1830, 3160, 3240]####Blocks可以是对象
</code></pre>

<p>block被转化成了Proc类的对象并将它存储在类的属性中   class ProcExample   def pass_in_block(&amp;action)      @stored_proc = action   end def use_proc(parameter)     @stored_proc.call(parameter)    end end</p>

<pre><code>eg = ProcExample.new    eg.pass_in_block { |param| puts "The parameter is #{param}" } 
eg.use_proc(99)
</code></pre>

<p>如果一个方法返回了一个block对象又如何调用?</p>

<pre><code>def create_block_object(&amp;block) 

block   end
bo = create_block_object { |param| puts "You called me with #{param}" } 
bo.call 99  bo.call "cat"   produces:   You called me with 99   You called me with cat
</code></pre>

<p>实际上这种方式是很有用的，所以Ruby提供了两个方法将一个block转化为一个对象,lambda和Proc.new都接受了一个block来创建一个Proc类的对象</p>

<pre><code>bo = lambda { |param| puts "You called me with #{param}" } bo.call 99   bo.call "cat"   produces:   You called me with 99   You called me with cat
</code></pre>

<h4>Blocks Can Be Closures</h4>

<pre><code>def n_times(thing)      lambda {|n| thing * n } end p1 = n_times(23)    p1.call(3) # =&gt; 69  p1.call(4) # =&gt; 92  p2 = n_times("Hello ")  p2.call(3) # =&gt; "Hello Hello Hello "    Blocks and Iterators • 65
</code></pre>

<p>n_times方法返回了一个Proc对象并且引用了方法的参数，thing,尽管到block被调用时，参数已经超出范围了，参数仍然能被block访问，这叫做closure(上下文的参数在block或Proc的生命周期中仍能被访问)，两看另外一个例子</p>

<pre><code>def power_proc_generator 
    value = 1       lambda { value += value }   end power_proc = power_proc_generator   puts power_proc.call    puts power_proc.call    puts power_proc.call    produces:   2 4 8
</code></pre>

<p>我们可以看到vaue值是一直变化的</p>

<h4>另一种创建Proc对象的方式</h4>

<p>之前我们用以下方式来创建Proc</p>

<pre><code>lambda { |params| ... }
</code></pre>

<p>你也可以用以下方式来创建</p>

<pre><code>-&gt; params { ... }

proc1 = -&gt; arg { puts "In proc1 with #{arg}" }  proc2 = -&gt; arg1, arg2 { puts "In proc2 with #{arg1} and #{arg2}" } 
proc3 = -&gt;(arg1, arg2) { puts "In proc3 with #{arg1} and #{arg2}" } proc1.call "ant" 
proc2.call "bee", "cat" 
proc3.call "dog", "elk"     produces:   In proc1 with ant   In proc2 with bee and cat   In proc3 with dog and elk
</code></pre>

<p>比起lambda,&ndash;>的形式看紧凑，特别是当你要传多个Proc对象给一个方法的时候</p>

<pre><code>def my_if(condition, then_clause, else_clause) 
    if condition            then_clause.call        else            else_clause.call        end     end 5.times do |val|        my_if val &lt; 2,
          -&gt; { puts "#{val} is small" }, 
          -&gt; { puts "#{val} is big" }   end produces:   0 is small  1 is small  2 is big    3 is big    4 is big####Block Parameter Lists
proc1 = lambda do |a, *b, &amp;block| 
    puts "a = #{a.inspect}"     
    puts "b = #{b.inspect}" 
    block.call  end proc1.call(1, 2, 3, 4) { puts "in block1" } produces:   a=1 b = [2, 3, 4] 

in block1
</code></pre>

<p>另一种形式</p>

<pre><code>proc2 = -&gt; a, *b, &amp;block do 

    puts "a = #{a.inspect}" 

    puts "b = #{b.inspect}" 

    block.call  end proc2.call(1, 2, 3, 4) { puts "in block2" } produces:   a=1 b = [2, 3, 4] in block2
￼
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类-对象-变量]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/23/lei-dui-xiang-bian-liang/"/>
    <updated>2014-07-23T21:41:14+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/23/lei-dui-xiang-bian-liang</id>
    <content type="html"><![CDATA[<p>假设有以下文件</p>

<pre><code>        //data.csv

        "Date","ISBN","Price"
        "2013-04-12","978-1-9343561-0-4",39.45
        "2013-04-13","978-1-9343561-6-6",45.67
        "2013-04-14","978-1-9343560-7-4",36.95
</code></pre>

<p>现在我们的任务就是从这个CSV文件中计算出有相同title的书各有多少本，以及书的总价
我们设计了一个BookInStock的类</p>

<pre><code>class BookInStock

end
</code></pre>

<p>用new来创建对象</p>

<pre><code>a_book = BookInStock.new
</code></pre>

<p>以此创建的类无任何信息，我们可以为此类提供一个initialize的方法，此方法能让我们在每个对象都创建好后就设置对象的状态，我们将此状态存储在实例变量中(以@开头),现在我们更新如下</p>

<pre><code>class BookInStock       def initialize(isbn, price)         @isbn = isbn            @price = Float(price)       end     end
</code></pre>

<p>initialize是一个特别的方法，当你调用BookInStore.new去创建一个对象的时候,Ruby分配了一些内存给此未初始化的对象，然后调用了initialize的方法，传递了任何传递给new方法的参数，这样就给了你一次设置对象状态的机会</p>

<pre><code>    b1 = BookInStock.new("isbn1", 3) 
p b1

produces:
    #&lt;BookInStock:0x007fac4910f3e0 @isbn="isbn1", @price=3.0&gt;
</code></pre>

<p>p方法能打印出一个对象的内部表示形式(如@isbn, @price)而puts方法只是简单地将字符串输出到标准输出上，当你将一个对象传给puts时，由于puts不知道如何处理，所以它作了一个简单地处理:对象类的名字+:+对象的内存地址,我们可以改变puts的这种输出形式，只要重写to_s即可</p>

<pre><code>class BookInStock       def initialize(isbn, price)             @isbn = isbn                @price = Float(price)       end
        def to_s        "ISBN: #{@isbn}, price: #{@price}"      end end
        b1 = BookInStock.new("isbn1", 3)    puts b1
结果  ISBN: isbn1, price: 3.0
</code></pre>

<h5>对象和属性</h5>

<p>以上的@isbn, @price不能访问，无任何意义，可以为它添加get方法</p>

<pre><code>class BookInStock       def initialize(isbn, price)         @isbn = isbn            @price = Float(price)       end     def isbn            @isbn       end
    def price           @price      end # ..    end
book = BookInStock.new("isbn1", 12.34) 
puts "ISBN = #{book.isbn}"  puts "Price = #{book.price}"
结果
    ISBN   = isbn1
Price  = 12.34
</code></pre>

<p>由于get方法的使用是如此频繁,Ruby提供了一个简便的方法，attr_reader能为你创建这些属性的get方法</p>

<pre><code>class BookInStock   
  attr_reader :isbn, :price     def initialize(isbn, price)             @isbn = isbn            @price = Float(price)       end     # ..    end book = BookInStock.new("isbn1", 12.34) 

puts "ISBN = #{book.isbn}"
    puts "Price = #{book.price}"
结果: ISBN   = isbn1  Price  = 12.34对应,attr_reader后面跟的是symbols
</code></pre>

<p>这里通常有一个误解，特别是那些学过Java和C#的人,他们认为attr_reader在某种程序上声明了实例变量，实际上是没有的，它只是生成了访问方法，但无声明任何变量，这些变量只有在你使用它们的时候才出现，Ruby是完全让实例变量与访问方法解藕的</p>

<h4>可写属性</h4>

<p>以上我们只是设置了只读方法,现在我看看如何设置可写方法</p>

<pre><code>class BookInStock       attr_reader :isbn, :price       def initialize(isbn, price) 
        @isbn = isbn            @price = Float(price)       end     def price=(new_price)           @price = new_price      end # ...   end

book = BookInStock.new("isbn1", 33.80)  puts "ISBN = #{book.isbn}"  puts "Price = #{book.price}" book.price = book.price * 0.75 puts "New price = #{book.price}"    结果: ISBN      = isbn1   Price     = 33.8    New price = 25.349999999999998
</code></pre>

<p>同样的,Ruby也提供了一个创建属性设置方法的捷径，如果你想有一个只写不可读的方法，可以使用attr_writer,不过这种情况极其罕见，如果你想为某个属性设置可读可写的方法，你可以用attr_accessor</p>

<pre><code>    class BookInStock       attr_reader :isbn 
    attr_accessor :price
    def initialize(isbn, price)             @isbn = isbn            @price = Float(price)       end # ...   end book = BookInStock.new("isbn1", 33.80) 
puts "ISBN = #{book.isbn}"
puts "Price = #{book.price}" 
book.price = book.price * 0.75
puts "New price = #{book.price}"
结果: ISBN      = isbn1
Price     = 33.8
New price = 25.349999999999998
</code></pre>

<h4>虚属性</h4>

<pre><code>class BookInStock 
    attr_reader :isbn       attr_accessor :price        def initialize(isbn, price) 
        @isbn = isbn            @price = Float(price)       end     def price_in_cents          Integer(price*100 + 0.5)        end # ...   end我们看看以下会输出什么
puts "Price in cents = #{book.price_in_cents}"  结果
rice in cents = 3380
</code></pre>

<p><code>book.price_in_cents</code>表示的就是虚属性，由于<code>price_in_cents</code>不对应任何对象的属性，但我们却提供了访问方法，依然可以通过.的形式访问它,同样的，我们也可以提供一个它的写方法</p>

<pre><code>def price_in_cents=(cents) 
    @price = cents / 100.0  end

book = BookInStock.new("isbn1", 33.80)
puts "Price = #{book.price}"
puts "Price in cents = #{book.price_in_cents}" 

book.price_in_cents = 1234  puts "Price = #{book.price}"    puts "Price in cents = #{book.price_in_cents}"  produces:   Price          = 33.8   Price in cents = 3380   Price          = 12.34  Price in cents = 1234####类与其他类的协同工作
</code></pre>

<p>已知BookInStock定义如上,现在不少csv文件，我们需要将csv文件的每一行转为一个BookInStock,并将每一个BookInStock保存到一个数组中，然后计算所有书的总价,所计算的几个csv文件我们通过命令行传入,现在我们将这个程序分成三个rb文件来操作(假设这三个文件在同一目录下)</p>

<ol>
<li><p>book_in_stock.rb</p>

<pre><code> class BookInStock 
     attr_reader :isbn, :price           def initialize(isbn, price)                 @isbn = isbn                @price = Float(price)           end end
</code></pre></li>
</ol>


<p>2.csv_reader.rb
此文件有两个外部信赖，它需要标准的CSV的库，也需要存储在book_in_stock.rb中的BookInStock的类,我们用require来加载Ruby的CSV库，用require_relative来加载book_in_stock文件</p>

<pre><code>require 'csv'   require_relative 'book_in_stock'
class CsvReader 
    def initialize          @books_in_stock = []        end     def read_in_csv_data(csv_file_name)             CSV.foreach(csv_file_name, headers: true) do |row|          @books_in_stock &lt;&lt; BookInStock.new(row["ISBN"], row["Price"]) 
        end end end
</code></pre>

<p>3.stock_stats.rb
这是我们的主程序</p>

<pre><code>require_relative 'csv_reader'   reader = CsvReader.new
ARGV.each do |csv_file_name|        STDERR.puts "Processing #{csv_file_name}" 
    reader.read_in_csv_data(csv_file_name)  end ￼￼￼puts "Total value = #{reader.total_value_in_stock}"
</code></pre>

<p>运行程序如下</p>

<pre><code>$ ruby stock_stats.rb data.csv  Processing data.csv Total value = 122.07000000000001
</code></pre>

<h5>访问控制</h5>

<p>Ruby给你三种访问控制权限</p>

<ul>
<li>Public</li>
<li>Protected</li>
<li>Private
三种访问控制权限与其他语言的一样，不过有一点与其他面向对象的语言很不一样，那就是，Ruby中的访问控制是程序运行后才被确定的，是动态的，而不是静态的，只有当代码执行了访问受限的代码才能知道是否有访问不合法的错误发生

<h6>如何指定访问控制</h6>

<p>有以下两种方法</p>

<pre><code>  class MyClass
      def method1     # 默认是 'public'
          #...
      end
  protected
      def method2
          #....
      end
  private 
      def method3
          #...
      end
  end
</code></pre>

<p>或</p>

<pre><code>      class MyClass 
          def method1 

          end             def method2                 end     # ... and so on           public    :method1, :method4            protected :method2              private   :method3        end
</code></pre>

<h4>变量</h4>

<pre><code>  person = "Tim"      puts "The object in 'person' is a #{person.class}" 
  puts "The object has an id of #{person.object_id}" 
  puts "and a value of '#{person}'"       produces:          The object in 'person' is a String          The object has an id of 70230663692980          and a value of 'Tim'
</code></pre>

<p>那么，变量是否是一个对象呢，答案是否定的，一个变量只是一个对象的引用,来看以下例子，一目了然</p>

<pre><code>  person1 = "Tim"
  person2 = person1 
  person1[0] = 'J'        puts "person1 is #{person1}" 
  puts "person2 is #{person2}"        produces:                      person1 is Jim              person2 is Jim
</code></pre></li>
</ul>


<p>你可以用String的
dup方法来创建一个全新的对象</p>

<pre><code>    person1 = "Tim"     person2 = person1.dup person1[0] = "J"      puts "person1 is #{person1}" puts "person2 is #{person2}"       produces:       person1 is Jim      person2 is Tim我们也可以冻结一个对象来避免对它作出修改
    person1 = "Tim"     person2 = person1       person1.freeze # prevent modifications to the object person2[0] = "J"       produces:               from prog.rb:4:in `&lt;main&gt;'      prog.rb:4:in `[]=': can't modify frozen String (RuntimeError)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby-new]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/23/ruby-new/"/>
    <updated>2014-07-23T20:11:08+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/23/ruby-new</id>
    <content type="html"><![CDATA[<h4>Ruby中一切皆对象</h4>

<p>创建对象，假设有一个Song的类，按如下方式创建实例</p>

<pre><code>song1 = Song.new("Ruby Tuesday")
song2 = Song.new("Enveloped in Python")
</code></pre>

<p>如何理解一切皆对象，看以下demo</p>

<pre><code>puts "gin joint".length 
puts "Rick".index("c") 
puts 42.even?           //42是否是偶数
puts sam.play(song)
</code></pre>

<p>在java中，如果要算一个值的绝对值，可按如下方式</p>

<pre><code>num = Math.abs(num)
</code></pre>

<p>但在Ruby中，由于一切皆对象，可按如下方式</p>

<pre><code>um = -1234          # =&gt; -1234 
positive = num.abs  # =&gt; 1234
</code></pre>

<p>同样的规则适用于所有的Ruby对象，在C中，你可以写strlen(name)，但在ruby中，你可以写name.length,无比轻松</p>

<h5>Ruby中的方法</h5>

<p>形式如下</p>

<pre><code>def say_goodnight(name)     result = "Good night, " + name      return result   end
    # Time for bed...
puts say_goodnight("John-Boy") 
puts say_goodnight("Mary-Ellen")
</code></pre>

<p>无需分号表示每个语句的结尾，只要你把每一条语句都放在一单独的行上    puts say_goodnight(&ldquo;Mary-Ellen&rdquo;)
相当于</p>

<pre><code>puts(say_goodnight("Mary-Ellen"))
</code></pre>

<h5>字符串</h5>

<p>创建字符串有两种方法，一种是单引号括起来的，一种是双引号括起来的,双引号括起来的字符串，ruby需要做更多的工作，首先，ruby会寻找以反斜杠开头的序列，并将它替换为一个二进制的值,如&#8221;\n&#8221;,另外，双引号形式的字符串还需要做的将#{expression}序列替换成expression的值,我们能用它来替换之前我们写的程序</p>

<pre><code>def say_goodnight(name)
    result = "Good night, #{name}" 
    return result
end
puts say_goodnight('Pa') 
produces:   Good night, Pa
</code></pre>

<p>任意的复杂的表达式都能放在#{&hellip;}里，如下</p>

<pre><code>def say_goodnight(name)     result = "Good night, #{name.capitalize}"       return result   end puts say_goodnight('uncle')     produces:   Good night, Uncle
</code></pre>

<p>我们还能对以上方法进行简化，ruby方法返回的值是最一个表达式对应的值，所以我们可以不必写临时变量和return语句</p>

<pre><code>    def say_goodnight(name)
    "Good night, #{name.capitalize}"
end
puts say_goodnight('ma') 
produces:   Good night, Ma
</code></pre>

<h4>Ruby的名字</h4>

<p>ruby的命名遵循以下惯例,第一个名字的首字符表示这个名字的使用场合</p>

<ul>
<li>局部变量，方法参数，方法名都 以一个小写字母或下划线开头</li>
<li>全局变量以一个$符开头，对象实例变量以@开头</li>
<li>类变量以两个@@开头</li>
<li><p>类名，模块名，常量必须以大写字母开头
使用的demo如下</p>

<pre><code>  Local Variable:     name fish_and_chips x_axis thx1138 _x _26
  Instance Variable:  @name @point_1 @X @_ @plan9
  Class Variable:     @@total @@symtab @@N @@x_pos @@SINGLE
  Global Variable:   $debug $CUSTOMER $_ $plan9 $Global
  Class Name:         String ActiveRecord MyClass     Constant Name:      FEET_PER_MILE DEBUG
</code></pre>

<h4>数组和哈希字典</h4>

<p>数组</p>

<pre><code>  a = [ 1, 'cat', 3.14 ] # array with three elements 
  puts "The first element is #{a[0]}"
  # set the third element
  a[2] = nil
  puts "The array is now #{a.inspect}"
  produces:
  The first element is 1
  The array is now [1, "cat", nil]
</code></pre>

<p>简便地创建数组的方法</p>

<pre><code>  a = %w{ ant bee cat dog elk } 
  a[0] # =&gt; "ant"
  a[3] # =&gt; "dog"
</code></pre>

<p>哈希字典</p>

<pre><code>  inst_section = {
  'cello' =&gt; 'string', 
  'clarinet' =&gt; 'woodwind', 
  'drum' =&gt; 'percussion', 
  'oboe' =&gt; 'woodwind', 
  'trumpet' =&gt; 'brass', 
  'violin' =&gt; 'string'    }
</code></pre>

<p><code>=&gt;</code>符号的左为key，右为value
在控制台上我们用p而不是puts，因为p可以更显式地打印nil值</p>

<pre><code>  p inst_section['oboe']
  p inst_section['cello']
  p inst_section['bassoon']
</code></pre></li>
</ul>


<p>produces:</p>

<pre><code>    "woodwind"
    "string"
    nil
</code></pre>

<p>默认情况下hash的key如果对应的value不存在，则value的值为nil，我们可以改变这个默认傎</p>

<pre><code>histogram = Hash.new(0)
histogram['ruby'] # =&gt; 0
histogram['ruby'] = histogram['ruby'] + 1 
histogram['ruby'] # =&gt; 1
</code></pre>

<h4>符号(Symbols)</h4>

<p>通常在编程的时候，你需要为某些重要的东西指定一个名字，比如，你也许想要用名字来指示指南针的方向，所以，你可以像以下这么写</p>

<pre><code>NORTH = 1 
EAST =2 
SOUTH = 3 
WEST =4
</code></pre>

<p>定义好之后，你就可以用这些名字而不是数字了</p>

<pre><code>walk(NORTH)
look(EAST)
</code></pre>

<p>然而，很多时候，这些名字对应的数值是不相关的(只要它们是唯一的)你所要做的只是区分这四个方向而已
Ruby提供了一个很简单的替代方案:符号(Symbols).Symbols只是常量名字，不过你无需定义它，并且它们也保证是唯一的，一个符号常量以:开头，紧跟着字符串
walk(:north)
look(:east)
无须为一个symbol赋任何值,Ruby已经为你考虑好了.Ruby保证不管符号出现在你，一个特定和符号总量有相同的值，因此，你可以按如下方式使用symbol</p>

<pre><code>def walk(direction)
    if direction == :north
    # ...
    end
 end
</code></pre>

<p>symbols通常被用来当作hash的key，我们可以将我们之前写的hash写为以下形式</p>

<pre><code>    inst_section = {
    :cello =&gt; 'string', 
    :clarinet =&gt; 'woodwind', 
    :drum =&gt; 'percussion', 
    :oboe =&gt; 'woodwind', 
    :trumpet =&gt; 'brass', 
    :violin =&gt; 'string'
}
</code></pre>

<p>事实上，symbols是如此频繁地被当作hash的键，ruby提供了一个更简洁的语法，你可以用name:value的形式来创建hash，如果key是symbols的话</p>

<pre><code>inst_section = {
    cello: 'string', 
    clarinet: 'woodwind', 
    drum: 'percussion', 
    oboe: 'woodwind', 
    trumpet: 'brass', 
    violin: 'string'
}
puts "An oboe is a #{inst_section[:oboe]} instrument"
produces:
An oboe is a woodwind instrument
</code></pre>

<h4>条件语句</h4>

<p>if语句</p>

<pre><code>today = Time.now
if today.saturday?
    puts "Do chores around the house"
elsif today.sunday?
     puts "Relax"
else
     puts "Go to work" 
end
</code></pre>

<p>produces:</p>

<pre><code>Go to work
</code></pre>

<p>较短的if语句也可以这么写</p>

<pre><code>puts "Danger, Will Robinson" if radiation &gt; 3000
</code></pre>

<p>while语句</p>

<pre><code>while weight &lt; 100 and num_pallets &lt;= 5
         pallet  = next_pallet()
         weight += pallet.weight
         num_pallets += 1
end
</code></pre>

<p>较短的while语句也可以这么写</p>

<pre><code>    square = 4
    square = square*square while square &lt; 1000
</code></pre>

<p>ruby中的许多语句返回一个值，这意味着你可以用它们作为条件判断，比如,内核方法gets从标准输入流中返回下一行或者当到达文件的末尾时会返回nil，由于Ruby有条件语句中将nil视为假的，你可以用以下代码来处理文件对应的行</p>

<pre><code>while line = gets 
    puts line.downcase
end
</code></pre>

<h4>正则表达式</h4>

<pre><code>/\d\d:\d\d:\d\d/    # a time such as 12:34:56
/Perl.*Python/      # Perl, zero or more other chars, then Python
/Perl Python/       # Perl, a space, and Python
/Perl *Python/     # Perl, zero or more spaces, and Python
/Perl +Python/     # Perl, one or more spaces, and Python
/Perl\s+Python/   # Perl, whitespace characters, then Python
/Ruby (Perl|Python)/ # Ruby, a space, and either Perl or Python
</code></pre>

<p>结果if语句使用</p>

<pre><code>line = gets
if line =~ /Perl|Python/
    puts "Scripting language mentioned: #{line}" 
end
</code></pre>

<p>正则表达式的替代方法</p>

<pre><code>line = gets
newline = line.sub(/Perl/, 'Ruby') # replace first 'Perl' with 'Ruby'   newerline =     newline.gsub(/Python/, 'Ruby') # replace every 'Python' with 'Ruby'
</code></pre>

<h4>Blocks和迭代器</h4>

<p>我们首先看看代码块(code blocks),code blocks是一串代码，你能将它与方法调用结合起来,就当它们是参数一样,这是难以置信的强大特性
你用代码块来实现回调(但比java中的匿名内部类简单),把它们像C中的函数指针那样来传递(比C函数指针更简单)，或者实现迭代器的功能
代码块的形式如下</p>

<pre><code>{ puts "Hello" }
</code></pre>

<p>或</p>

<pre><code>do
  club.enroll(person)
  person.socialize
end
</code></pre>

<p>&ldquo;{}&#8221;block主要用在单行中,&#8221;do&hellip;.end&#8221;主要用在多行中
你可以将block放在一个调用方法的尾部</p>

<pre><code>greet { puts "Hi" } //greet是方法
</code></pre>

<p>如果方法有参数，则将block放在这些参数的最后</p>

<pre><code>verbose_greet("Dave", "loyal customer") { puts "Hi" }
</code></pre>

<p>方法可以用Ruby提供的yield来调用block多次</p>

<pre><code>def call_block      puts "Start of method" yield        yield       puts "End of method"    end
    call_block { puts "In the block" }
</code></pre>

<p>打印结果</p>

<pre><code>    Start of method
    In the block
    In the block
    End of method
</code></pre>

<p>调用yield的时候可以带参数,这些参数将被传到block中去，在block中，你将这些被接收的参数用|params&hellip;|的形式列出来,如下</p>

<pre><code>def who_says_what yield("Dave", "hello") 
    yield("Andy", "goodbye")    end
who_says_what {|person, phrase| puts "#{person} says #{phrase}"}
</code></pre>

<p>打印结果</p>

<pre><code>Dave says hello Andy says goodbye
</code></pre>

<p>Code blocks广泛用在ruby的库中用来实现迭代器</p>

<pre><code>    animals = %w( ant bee cat dog ) # create an array
animals.each {|animal| puts animal }    # iterate over the contents
</code></pre>

<p>produces:</p>

<pre><code>ant bee cat dog再来看几个例子
    [ 'cat', 'dog', 'horse' ].each {|name| print name, " " } 
5.times { print "*" }
3.upto(6) {|i| print i }
('a'..'e').each {|char| print char }
puts
</code></pre>

<p>produces:</p>

<pre><code>cat dog horse *****3456abcde####读写

printf("Number: %5.2f,\nString: %s\n", 1.23, "hello")
</code></pre>

<p>produces:    Number:  1.23,    String: hello有很多方法可以将输入读入程序中，最常见的gets方法，它返回标准输入流的下一行</p>

<pre><code>line = gets print line
</code></pre>

<h4>命令行参数</h4>

<p>当你从命令行运行一个Ruby程序时，你能传送一些参数给它，你能用两种不同的参数来访问这些参数
首先，ARGV就是这些参数组成的数组，假设有一个叫cmd_line.rb的程序如下</p>

<pre><code>puts "You gave #{ARGV.size} arguments" 
p ARGV
</code></pre>

<p>当我们向此程序传入这些参数时，我们参看到输出结果</p>

<pre><code>$ ruby cmd_line.rb ant bee cat dog 
You gave 4 arguments    ["ant", "bee", "cat", "dog"]
</code></pre>

<p>通常，传入的参数是你要处理的文件的名字，这种情况下，你应该用第二种技巧,<code>ARGF</code>,它是一种特别的I/O对象，代表了通过命令行传入的文件名的所有内容, 我们之后再学习它</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Ruby]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/21/chu-shi-ruby/"/>
    <updated>2014-07-21T22:23:15+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/21/chu-shi-ruby</id>
    <content type="html"><![CDATA[<p>在终端中输入irb与ruby交互</p>

<pre><code>    2.1.2 :002 &gt; def sum(n1, n2)
    2.1.2 :003?&gt;   n1+n2
    2.1.2 :004?&gt;   end
     =&gt; :sum
    2.1.2 :005 &gt; sum(3, 4)
     =&gt; 7
</code></pre>

<p>通常我们将ruby程序写在文件里，假设现在有一个myprog.rb的程序如下</p>

<pre><code>    gettingstarted/myprog.rb        puts "Hello, Ruby Programmer"       puts "It is now #{Time.now}"
</code></pre>

<p>现在我们可以敲入以下命令来运行程序</p>

<pre><code>    $ ruby myprog.rb        Hello, Ruby Programmer)     It is noew 2014-07-21 22:27:47 +0800
</code></pre>

<p>在Unix中，我们可以在程序的第一行添加&#8221;shebang&#8221;的符号，如下</p>

<pre><code>    #! /usr/bin/ruby
    puts "Hello, Ruby Programmer" 
    puts "It is now #{Time.now}"
</code></pre>

<p>如果你用<code>chmod+x myprog.rb</code>命令让此文件成为可执行程序，Unix能让你将此文件作为一个程序来运行</p>

<pre><code>    $ ./myprog.rb       Hello, Ruby Programmer      It is now 2013-05-27 12:30:36 -0500####Ruby文档:RDoc和ri
</code></pre>

<p>Ruby库越来越大，已经不可能将有关它们的文档写进一本书中了，ruby的标准库有9000多个！幸运的是，一种为这些方法(类，模块)提供文档的方法是存在的，许多在它们内部写文档的方法是采用一个RDoc的工具
如果一个源文件用RDoc来文档注释，那么它的文档是可以被提取出来并被转化成HTML和ri的形式的
ri是一个浏览本地RDoc的，命令行浏览器，许多ruby的发行版现在用ri程序来安装文档资源
要发现针对某个类的文档，我们可以在命令行敲入<code>ri ClassName</code>的形式来查看,如以下</p>

<pre><code>$ ri GC
----------------------------------------------------------------------------------- 
The GC module provides an interface to Ruby's garbage collection mechanism. Some of the underlying  methods are also available via the ObjectSpace module.           You may obtain information about the operation of the GC through GC::Profiler.    -----------------------------------------------------------------------------------    Class methods:      count, disable, enable, malloc_allocated_size, malloc_allocations,      start, stat, stress, stress=    Instance methods:      garbage_collect
</code></pre>

<p>查看某个指定类的方法</p>

<pre><code>ri GC::enable
--------------------------------------------------------------- GC::enable GC.enable =&gt; true or false   --------------------------------------------------------------------------- Enables garbage collection, returning true if garbage collection was    disabled.   GC.disable  GC.enable   GC.enable   #=&gt; false   #=&gt; true    #=&gt; false   
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第八章-静态库和动态库]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/16/head-first-cdi-ba-zhang-jing-tai-ku-he-dong-tai-ku/"/>
    <updated>2014-07-16T21:54:55+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/16/head-first-cdi-ba-zhang-jing-tai-ku-he-dong-tai-ku</id>
    <content type="html"><![CDATA[<p>这一章中，我们将学习如何创建自己的动态库，并在多个程序中用到同样的代码
来看下以下代码
加密代码</p>

<pre><code>//encyrpt.h
void encrypt(char *message)

//encrypt.c
#include "encrypt.h"    void encrypt(char *message) {       while (*message) {          *message = *message ^ 31; message++;        }    }
</code></pre>

<p>校验代码</p>

<pre><code>//checksum.h
int checksum(char *message);

//checksum.c
#include "checksum.h"   int checksum(char *message) {       int c = 0;      while (*message) {      c += c ^ (int)(*message);       message++; }        return c; 
}
</code></pre>

<p>加密和校验两段代码构成了我们接下来将要进行的密码库的基础
假设我们已经将以上的代码编译成了目标代码</p>

<pre><code>gcc -c encrypt.c -o encrypt.o
gcc -c checksum.c -o checksum.o
</code></pre>

<p>现在我们写一段测试程序</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;encrypt.h&gt; 
#include &lt;checksum.h&gt;   int main() {        char s[] = "Speak friend and enter"; encrypt(s);        printf("Encrypted to '%s'\n", s); printf("Checksum is %i\n", checksum(s)); encrypt(s);      printf("Decrypted back to '%s'\n", s); printf("Checksum is %i\n", checksum(s));     return 0;   }
</code></pre>

<p>当我们编译时，会出现以下错误</p>

<pre><code>gcc test_code.c encrypt.o checksum.o -o test_code 
test_code.c:2:21: error: encrypt.h: No such file or directory 
test_code.c:3:22: error: checksum.h: No such file or directory
</code></pre>

<p>错误在以下两行</p>

<pre><code>#include &lt;encrypt.h&gt; 
#include &lt;checksum.h&gt;
</code></pre>

<p>尖括号将在标准头文件目录中寻找，在Mac或Linux系统中，编译器在以下目录中寻找这些文件</p>

<pre><code>/user/local/include     //此目录下通常存放一些第三方库
/user/include           //此目录通常存放一些操作系统相关的头文件
</code></pre>

<h4>该如何共享代码</h4>

<p>有时你想写一些代码用在很多程序中，无论它们是在不同的文件夹下，还是在整个电脑中，你该如何做呢?
一般来说我们想在多个程序中共享两种文件,头文件(.h)和目标文件(.o),让我们看看如何操作</p>

<h5>共享.h头文件,有以下几种文件</h5>

<ol>
<li><p>将它们存储在标准目录中
如果你将你的头文件拷贝到标准目标如/usr/local/include中，你可以用尖括号来引用它们</p>

<pre><code>  #include&lt;encrypt.h&gt;
</code></pre></li>
<li><p>在include中写下此文件所在的完整路径
假设你的文件存储在/my_header_files目录下,你可以按以下方式来引用代码</p>

<pre><code>  #include "/my_header_files/encrypt.h"
</code></pre></li>
<li><p>你可以告诉编译器去哪来搜寻它们
用gcc编译时加上-I选项</p>

<pre><code>  gcc -I /my_header_files test_code.c ... -o test_code
</code></pre>

-I选项告诉gcc编译器在/my_header_files这个目录下你能找到所需要的头文件，<code>注意</code>，gcc仍将在标准目录中寻找头文件，但是<code>首先</code>它将在-I选项对应的目录中寻找此文件

<h5>通过写完整路径的方式来共享.o目标文件</h5>

<pre><code>  gcc -I/my_header_files test_code.c /my_object_files/encrypt.o /my_object_files/checksum.o -o test_code
</code></pre>

/my_object_files目录就像是存储目标文件的中枢,用目标文件的完整路径意味着你不需要为每一个程序拷贝一份单独的目标文件
如果只有一两个需要共享的目标文件还好，如果有许多目标文件呢，不是要在所有的目标文件前都加上它们的完整路径了?
<code>解决方法</code>:你可以将许多目标文件打包成一个.a文件,这样你一次就能告诉编译器所有目标文件的所在了(都在.a文件里)

<h6>让我们看下如何打包</h6>

<p>我们用过.zip和.tar文件，这些文件包含了多个文件,.a文件与此类似，一个文件包含了多个.o文件
打开命令行，切换到库目录下，比如/usr/lib里。在此目录上，你将看到许多.a文件,有一个nm的命令可以用来查看.a文件里有哪些.o文件
<img src="http://xiekunRonaldo.github.io/images/2014/7/libl.png">
<img src="http://xiekunRonaldo.github.io/images/2014/7/nm.png">
在我们用.a文件编译程序之前,先看看如何将encrypt.o和checksum.o文件存储到一个.a文件里吧
用ar命令来创建一个.a文件</p>

<pre><code>  ar -rcs libhfsecurity.a encrypt.o checksum.o
</code></pre>

<p>rcs三个选项的解释如下
-r表示如果(.a)文件已经存在,文件将被更新
-c表示.a创建成功与否都无任何反馈信息
-s告诉ar在文件的开头创建一个索引
注意到了吗，所有的.a文件都有lib<something>.a形式的命名,名字以lib开头，因为它们是静态库，我们将很快学习到什么是静态库</p></li>
</ol>


<p>创建好了标准库文件后，该如何使用呢</p>

<ul>
<li><p>将它放到一个标准目录如/user/local/lib里
一些码农在确认.a文件能工作后喜欢将.a文件放在一标准库里，在Linux和Mac里/usr/local/lib目录是一个很好的选择，因为这个目录就是专门用来放置你自己的库文件的</p></li>
<li><p>将.a文件放到你自己喜欢放置的库文件目录下,如/my_lib中
既然库创建好了，那我们来看看怎么利用这些库来编译用到这些库的程序</p></li>
<li>如果你将.a文件放到标准库目录中,你可以按以下方式来编译代码
<img src="http://xiekunRonaldo.github.io/images/2014/7/nm.png"></li>
<li><p>如果你是将.a文件放在你自己的库文件目录下，可按以下方式来编译代码</p>

<pre><code> gcc test_code.c -L/my_lib -lhfsecurity -o test_code
</code></pre>

<p>-L选项告诉编译器去哪个目录寻找库文件</p></li>
</ul>


<p>现在有一个搞安全的哥们在用最新的加密库编译一个银行相关的程序时遇到了一点麻烦，他把源码和 ecnrypt，checksum 的源码放在了同一个目录下，他想要在同一个目录下创建一个libhfsecurity.a库并用它去编译程序，你能帮助它修改它的makefile文件吗
这个程序叫band_vault，它用了以下的include语句</p>

<pre><code>#include&lt;encrypt.h&gt;
#include&lt;checksum.h&gt;
</code></pre>

<p>由于用到了尖括号，编译器需要使用用-I选项告知头文件在哪
makefile文件如下
<img src="http://xiekunRonaldo.github.io/images/2014/7/bank_vault_makefile.png"><br/>
-L选项必须出现在源文件后面才行
从.a文件中提取中某个目标文件</p>

<pre><code>ar -x libhfsecurity.a encrypt.o
</code></pre>

<p>再来看一个例子</p>

<pre><code>//hfcal.c
#include &lt;stdio.h&gt; 
#include &lt;hfcal.h&gt;

void display_calories(float weight, float distance, float coeff) {      printf("Weight: %3.2f lbs\n", weight);      printf("Distance: %3.2f miles\n", distance);        printf("Calories burned: %4.2f cal\n", coeff * weight * distance);  }

//elliptical.c
#include &lt;stdio.h&gt;
#include &lt;hfcal.h&gt;  int main() {        display_calories(115.2, 11.3, 0.79);        return 0;   }
</code></pre>

<p>下面我们来看看如何编译代码</p>

<ol>
<li><p>首先，创建hfcal.o文件,hfcal.h头文件存储在./includes</p>

<pre><code> gcc -I./includes -c hfcal.c -o hfcal.o
</code></pre>

<p>-c选项表示只是创建目标文件，不链接</p></li>
<li><p>创建elliptical.o文件</p>

<pre><code> gcc -I./includes -c elliptical.c -o elliptical.o
</code></pre>

<p>同样的，你需要告诉编译器头文件在./includes下的</p></li>
<li><p>你需要从hfcal.o中创建一个.a文件，并将它存储在./libs中</p>

<pre><code> ar -rcs ./libs/libhfcal.a hfcal.o
</code></pre></li>
</ol>


<p>被打包的libhfcal.a文件将被放在./libs目录下</p>

<ol>
<li><p>最后，用elliptical.o和libhfcal.a创建elliptical可执行文件</p>

<pre><code> gcc elliptical.o -L./libs -lhfcal -o elliptical
</code></pre></li>
</ol>


<p>现在你能执行elliptical可执行文件了</p>

<pre><code>&gt; ./elliptical  Weight: 115.20 lbs  Distance: 11.30 miles   Calories burned: 1028.39 cal    &gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第七章笔记-高级函数]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/15/head-first-cdi-qi-zhang-bi-ji-gao-ji-han-shu/"/>
    <updated>2014-07-15T22:11:00+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/15/head-first-cdi-qi-zhang-bi-ji-gao-ji-han-shu</id>
    <content type="html"><![CDATA[<p>导读:这一章我们将学习函数的一些高级特性,如</p>

<ol>
<li>将函数作为一个参数进行传递</li>
<li>用比较函数进行排序</li>
<li>用可变参数的函数让你的代码变得更加灵活</li>
</ol>


<h5>函数指针</h5>

<pre><code>int (*warp_fn)(int);
</code></pre>

<p>将函数指针当作参数传递给函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void find(int (*mactch)(char *)){
</span><span class='line'>  if (match(ADS[i])){
</span><span class='line'>      //char *ADS[] = {"one", "two"};
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>用函数指针来排序</h5>

<p>C标准库里有一个排序指针如下</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/qsort.png"></p>

<p>假设你有以下整形数组，你想按升序排序，该如何写排序函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int scores[] = {543,323,32,554,11,3,112};
</span><span class='line'>int compare_scores(const void* score_a, const void* score_b)
</span><span class='line'>{
</span><span class='line'>  int a = *(int*)score_a; 
</span><span class='line'>  int b = *(int*)score_b;
</span><span class='line'>  return a-b;
</span><span class='line'>}
</span><span class='line'>qsort(scores, 7, sizeof(int), compare_scores);</span></code></pre></td></tr></table></div></figure>


<p>如果是一个char *p[]数组呢，该如何写compare函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int compare_names(const void* a, const void* b){
</span><span class='line'>  char** sa = (char**)a;
</span><span class='line'>  char** sb = (char**)b; 
</span><span class='line'>  return strcmp(*sa, *sb);￼￼￼￼￼￼￼￼
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>函数指针数组</h5>

<pre><code>//dump,second_change, marriage都是函数
void (*replies[])(response) = {dump, second_chance, marriage};
</code></pre>

<p>判断调用的是否是某个函数</p>

<pre><code>enum response_type {DUMP, SECOND_CHANCE, MARRIAGE};
replies[SECOND_CHANCE] == second_chance完整的demo
typedef struct {    char *name; enum response_type type; } response;    enum response_type {DUMP, SECOND_CHANCE, MARRIAGE};
void (*replies[])(response) = {dump, second_chance, marriage};

int main()
{
    response r[] = {            {"Mike", DUMP}, {"Luis", SECOND_CHANCE},            {"Matt", SECOND_CHANCE}, {"William", MARRIAGE}      };
    int i;
    for (i = 0; i &lt; 4; i++){
        (replies[r[i].type])(r[i]);
    }
}
</code></pre>

<h5>可变参函数</h5>

<p>demo1</p>

<pre><code>#include &lt;stdarg.h&gt;
void print_ints(int args, ....){
    va_list ap; 
    va_start(ap, args);
    int i;
    for (i = 0; i &lt; args; i++) {            printf("argument: %i\n", va_arg(ap, int));      }
    va_end(ap);
}
</code></pre>

<p>注:va_end,va_start是宏</p>

<p>demo2</p>

<pre><code>enum drink {    MUDSLIDE, FUZZY_NAVEL, MONKEY_GLAND, ZOMBIE };
printf("Price is %.2f\n", total(3, MONKEY_GLAND, MUDSLIDE, FUZZY_NAVEL));
double total(int args, ...)
{
    double total = 0;       va_list ap;
    va_start(ap, args);             int i;
    for(i = 0; i &lt; args; i++) {         enum drink d = va_arg(ap, enum drink);          total = total + price(d);       }       va_end(ap);     return total;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第六章-数据结构和动态内存]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/13/head-first-cdi-liu-zhang-shu-ju-jie-gou-he-dong-tai-nei-cun/"/>
    <updated>2014-07-13T11:19:10+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/13/head-first-cdi-liu-zhang-shu-ju-jie-gou-he-dong-tai-nei-cun</id>
    <content type="html"><![CDATA[<p>这一章中我们将学习到如何用结构体指针来将自定义的数据类型连接成一个更大更复杂的数据结构，我们通过创建链表来了解结构体指针的用处，也将学习到如何在堆上分配内存，并在你用完之后释放它，我们也将学习到valgrind的使用</p>

<h4>在堆上分配内存以及释放内存</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct island{ 
</span><span class='line'>  char *name;
</span><span class='line'>  char *opens;
</span><span class='line'>  char *closes;
</span><span class='line'>  island *next;   } island;
</span><span class='line'>
</span><span class='line'>#include&lt;stdlib.h&gt;
</span><span class='line'>island *p = malloc(sizeof(island))
</span><span class='line'>free(p);</span></code></pre></td></tr></table></div></figure>


<p>以下函数有何问题</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>island* create(char *name) {
</span><span class='line'>      island *i = malloc(sizeof(island)); 
</span><span class='line'>      i-&gt;name = name;
</span><span class='line'>      i-&gt;opens = "09:00";
</span><span class='line'>      i-&gt;closes = "17:00";
</span><span class='line'>      i-&gt;next = NULL;
</span><span class='line'>      return i; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当在程序里调用如下代码时</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char name[80];fgets(name, 80, stdin);island *p_island0 = create(name); 
</span><span class='line'>fgets(name, 80, stdin);island *p_island1 = create(name);</span></code></pre></td></tr></table></div></figure>


<p>p_island0和p_island1的name是一样的！！！原来是create函数传入的只是name的地址，两者的地址是一样的，你必须用strdup函数copy字符串,故以上create函数的代码中的</p>

<pre><code>i-&gt;name = name;
</code></pre>

<p>可改为</p>

<pre><code>i-&gt;name = strdup(name);
</code></pre>

<p>不过要记得用strdup()拷贝字符串，最后需要用free()将此拷贝字符串release掉</p>

<h3>valgrind可用来检测内存泄漏</h3>

<p>valgrind能模拟在堆上分配的数据，它通过创建模拟的malloc()版本来工作，当你的程序想要分配一些堆上的内存时，valgrind将截获你对malloc()和free()的调用并运行它自己的模拟版本的malloc()和free(),valgrind版本的malloc()将记录调用它的那些代码以及它所分配的那部分内存,当你的程序终止时,valgrind将会报告任何堆上还存在的数据并且告诉你这些数据由哪些代码调用产生的</p>

<h4>准备:添加debug信息</h4>

<p>用valgrind运行之前你不需要对你的代码作任何操作，你甚至不需要重新编译代码，但是为了更好地利用valgrind，代需要确保你的可执行代码包含debug信息，debug信息是在编译代码后嵌入到可执行文件里的额外数据，比如代码对应的行数，如果debug信息存在了，valgrind将能给你许多内存泄漏的具体信息
测试所用程序<a href="https://gist.github.com/xiekunRonaldo/cdde073cac5636270322">spies</a>
用valgrind结合&mdash;leak-check=full选项进行以下测试</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/valgrind1.png"></p>

<p>从上图可以看出，当SPIES退出后，堆上已无对象，再运行一遍试试看，然后告诉程序有一个Hayden Fantucci的嫌疑人会怎样</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/valgrind2.png"></p>

<p>这次,valgrind发现了内存泄漏,从上图可看出，在程序结束时，堆上有19个字节的空间未释放,valgrind告诉你以下信息</p>

<ol>
<li>19个字节的内存分配了但未释放</li>
<li>分配了11次的内存空间，但只释放了10次</li>
<li>这几行给了我们什么线索</li>
<li>为什么是19个字节？说明了什么?
从以个信息可得,&ldquo;Loretta Barnsworth&#8221;占了19个字节,strdup导致了内存泄漏！</li>
<li>valgrind是如何截获对malloc()和free()的调用的
答:malloc()和free() 实际上是标准库函数，不过valgrind包含一个它自己的malloc()和free()版本的标准库函数，当你用valgrind来运行程序时，你的程序将用valgrind的malloc()和free()函数，而非C的标准库函数</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第五章学习笔记]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/13/head-first-cdi-wu-zhang-xue-xi-bi-ji/"/>
    <updated>2014-07-13T09:22:09+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/13/head-first-cdi-wu-zhang-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h4>Union的初始化</h4>

<ol>
<li><p>用.来初始化</p>

<pre><code> typedef union { 
     short count;
     float weight;
     float volume;       } quantity;
 //By name       quantity q = {.weight=1.5};
 //By dot notation
 quantity q;
 q.volume = 3.7;
</code></pre></li>
<li><p>struct也可以按名字(Designated initializer)来进行初始化
         typedef struct {            const char *color;          int gears;          int height;     } bike;     bike b = {.height=17, .gears=21};</p></li>
</ol>


<p>union可以用在struct中</p>

<pre><code>typedef struct {        const char *name;       const char *country;        quantity amount;    } fruit_order;
</code></pre>

<p>你可以通过.或->来访问成员值</p>

<pre><code>fruit_order apples = {"apples", "England", .amount.weight=4.2};
</code></pre>

<p>假设有一下定义</p>

<pre><code>typedef union { 
    float lemon;
    int lime_pieces;    } lemon_lime;
typedef struct {        float tequila;      float cointreau;        lemon_lime citrus;  } margarita;
</code></pre>

<p>则以下定义是错误的</p>

<pre><code>margarita m;    m = {2.0, 1.0, {0.5}};  //编译器会认为是数组
</code></pre>

<p>以下定义才是对的</p>

<pre><code>margarita m = {2.0, 1.0, {0.5}};
</code></pre>

<p>在一个union里，可能会有很多可能的值，但一旦被赋值，你没法知道它存储的值的类型
我们可能为某些字段设定了值却访问了另一个字段，这可能出现大问题,假设有以下程序</p>

<pre><code>#include &lt;stdio.h&gt; 
typedef union { 
  float weight;   int count;    } cupcake;
    int main() {        cupcake order = {2};        printf("Cupcakes quantity: %i\n", order.count);     return 0;   }
</code></pre>

<p>运行程序将会出现以下结果</p>

<pre><code>gcc badunion.c -o badunion &amp;&amp; ./badunion 
Cupcakes quantity: 1073741824可以用enum来避免此类问题
</code></pre>

<h4>Bitfiled</h4>

<p>bitfield能让你指定struct里的field能有几位，你可以按如下方式定义struct</p>

<pre><code>typedef struct {
    unsigned int low_pass_vcf:1;
    unsigned int filter_coupler:1;  } synth;
</code></pre>

<p>用bitfield，你能让每个field都只占一位
如果你有一连串的bitfields,计算机能将它们排列压缩以节省空间，所以如果你有8个1位的bitfields，电脑将会把它们存储到一个字节里
bitfield的不仅可以节省空间，也可以读写某些二进制文件</p>

<ul>
<li>bitfield应该被声明为unsigned int</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第四章学习笔记]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/01/head-first-cdi-si-zhang-xue-xi-bi-ji/"/>
    <updated>2014-07-01T19:23:15+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/01/head-first-cdi-si-zhang-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p><code>#include &lt;limits.h&gt;</code>此头文件包含一些整型如int和char的值,可打印整型的最大最小值,如</p>

<pre><code>printf("The value of INT_MAX is %i\n", INT_MAX); 
printf("The value of INT_MIN is %i\n", INT_MIN);
</code></pre>

<p><code>#include &lt;float.h&gt;</code>此头文件包含一些浮点型如float和double的值,可打印浮点的最大最小值,如</p>

<pre><code>printf("The value of FLT_MAX is %f\n", FLT_MAX);
printf("The value of FLT_MIN is %.50f\n", FLT_MIN);
</code></pre>

<p>如果你想知道char,short,double或long的具体细节呢,没问题，只要将INT和FLT替换成CHAR,DBL,SHRT,LNG即可
不过你会发现在不同的机器上，这些值都是不一样的，因为C在不同的OS和处理器上用了不同的数据类型，这么做允许它最大限度地利用了硬件的特性,那么C是如何做的呢
当C被发明时，许多机器是8位的，现在，许多机器是32位或64位的，由于C并不指定数据类型的确切大小，这样，它有很好的移植性，随着越来越多的机器被发明出来，C将能够有限地利用它们</p>

<p><code>这里我们说的8位和64位是什么意思</code>
一台计算机的位大小实际上表示多种情况，比如它的CPU指令的大小或者CPU一次能从内存中读取的数据大小，位大小是一台计算机能处理地最优大小
<code>那么这和ints或doubles的大小有何关系呢</code>
如果一台计算机能最优地处理32位的数，那么基本的数据类型，如int也会被设置成32位
<code>floats和doubles是如何存储的</code>
<a href="http://tinyurl.com/6defkv6">http://tinyurl.com/6defkv6</a>
一段代码引发的思考
<img src="http://xiekunRonaldo.github.io/images/2014/7/errorcode.png"></p>

<p>运行以上代码</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/errorcommandline.png"></p>

<p><code>error: conflicting types for 'add_with_tax'</code>此话何解</p>

<p><code>当编译器看到以下的代码时会发生什么</code></p>

<pre><code>printf("Total so far: %.2f\n", add_with_tax(val));
</code></pre>

<p>编译器将看到一个对不认识的函数的调用，它并不抱怨，编译器会猜想它会在源文件的随后部分发现更多此函数的信息，不幸的是，这就是问题所在,编译器会想，这个函数我从来没见过，但我要先记录它以便在源文件的后半部分对它进行处理
<code>问题是编译需要知道此函数的返回类型</code>当然，编译器此时并不知道函数的返回类型，所以它就作 了一个假设，编译器假设此函数返回int值
<code>但当编译器到达此函数的定义时，它将返回一个“conflicting types for ‘add_with_tax’”错误</code>
这是因为编译器认为它看到了两个同名函数，一个是实际存在文件中的函数，一个则是编译器假设的，返回int型的函数
<code>那么如何解决此问题呢，你可能会认为，把函数放在调用代码的前面按正确地顺序书写不就ok了吗</code>
这么做确实可以解决问题，但<code>修改函数的顺序是件很痛苦的事</code>,假设有以下情况，你添加了一个很棒的新函数</p>

<pre><code>int do_whatever(){...}  float do_something_fantastic(int awesome_level) {...} int do_stuff() {  do_something_fantastic(11); }
</code></pre>

<p>此时你改变注意想在do_whatever调用do_something_fantastic函数呢，那你不得不将do_something_fantastic函数移do_whatever前面,很麻烦，更麻烦的是，有些递归函数将在它被定义前调用自己,如</p>

<pre><code>float ping(){
    pong();
}
float pong(){
    ping();
}
</code></pre>

<p>如果你有两个相互调用的函数，其中一个必然会在它定义之前被调用，这样必然性错误，解决方法是
<code>将声明和定义分隔开来</code>,将声明放在头文件(.h)将定义放在实现文件(.c)
<code>要点</code>
* 从以上可得知实际上你无须为返回值为int函数声明
将多个源文件编译成一个可执行程序</p>

<pre><code>gcc message_hider.c encrypt.c -o message_hider
</code></pre>

<p><code>编译</code>   gcc -c *.c</p>

<p><code>链接</code>   gcc *.o -o launch</p>

<p>问题是如果有非常多的源文件，当你修改一个，你需要把所有的这些源文件全都编译一遍，要浪费很多时间!那如何解决呢</p>

<h4>make工具</h4>

<p>make是一种能自动编译你的源文件的一种工具
<img src="http://xiekunRonaldo.github.io/images/2014/7/theater.png">
如上所未，你如何断定thruster.o文件需要重新编译呢，看时间戳，如果thruster.o文件早于thruster.c,thruster.o就需要重新创建了，相当简单的规则，不是吗，既然明白了规则，我们就可以用make工具自动进行此过程，make将会比较源文件和目标文件的时间戳，如果某些目标文件的时间戳早于源文件，则它将对这些源文件重新编译，但在此之前，你需要告诉make这个工具一些信息，包括文件的信赖关系等，你需要确切地告诉它你想要如何编译代码</p>

<h4>make需要知道哪些东西</h4>

<p>如果你想将thruster.c编辑成一个叫thruster.o的目标文件,依赖文件和配方分别是什么,thruster.o是目标文件,因为这是你想要生成的文件，thruster.c就是信赖文件，因为它是编译所需的转化为thruster.o的源文件，那么配方是什么呢，是将thruster.c转化为thruster.o的编译器命令</p>

<pre><code>gcc -c thruster.c
</code></pre>

<p>明白了吗？如果你告诉make工具相应的信赖文件和配方,你就能让make工具知道何时它需要重新编译成thruster.o了
但你可以更进一步，一旦你编译了thruster.o的目标文件，你就将用它创建launch程序了，也就是说，launch文件也可以被设置成一个目标，因为它是你要产生的文件，launch的依赖文件是所有的.o的目标文件，配方是以下命令</p>

<pre><code>gcc *.o -o launch
</code></pre>

<p>一旦make知道了所有的依赖文件和规则，你所要做的就是告诉它去创建launch文件了
<img src="http://xiekunRonaldo.github.io/images/2014/7/make.png"></p>

<p>以下是make文件的内容
<img src="http://xiekunRonaldo.github.io/images/2014/7/makefile.png"></p>

<p>最后输入以下命令
<img src="http://xiekunRonaldo.github.io/images/2014/7/makelaunch.png">
你能看到make能够执行创建launch程序所需的命令，那么我们看看如果你改变了thruster.c文件然后重新执行make命令会发生什么
<img src="http://xiekunRonaldo.github.io/images/2014/7/remake.png">
我们可以看到，它只编译thruster.o了，然后重新链接</p>

<pre><code>注:由于make文件调用OS底层的操作系统，有时同一个make文件并不适用在不同的OS上
</code></pre>

<p>除了编译代码，make也可用作command-line installer,或源码管理工具，实际上，有命令行上你几乎可以把make用在任何你想执行的任务上</p>

<p>如果你觉得make还不够自动化，你可以试试<a href="http://www.gnu.org/software/autoconf/">autoconf</a>用来产生make文件</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C 第三章学习笔记-创建小工具]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/06/29/head-first-c-di-san-zhang-xue-xi-bi-ji-chuang-jian-%5B%3F%5D-xie-xiao-gong-ju/"/>
    <updated>2014-06-29T18:44:13+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/06/29/head-first-c-di-san-zhang-xue-xi-bi-ji-chuang-jian-[?]-xie-xiao-gong-ju</id>
    <content type="html"><![CDATA[<h3>要点</h3>

<p>Linux/Unix系统有很多小工具,这些小工具执行一些特定的任务，比如读写文件，过滤数据等，这些工具都只负责处理自己的事情，各司其职，无需顾虑其他的工具所做的事，这样做的好处可以如果你需要处理一个比较复杂的任务，你可以将它分割成各个小任务，每个小任务由相应的工具完成，就有效地做到了解耦,同时这么做也使得每个小程序更容易调试</p>

<p>此章介绍我们将学习如何了解命令行参数，处理流信息，重定向，并快速地将各个工具组合起来</p>

<p>本章我们主要以将以下数据格式</p>

<pre><code>42.363327,-71.097588,Speed = 23 
42.363255,-71.096710,Speed = 17
</code></pre>

<p>转换成以下的JSON形式进行讨论分析</p>

<pre><code>[{latitude: 42.363400, longitude: -71.098465, info: 'Speed = 21'},
 {latitude: 42.363327, longitude: -71.097588, info: 'Speed = 23'}, 
 {latitude: 42.363255, longitude: -71.096710, info: 'Speed = 17'},  ...]
</code></pre>

<p>以下程序(geo2json)能从命令行中读取以逗号分隔的行，并将它以JSON的形式展示出来</p>

<pre><code>//geo2json
#include &lt;stdio.h&gt;  int main() {        float latitude;     float longitude;        char info[80]; intstarted= 0 ￼ ￼ ;      puts("data=[");         while (scanf("%f,%f,%79[^\n]", &amp;latitude, &amp;longitude, info) == 3) {         if (started)                printf(",\n");          else                started= 1 ;
        if ((latitude &lt; -90.0) || (latitude &gt; 90.0)) {              printf(“Invalid latitude: %f\n”, latitude);             return 2;
        }           if ((longitude &lt; -180.0) || (longitude &gt; 180.0)) {              printf(“Invalid longitude: %f\n”, longitude);               return 2;           }           printf("{latitude: %f, longitude: %f, info: '%s'}", latitude , longitude , info );      }       puts("\n]");        return 0;   }
</code></pre>

<p>scanf()会返回输入的参数个数</p>

<pre><code>while (scanf("%f,%f,%79[^\n]", , , ) == 3)
</code></pre>

<ul>
<li>注意以上的[^\n]表示第三个输入参数的内容为除换行以外的字符串</li>
</ul>


<p>以上程序让你在键盘上输入GPS数据，将将它们在JSON的形式输出到屏幕上,问题是输入和输出混起来了，如果有许多的数据，你肯定不想在键盘上手动输入，你肯定希望能用一个小工具(geo2json)将大量的数据通过读取文件来获取.</p>

<p>在以上的程序中，你用scanf()和printf()来从键盘中读取数据并将它显示到显示器上，但实际上它们并不直接和键盘和显示器交互，它们用了标准输入(Standard Input)和标准输出(Standard Output)来和相应的输入输出设备交互,输入输出在程序运行的时候由操作系统创建</p>

<p>操作系统决定了数据如何进出标准输入输出的，如果你从终端运行一个程序，操作系统将把所有的按键信息发送给标准输入，如果操作系统从标准输出中获取数据，默认情况下它将把数据输入出显示器上
scanf()和printf()两个函数并不关心数据来自哪里，去向何方，它们从标准输入和标准输出中读写数据
可能你会问，为何这两个函数不直接和键盘，屏幕交互，难道不是更简单吗</p>

<p>程序系统用标准输入和标准输出的形式与程序进行交互有一个很好的理由:
你可以重定向标准输入和标准输出到其他地方，比如文件</p>

<p>你可以用&#8221;&lt;&ldquo;来重定向标准输入:</p>

<pre><code>./geo2json &lt; gpsdata.csv
</code></pre>

<p>&ldquo;&lt;&#8221;告诉操作系统程序的标准输入应与gpsdata.csv文件连接，而非键盘，所以你可以通过文件向程序传送数据</p>

<p>你也可以用&#8221;>&ldquo;来重定向标准输出</p>

<pre><code>./geo2json &lt; gpsdata.csv &gt; output.json
</code></pre>

<p>将你执行以上命令，你将发现在屏幕上没有任何数据，因为结果已经输出到output.json这个文件去了</p>

<p>以上的程序(geo2json)虽然加了错误判断，但如果有非法数据，在最后的输出文件中，一样会有非法数据
如果发生错误，如何发现错误码(以上为2)</p>

<pre><code>echo $?
</code></pre>

<p>如果数据错误了，能有专门针对这些错误的输出该多好!
标准错误(Stand Error)应运而生!它就是专门针对错误信息的输出，默认情况下，标准错误与屏幕相连,以下是默认状态下的三种标准对应设备的图</p>

<p> <img src="http://xiekunRonaldo.github.io/images/2014/6/standardIOE.png"></p>

<p> 也就是说如果重定向了标准出入和标准输出，标准错误仍将发送数据到屏幕上</p>

<p> <img src="http://xiekunRonaldo.github.io/images/2014/6/standardIOE2.png"></p>

<h3>fprintf()输出到一个数据流中(标准输出或标准错误)</h3>

<p>我们已经知道print()将数据输出到标准输出中，实际上print()只是fprintf()的一个特例而已
当你调用</p>

<pre><code>printf("I like Turtles!");
</code></pre>

<p>时，实际上它调用的是</p>

<pre><code>fprintf(stdout, "I like Turtles!");
</code></pre>

<p>以上清楚地显示了字符串&#8221;I like Turtles&#8221;输出到stdout,你可以告诉fprintf()发送数据到stdout或stderr
既然知道了fprintf()的用法，我们就可以修改geo2json了
 <img src="http://xiekunRonaldo.github.io/images/2014/7/updategeo2json.png">
这样错误信息就与标准错误而不是标准输出关联了,重新运行代码，你将看到尽管标准输出重定向到了output.json文件，错误信息仍然打印到屏幕上，这是因为标准错误信息默认就是打印到屏幕上</p>

<p> <img src="http://xiekunRonaldo.github.io/images/2014/7/stderroutput.png"></p>

<p>标准错误的创建其实就是为了将错误信息和正常的输出区分开来，不过要记得，标准错误和标准输出都是输出流，你可以随心所欲地用按自己的想法利用它们</p>

<h4>要点</h4>

<ul>
<li>printf()默认发送数据到标准输出</li>
<li>标准输出默认输出数据到屏幕上</li>
<li>在命令行中你可以用&#8217;>&lsquo;来重定向标准输出,用&#8217;2>&#8217;来重定向标准错</li>
</ul>


<p>在以上处理经纬度数据的程序中，如果你想得到一定范围内的数据，如下图
<img src="http://xiekunRonaldo.github.io/images/2014/7/range.png"></p>

<p>为了不改变geo2json这个工具，你可以另外创建一个工具(称它为bermude吧)来过滤不在以上范围的数据</p>

<pre><code>//bermude
#include &lt;stdio.h&gt;  int main()
{
    float latitude;     float longitude;        char info[80];      while (scanf("%f,%f,%79[^\n]", &amp;latitude, &amp;longitude , info ￼) == 3)
    if (( ￼ ￼ latitude ￼ &gt; ￼ ￼ 26 ￼ ) ￼ ￼ &amp;&amp; ￼ ( ￼ ￼ latitude ￼ &lt; ￼ ￼ 34 ￼ ))     ￼￼￼￼￼￼￼if (( longitude &gt; -76 ) &amp;&amp; ( longitude &lt; -64 )) 
        printf("%f,%f,%s\n", latitude , longitude , info );     ￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼return 0;
}   
</code></pre>

<p>这样，你可以通过管道&#8217;|&lsquo;将&#8221;bermude&#8221;的输出连接到geo2json的标准输入上，进而得到相应的结果</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/pipe.png"></p>

<p>操作系统将处理管道工作的细节，你需要做的只是运行一下以下的命令</p>

<pre><code>bermuda | geo2json
</code></pre>

<p>操作系统将同时运行两个程序，完整的命令操作如下</p>

<pre><code>(./bermuda | ./geo2json) &lt; spooky.csv &gt; output.json
</code></pre>

<p>通过管道将两个程序联合起来一起运行，你可以把两个程序当作一个进行看待，这样，你就能像之前那样重定向标准输出和标准输出了，注意括号是必要的！，这样保证了文件的内容将传到bermuda程序的标准输入中
思考：如果多个程序通过管道连接起来，此时我用&#8221;>&ldquo;和&rdquo;&lt;&ldquo;来重定向标准输入和标准输出，哪一个程序将让它们的输入输出重定向
答:&rdquo;&lt;&ldquo;将把文件的内容传到管道中的第一个程序中,&rdquo;>&ldquo;将从管道中的最后一个程序中获取标准输出</p>

<h4>如果你想将输出传到多个文件中去呢?</h4>

<p>我们已经知道如何用重定向从一个文件中读取数据和写入数据到一个文件中去了，那如果程序想做一些更复杂的，比如发送数据到多个文件中去该如何操作呢？
假设你需要另外一个工具，这个工具将从一个文件中读取一系列的数据，并将数据分割到多个文件中去
<img src="http://xiekunRonaldo.github.io/images/2014/7/threefiles.png">
问题是什么？你最多只能重定向到两个文件中，分别从标准输出和标准错误中重定向，那第三个文件该怎么办呢?</p>

<h4>用FILE</h4>

<p>每一个数据流由一个指向文件的指针表示，你可以用fopen()来创建一个数据流</p>

<pre><code>FILE *in_file = fopen("input.txt", "r");
</code></pre>

<p>以上创建了一个数据流，从一个文件中读取数据</p>

<pre><code>ILE *out_file = fopen("output.txt", "w");以上创建的一个数据流，将写入数据到文件中
</code></pre>

<p>一旦你创建了一个数据流，你可以用fprintf()将输出的数据指向此文件中</p>

<pre><code>fprintf(out_file, "Don't wear %s with %s", "red", "green");
</code></pre>

<p>那如果想从文件中读取数据呢，用fscanf()</p>

<pre><code>fscanf(in_file, "%79[^\n]\n", sentence);
</code></pre>

<p>最后，当你处理完了以上针对文件的数据流操作，你需要关闭它，实际上当程序结束的时候所有的数据流都会自动关闭，不过在不需要它们时手动关闭数据流总量一个好习惯
回到以上的问题，现在我们能把数据输出到3个文件中去了，示例如下</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main() {        char line[80];      FILE *in = fopen("spooky.csv","r");     FILE *file1 = fopen("ufos.csv", “w”);
    FILE *file2 = fopen("disappearances.csv","w");
    FILE *file3 = fopen("others.csv","w");  
    while(fscanf(in,"%79[^\n]\n", line) == 1){
        if (strstr(line, "UFO"))                fprintf (file1, "%s\n", line);          else if (strstr(line, "Disappearance")) 
            fprintf (file2, "%s\n", line);          else fprintf (file3, "%s\n", line);     }
    fclose (file1);         fclose (file2);     fclose (file3);     return 0;
}   
</code></pre>

<p> 程序正常运行了，当你编译并执行以下命令
<img src="http://xiekunRonaldo.github.io/images/2014/7/threefilesok.png"></p>

<p>程序正常运行，并将结果输出到3个文件中
问题是如果你想数据输出到不同的文件(而不是指定的文件)，又该如何操作呢，每次用户都需要重新编译程序吗</p>

<h4>main()函数的参数</h4>

<p>实际上，任何你写的程序都需要给用户改变程序工作方式的灵活性，如果是一个GUI程序，你需要提供它的偏好设置，如果是一个命令行程序，就像我们的categorize工具，它需要提供给用户传送命令行参数的能力
<img src="http://xiekunRonaldo.github.io/images/2014/7/commandlineparam.png">
那么，如何从程序中读取命令行参数呢，目前为止，你用的是main()函数，没有包含任何参数，实际上，你还可以用上main()函数的第二个版本</p>

<pre><code>int main(int argc, char *argv[])
{
    ......Do stuff
}
</code></pre>

<p>以上的main()函数把命令行的参数当作一个字符串数组，实际上，由于C没有内置的字符串类型，它将用一个指针数组来指向这些命令行参数
<img src="http://xiekunRonaldo.github.io/images/2014/7/argv.png"></p>

<p>像C数组一样,你也需要知道一个数组的长度，argc就表示此长度
命令行参数给了你程序很大的灵活性，确实需要仔细考虑下在程序运行时该让用户传哪些参数，它将让你的程序更有价值
以下是使用命令行参数的完整示例</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; int main(int argc, char *argv[]) {      char line[80];
    if (argc != 6) {
        fprintf(stderr, "You need to give 6 arguments\n");
        return 1;
    }

    FILE *in = fopen("spooky.csv", "r");

    FILE *file1 = fopen(argv[2], "w");

    FILE *file2 = fopen(argv[4], "w");

    FILE *file3 = fopen(argv[5], "w");

    while (fscanf(in, "%79[^\n]\n", line) == 1) {
        if (strstr(line, argv[1]))
            fprintf(file1, "%s\n", line);
        else if (strstr(line, argv[3]))
            fprintf(file2, "%s\n", line);
        else 
            fprintf(file3, "%s\n", line);
    }

    fclose(file1);
    fclose(file2);
    fclose(file3); 
    return 0;
}
</code></pre>

<p>运行以上程序，你首选需要以下格式的<code>spooky.csv</code>文件</p>

<pre><code>30.685163,-68.137207,Type=Yeti 28.304380,-74.575195,Type=UFO    29.132971,-71.136475,Type=Ship 28.343065,-62.753906,Type=Elvis  27.868217,-68.005371,Type=Goatsucker 30.496017,-73.333740,Type=Disappearance    26.224447,-71.477051,Type=UFO 29.401320,-66.027832,Type=Ship    37.879536,-69.477539,Type=Elvis
</code></pre>

<p>这样，在命令行中输出以下格式运行程序</p>

<pre><code>categorize UFO aliens.csv Elvis elvises.csv the_rest.csv
</code></pre>

<p>当程序运行后，产生了以下三个文件
<img src="http://xiekunRonaldo.github.io/images/2014/7/3outputfiles.png">
尽管在以上的程序中我们打开关闭程序没有出现错误，在实际操作中是很可能犯错的，幸运的是，如果在打开数据流发生了错误,fopen()将返回0，因此，以上的程序中，你应该将以下的程序</p>

<pre><code>FILE *in = fopen("i_dont_exist.txt", "r");改为
FILE *in;   if (!(in = fopen("dont_exist.txt", "r"))) {     fprintf(stderr, "Can't open the file.\n");      return 1;   }
</code></pre>

<p>很可能你写的程序需要一些选项，如果你创建了一个聊天程序，它需要一些偏好设置，如果你写了一个命令行工具，你可能需要提供类似以下的命令行的一些选项</p>

<pre><code>ps -ae
tail -f logfile.out
</code></pre>

<p>有一个叫做getopt()的库函数能让你更好地处理命令行选项,每次你调用它，它将返回下一个在命令行中的命令行选项
假设你有一个函数，能提供多个命令行选项</p>

<pre><code>rocket_to -e 4 -a Brasilia Tokyo London这个函数将需要两个个选项，其中一个选项需要提供一个值，另一个仅仅表示此选项是否开关,你可以在一个循环中调用getopt()来处理这些选项，如下
</code></pre>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/getopt.png">
在循环中，你用switch来处理每一个合法的选项,字符串&#8221;ae:&ldquo;告知getopt()函数a和e是合法的选项，紧跟在e之后的冒号表示-e后面需要一个的值，getopt()将用optarg变量表示这个值当循环结束，你让argv和argc变量跳过所有的选项，此时它们表示跟随这些选项之后的命令行参数，这样，argv数组表示如下</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/skipargv.png">我们也可以将两个选项结合起来
如用-td而不是-t -d
默认情况下，如果程序在命令行中看到以&#8221;&ndash;&ldquo;开头的命令行，程序将会把它当作命令行选项，如果要避免此种情况，可以在&rdquo;&ndash;&ldquo;前加&mdash;,这样，在&rdquo;&mdash;&ldquo;之后的参数就被当作普通的参数了</p>

<pre><code>set_temperature -c -- -4
</code></pre>

<p>以上的命令行中，-4就被当作普通的参数而非命令行选项</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C 第二章学习笔记-内存与指针]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/06/27/head-first-c-di-er-zhang-xue-xi-bi-ji/"/>
    <updated>2014-06-27T22:01:57+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/06/27/head-first-c-di-er-zhang-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h5>问:运算符和函数的区别</h5>

<p>答:运算符会被编译器编译成一串指令，而如果调用了函数，则会跳到一块单独的代码块中,也就是说在编译的时候sizeof就被执行了，因为编译器能在编译的时候就知道存储空间的大小了</p>

<h5>问:为何在不同的机器上，指针的大小是不同的?</h5>

<p>答:在32位OS上，一个内存地址以一个32比特的数字来表示，这也是它被称为32位的原因,32bit = 8bytes,则也是为何64位OS用8bytes来存储一个地址的原因</p>

<h5>写一个函数，则函数只打印一个字符串的第7个字符以后的信息</h5>

<pre><code>void skip(char *msg) {      puts( msg + 6 );    } 
</code></pre>

<p>以下写法是错误的</p>

<pre><code>char food[5];   printf("Enter favorite food: ");    scanf("%s", food);
</code></pre>

<p>应改为</p>

<pre><code>scanf("%4s", food);
</code></pre>

<p>否则将导致缓冲区溢出(buffer overflow),或者说栈错误(segmentation fault)</p>

<h2>fgets()是一种替代方式</h2>

<p>它接受一个char的指针，但不像scanf(),fgets()必须指定一个最大长度</p>

<pre><code>char food[5];   printf("Enter favorite food: ");    fgets(food, sizeof(food), stdin);
</code></pre>

<p><code>注意点</code>:不过需要注意的是sizeof返回 的是一个变量所占据的空间,以上的例子中,food是一个数组变量 ,所以sizeof返回了数组的大小，如果food只是一个指针变量,sizeof将返回一个指针的大小如果你知道你所传的参数是一个数组变量,那用sizeof是ok的，如果你传的是一个指针变量，你需要传入确定的大小,如下</p>

<pre><code>printf("Enter favorite food: "); 
fgets(food, 5, stdin);
</code></pre>

<h2>fgets和scanf的比较</h2>

<ol>
<li><p>输入大小限制</p>

<ul>
<li>scanf()能限制输入的大小，只要你记得在输入的字符串格式上加上相应的大小即可,如&#8221;%4s&#8221;</li>
<li>fgets()有一个强制输入大小的限制</li>
</ul>
</li>
<li><p>输入类型</p>

<ul>
<li>scanf()不仅仅能让你输入多种类型，还让你指定比如在相应的输入数据之间用什么数据来分隔,如scanf(&ldquo;%d,%d&rdquo;)表示输入的两个整数之间必须用&#8221;,&ldquo;隔开</li>
<li>fgets()只允许你输入一个字符串到缓冲区中,其他数据类型都是不允许的</li>
</ul>
</li>
<li><p>字符串中的空格</p>

<ul>
<li>对scanf()来说，如果它用%s来输入一个字符串,如果碰到一个空格时，它将马上终止输入,所以如果你想输入两个单词，要么你调用两次scanf()来输入，要么你用一些古怪的正则表达式来操作</li>
<li>fgets()无任何问题,每次fgets()都可读入整个string</li>
</ul>
</li>
</ol>


<h2>字符串常量不能被修改</h2>

<pre><code>char *cards = "JQK"
cards[0] = 'H'
</code></pre>

<p>错误！字符串常量被存储在常量存储区，这个区域是只读的,如果你想要改变一个字符串，copy它，你需要将string拷贝到一个可写的内存区域，这样你就能修改它了,如下</p>

<pre><code>char cards[] = "JQK";
</code></pre>

<p>可能你不清楚发生了什么，所有的string都是数组，但在之前的错误代码中，cards仅仅是一个指针，在新代码中，如果你定义了一个叫做cards的数组，然后将一个字符串常量赋值给它，cards数组得到的是一份全新的拷贝，此时&#8221;JQK&#8221;在栈上
为了避免当cards是指针时修改它产生错误，你应该按哪下方式进行声明</p>

<pre><code>const char *s = "JQK";
</code></pre>

<p>这样，如果编译器看到试图修改此string的代码，就会报错</p>

<pre><code>s[0] = 'S'      //error: assignment of read-only location
</code></pre>

<h2>cards[]还是cards*</h2>

<p>如果你看到以下的声明，意味着什么</p>

<pre><code>char cards[]
</code></pre>

<p>一切取决于你在哪看到它的，如果是一个正常的声明，那么意味着它是一个数组，必须给它赋值</p>

<pre><code>int my_function()   {
    //此时cards是一个数组        char cards[] = "JQK"; ...   }
</code></pre>

<p>如果cards出现在一个函数的参数中，此时cards表示一个指针</p>

<pre><code>void stack_deck(char cards[])   {       }
</code></pre>

<p>等价于</p>

<pre><code>void stack_deck(char *cards) {      }
</code></pre>

<h2>存储区</h2>

<p>  <img class="left" src="http://xiekunRonaldo.github.io/images/2014/6/memory_memorizer.png" width="350" height="350" title="'image'" ></p>

<ul>
<li>栈
栈用来存储局部变量,每次你调用一个函数，所有此函数的局部变量都创建在栈上，它被称称栈，是因为它像一叠盘子,将你创建一个函数的时候，变量被加到栈中，将你离开一个函数时，这些变量又会变销毁，奇怪的是栈的工作方式，总是从高地址开始，向低地址增长</li>
<li>堆
堆主要用在动态内存分配上,创建在堆上的数据在程序运行时即可创建，不过会保持相当长的一段时间，直到你手动释放它</li>
<li>全局存储区
一个全局存储区的作用域在所有函数之外，并且对所有函数可见，全局变量在程序首次运行的时候创建，你可以随意改变它们，但却不像&hellip;</li>
<li>常量存储区
常量也在用户首次运行的时候创建，但它们只存储在只读的存储区域中,常量就像字符串字面量一样，程序运行的时候你可能需要它们，但你却无法改变它们</li>
<li>代码存储区
许多操作系统将代码存储区置于最低的内存地址中,代码存储区是只读的，这里实际上是汇编代码加载的区域</li>
</ul>


<h2>字符串</h2>

<p>使用前#include&lt;string.h>
提供的函数如下</p>

<ol>
<li>strchr() : 寻找字符串中某个字符的位置</li>
<li>strcmp() : 比较两个字符串</li>
<li>strstr() : 寻找字符串中对应字符串的位置</li>
</ol>


<p>如果找到了，返回被寻找的字符串的位置，如果没有，返回0</p>

<pre><code>char s0[] = "dysfunctional"; char s1[] = "fun"; if (strstr(s0, s1)) puts("I found the fun in dysfunctional!");
</code></pre>

<ol>
<li>strcpy() : 拷贝字符串</li>
<li>strlen() : 求字符串的长度</li>
<li>strcat() : 连接两个字符串</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runloop]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/06/27/runloop/"/>
    <updated>2014-06-27T21:38:47+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/06/27/runloop</id>
    <content type="html"><![CDATA[<p>参考</p>

<ul>
<li><p><a href="http://lianxu.me/2012/11/10-cocoa-objc-newbie-problems/#4">http://lianxu.me/2012/11/10-cocoa-objc-newbie-problems/#4</a></p></li>
<li><p><a href="http://blog.csdn.net/devday/article/details/6928432?reload">http://blog.csdn.net/devday/article/details/6928432?reload</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C指针所引发的一个问题]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/06/25/czhi-zhen-suo-yin-fa-de-%5B%3F%5D-ge-wen-ti/"/>
    <updated>2014-06-25T21:39:33+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/06/25/czhi-zhen-suo-yin-fa-de-[?]-ge-wen-ti</id>
    <content type="html"><![CDATA[<pre><code>void fortune_cookie(char msg[]) {
     printf("Message reads: %s\n", msg);
     printf("msg occupies %i bytes\n", sizeof(msg)); 
} 

int main () {
    char msg[] = "Turtles!";
    fortune_cookie(msg);
    return 0;
}
</code></pre>

<p>运行以上代码会输出什么,有人说是</p>

<pre><code>Message reads Turtles!
msg occupies 9 bytes("Turtles!"的8个字节再加代表字符串结尾的\0这个字节，所以是9个字节)
</code></pre>

<p>如果你这么想，那就错了,实际的结果是</p>

<pre><code>Message reads Turtles!
msg occupies 4 (or 8) bytes
</code></pre>

<p>解释如下</p>

<h2>数组变量就像指针一样</h2>

<p>是的，只是像，而不等于指针</p>

<p>当你创建了一个数组,数组变量其实可以被当作指向数组首元素地址的指针,当写了如下代码时</p>

<pre><code>char quote[] = "Cookies make you fat";
</code></pre>

<p>实际上quote代表的是string中的首字符的地址，即字符&#8217;C&#8217;对应的地址</p>

<pre><code>printf("The quote string is stored at: %p\n", quote);
</code></pre>

<p>以上将打印一个16进制的地址,尽管quote是一个数组，但是你可以把&#8221;quote&#8221;当成一个指针变量，因为它本身就是代表首字符串中的首字符的地址.</p>

<p>所以当调用</p>

<pre><code>fortune_cookie(msg);
</code></pre>

<p>时，其实我们给fortune_cookie函数传的是一个指针,它返回的是指向一个字符串的指针的大小，在32位上操作系统，一个指针占了4个字节的空间，而在64位上，一个指针则占据了8个字节,故有以上结果</p>

<h2>数组变量不是指针</h2>

<p>尽管在调用函数时，数组参数是可以被当作指针传递，但实际上仍有一些不同，考虑以下情况</p>

<pre><code>char s[] = "How big is it?"; 
char *t = s;
</code></pre>

<ol>
<li>sizeof(数组) 是一个数组的大小.
 sizeof(s) = 15   sizeof(t) = 4 或 8</li>
<li>数组的地址
 &amp;s = s     &amp;t != t
如果你写&amp;s,表示数组s的地址是什么,数组s的地址就是s,&amp;t表示t变量的地址，显然不等于t(表示s的地址)</li>
<li><p>一个数组变量不能指向任何地方
 如果你创建了一个指针，机器将会为之分配4或8个字节来存储它,但如果你创建了一个数组，机器将为此<code>数组</code>分配空间，而不分为此<code>数组变量</code>分配<strong>任何</strong>的空间,数组变量仅代表数组的首地址</p>

<p> 由于数组变量没有任何的存储空间，所以它不能指向任何地方,当程序编译时，所以的数组变量都被数组的地址替换了，所以数组变量并不存在最后的可执行文件中，这也就是为什么数组变量不能指向任何其他地方的原因</p></li>
</ol>


<h2>指针退化(Pointer decay)</h2>

<p>由于数组变量和指针变量有些区别，当你把数组赋给指针时需要特别小心，如果你将一个数组赋给一个指针变量，此时的指针变量将只包含数组的地址,没法知道数组的大小，所以一些信息丢失了，这种丢失信息的情况就叫做指针退化</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ &amp; Objective C]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/06/24/c-plus-plus-and-objective-c/"/>
    <updated>2014-06-24T07:58:39+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/06/24/c-plus-plus-and-objective-c</id>
    <content type="html"><![CDATA[<p>译自<a href="http://paralaxer.com/cpp-vs-objective-c/">C++ vs Objective C</a></p>

<h2>C++ 是一辆手动档汽车</h2>

<p>如果说object C是一辆自动档汽车，那么C++就是一辆手动档的汽车</p>

<p>也许有人会说自动档汽车更好，因为它更容易操纵，不过,用自动档的人可能会在经过一条石子路时因没有将离和器置空档的经验而无法让车停下来</p>

<p>C的运行速度更快，也能对它进行更多的掌控，然而相应得，它对程序员的技能提出了更高的要求</p>

<p>比如，C++在解引用指针前不检查指针(是否为空或有效)来节省时间，这提升了你游戏的运行速度,给了你更多的掌控，同时它也使得你必须在debug模式下使用用assert</p>

<h2>发送消息给空对象</h2>

<p>我们来看一下ObjC和C++的一个最根本的区别之一</p>

<p>用Object C,你能安全地发送信息给nil对象(付出的代价是程序的执行时间会慢一点)</p>

<pre><code>// in Objective C
Node* node = nil;

// this will not crash, it will just do nothing
[node setPosition:Point(10,10)];
</code></pre>

<p>在C++中，如果你解引用一个空指针，将会产生一个运行时错误</p>

<pre><code>// in C++
Node* node = nullptr; // nullptr introduced in C++11

// this will crash
node-&gt;setPosition(Point(10,10));

// using a safeguard, this will not crash
if(node)
   node-&gt;setPosition(Point(10,10));

// using an assertion will trigger a debuggable error
assert(node);
node-&gt;setPosition(Point(10,10));
</code></pre>

<p>在底层，Objc实际上实现了一个空对象，对任何发送给它的消息，它都返回0，这种实现方式让编程更安全，也更简单，不过，这么做也会导致一些bug难以察觉</p>

<p>C++在解引用前不会检查一个指针是否为空,如上所示,如果node为null,C++会用null去执行setPosition函数,如果通过一个null指针去访问它的成员变量,你的程序将会崩溃</p>

<p>一种解决方法是用<a href="http://www.cplusplus.com/reference/cassert/assert/">断言</a>,它仅在非发布模式下起作用,如果传给断言的表达式为假，程序终止，如果此时有个调试器，程序终止时将停在断言失败的那一行，这样，你就能看到哪一行代码出问题了</p>

<pre><code>Node* node = nullptr;

// this will pause execution when debugging
assert(node);
</code></pre>

<p>由于断言通常被定义为宏,用它的一个好处是在发布模式下(或者其他任何定义了NDEBUG的模式中)，此断言宏不做任何事情,本质上,编译器不会为它产生任何二进制的代码，这样，在debug模式时，你就可以放心地用它,同时,也保证了发布模式下的程序运行速度(由于针对assert的二进制代码被忽略掉了)</p>

<h2>可读性</h2>

<p>我们来看看两者的另一个基本的区别,Object C生来就比C++有更好的可读性,因为方法的参数名称也集成到了方法名中</p>

<pre><code>// Objective C
[layer addChild:sprite z:1];

// C++
layer-&gt;addChild(sprite, 1);
</code></pre>

<p>你能看到两者在可读性上的差别吗?</p>

<p>Objective C有更好的可读性因为addChild方法中的第二个参数清楚地显示了z参数,在C++中,没人知道1代表什么</p>

<p>如今,像Xcode之类IDE提供了自动补全的功能，这也减轻了你写代码的负担，当你敲addChild时，IDE们会自动为你显示参数类型和名字,这样IDE就为你清楚地显示了相应的参数是什么(类型和名字),不过如果你好久没碰你的项目了，然后回头看addChild方法的时候，你就会感到困惑，不明白第二个参数代表什么意思</p>

<p>用一些名字定义良好的变量，你可以让C++代码更具有可读性</p>

<pre><code>int z = 1;
layer-&gt;addChild(sprite, z);
</code></pre>

<h2>速度和可移植性</h2>

<p>我们已经讨论了C++为何比Objective C更快,那么可移植性呢,这才是C++闪光的地方</p>

<p>C++比OC更具有可移植性,它可以在多个平台上(如Windows,Mac, Linux,iOS,Android等平台上)被原生的编译集成</p>

<p>说到Android,如果你升级NDK的GCC编译器，技术上是可以编译OC的,但要注意，你需要所有的Foundation 类</p>

<p>还记得 NSObject, NSString, NSArray否？它们在Mac上完美的实现了，而在Windows上则没有,所有这些都必须用一种跨平台的方式重新实现</p>

<p>幸运的是,有一些像<a href="http://www.cocotron.org">Cocotron</a>这样的项目致力于此,然而如果到一些android相关的具体问题上,比如输入和声音,你仍然需要一个跨平台的库, 这些库实现了相应平台的细节，所以你就不需要做了.</p>

<p>这就是为什么C++和Cocos2dX 如此cool的原因,cocos2dx处理了平台相关的问题,并且用C++来实现它们</p>

<p>除了速度，可移植性和可读性，我们来看看更具体的区别,比如oc的dClass和id类型</p>

<h2>Class和id类型</h2>

<p>OC有一个叫Class类型的实现,它允许你获得对象的类并且将你存储在一个变量中.</p>

<p>C++并没有相应的Class类型的实现方式，但它有一个叫做运行时类型信息(RTTI)的东西,可以粗略地将一个指针转换为一个字符串,这个字符串包含有一个以<a href="http://www.cplusplus.com/reference/typeinfo/type_info/">typeid</a>表示的对象类,不过,由于各个平台的转换结果不同,这种解决方式似乎并不可靠</p>

<p>OC的Class类型使得从字符串创建类可以变得相当优雅，考虑以下情况</p>

<pre><code>// Objective C
NSString* string = @"Hammer";
Class class = NSClassFromString(string);
id object = [[class alloc] init];

// C++
Tool* tool = nullptr;
std::string string = "Hammer";
if( string == "Hammer" )
   tool = new Hammer;
</code></pre>

<p>以上显示了OC的类类型的优雅以及在C++中相应的可能的解决方式</p>

<p>你可以看到以上代码中我们用了ObjC的id类型,它本质上是一个指向对象类型的指针,大致相当于C++中的void*,但仍有不用两者的许多理由</p>

<h2>惰性</h2>

<p>假设有一个叫做Parent的父类,有一个继续它的Child子类，同时有一个叫做goToSleep的方法</p>

<p>在C++中,如果你在Child中重新定义了Child的接口，你就不得不在Child的接口中(头文件中)重新定义goToSleep这个方法，但在OC中，你无需这么做，只要在@implementation中实现它即可</p>

<pre><code>/ Objective C
@interface Parent : NSObject
   -(void) goToSleep;
@end

@interface Child : Parent
   // woo! don't have to redefine goToSleep
@end

@implementation Parent
   -(void) goToSleep {}
@end

@implementation Child
   -(void) goToSleep {}
@end

// C++
class Parent
{
   public:
      virtual void goToSleep();
};

class Child : public Parent
{
   public:
      // goToSleep has to be redefined
      // if it is to be overridden
      virtual void goToSleep();
};

void Parent::goToSleep() {}

void Child::goToSleep() {}
</code></pre>

<p>C++之所以迫使程序员重新定义被重写的函数的原因是因为这么做可以让编译器的工作变得更加容易，编辑器无需因为一些神秘的方法去检查类的继承关系</p>

<h2>虚函数</h2>

<p>在以上的例子中,我们看到了C++中virtual关键字的使用,当virtual被用在函数时，位于继承层次中最低的那个类有最高的优先级调用此函数(比如以上例子中，Child的goToSleep先被调用)</p>

<p>在OC中,所以的方法本质上是虚函数,这让编程变得简单，不过相应的，这么做也导致了<a href="http://stackoverflow.com/questions/4882105/c-polymorphism-inheritance-question-redefinition-of-base-functions-vs-virtual/4882155#4882155">性能的下降</a></p>

<p>另外，如前所述，C++相当于手动档汽车,你可以根据需要指定或不指定函数为virtual</p>

<h2>栈</h2>

<p>在OC中，你只能在堆上分配对象
在C++中，你可以在栈上分配对象，有栈上创建对象比在堆上创建快，同时也保证了，对象超出相应的作用范围时析构函数能被调用,即便在已经抛出异常的情况下</p>

<p>举个例子</p>

<pre><code>// Objective C
// 仅分配在堆上
Tool* tool = [[Tool alloc] init];

// C++
//我们采用了快速的，可信任的栈分配
Tool tool;
</code></pre>

<h2>运算符重载</h2>

<p>在C++中，你可以重载运算符,比如，如果你写了一个Vector对象,你可以重载&#8221;+&ldquo;符号,这样Vector的对象就能进行相加的运算了</p>

<pre><code>// C++
class Vector
{
   const Vector operator+(const Vector&amp; v) const
   {
      return Vector(x + v.x, y + v.y, z + v.z);
   }
}

// this '+' calls the overloaded operator+
// isn't it nice?
Vector v1,v2,v3;
v3 = v1 + v2;
</code></pre>

<p>而在OC中，则不能重载运行符，不过你可以在方法命名上动些脑筋</p>

<pre><code>// Objective C
v3 = [v1 addVector:v2];
</code></pre>

<p>不过，这样一来，OC在处理一些事情时便显得有些哆嗦了，如下</p>

<pre><code>// Objective C
NSString* a = @"something";
NSString* b = @"else";
if( [a isEqualToString:b] )
   [self doSomething];

// C++
string a = "something";
string b = "else";
if( a == b )
   doSomething();
</code></pre>

<h2>私有性</h2>

<p>OC在技术上是没有私有方法的，不过我们可以在.m文件中定义一个空的类别，并在此空的类别中定义此方法(来模拟私有方法),达种方法是很优雅的,因为这样一来私有方法就无需在公共接口中声明了(因此由于头文件的变化，你的代码将会重新进行索引和编译)</p>

<pre><code>// 在OC的头文件中 (.h)
@interface Something : NSObject
   // See? No private method
@end

// 在实现文件中 (.m)
// 用一个类别来扩展接口
// (空类别代表私有的一些属性)
@interface Something () // a blank category
   -(void) privateMethod;
@end
</code></pre>

<p>在C++中，有公有和私有的概念，不过私有的属性或方法必须在公有接口另声明</p>

<p>如果你确实不想在公有接口中声明私有的方法，你可以采用在.m文件中声明静态函数的形式来避免它(这和之前提到的OC的空类别有点类似)</p>

<h2>类扩展</h2>

<p>如上例所示，OC可以用一个类别来扩展一个类</p>

<p>类别是很优雅的，因为一个类可以在任何地方被扩展,如在.h和.m文件中，或是其他地方</p>

<p>技术上C++是不能扩展一个类的，不过它有<a href="http://www.cprogramming.com/tutorial/multiple_inheritance.html">多继承</a></p>

<h2>默认参数</h2>

<p>C++还有一个很cool的地方:默认参数.函数中的参数可以有一个默认值,这样我们可以选择在调用函数时是否给此参数传值</p>

<pre><code>// C++
class Something
{
   void doSomething(int i, float f = 0.0f) {}
};

Something s;

// can be called with or without the f parameter
s.doSomething(5);
s.doSomething(5, 1.0f);
</code></pre>

<p>OC则没有默认参数，不过它可以采用定义多个方法的形式来实现</p>

<pre><code>// Objective C
@interface Something : NSObject
   -(void) doSomething:(int)i;
   -(void) doSomething:(int)i withF:(float)f;
@end

@implementation Something
   -(void) doSomething:(int)i
   {
      [self doSomething:i withF:0.0f];
   }

   -(void) doSomething:(int)i withF:(float)f
   {
      // do something with i and f...
   }
@end

Something* s = [[Something alloc] init];

// either method can be called, however
// two separate methods have been implemented
[s doSomething:5];
[s doSomething:5 withF:1.0f];
</code></pre>

<h2>结论:混合使用C++和OC</h2>

<p>以上就是C++和OC的主要区别
需要记住两者总是可以共存的，实际上你可以采用<a href="http://en.wikipedia.org/wiki/Objective-C#Objective-C.2B.2B">Objecttive C++</a>的使用来让两者共存</p>

<p>你可以将.m文件改为.mm文件，这样编辑器就知道是用Object C++了，从而可以使用Object C,C++或者两者混用</p>

<pre><code>// In the file AppDelegate.mm
@implementation AppDelegate
   -(void) applicationDidFinishLaunching:(NSNotification*)aNotification
   {
      // Do some Objective C stuff
      window = [[Window alloc] initWithContentRect:...];

      // Now switch to C++ and launch Cocos2dx
      Application::getInstance()-&gt;run();
   }
@end
</code></pre>

<p>如以上例子所见,Objective C++是很常见的,它对于在同一个方法中响应iOS和Mac的通知并启动Cocos2d-x是必须的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[部署octopress成功]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2013/11/25/bu-shu-octopresscheng-gong/"/>
    <updated>2013-11-25T21:35:14+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2013/11/25/bu-shu-octopresscheng-gong</id>
    <content type="html"><![CDATA[<p>今天经过一番探索,按船哥的<a href="http://beyondvincent.com/blog/2013/08/03/108-creating-a-github-blog-using-octopress/">博文指引</a>，查阅了一些资料后，终于成功的部署了octopress博客系统，成功地写出了博客，用得主题是很流行的<a href="https://github.com/shashankmehta/greyshade">greyshade</a>主题,整理一下需要注意的几个问题</p>

<ol>
<li>侧栏social links支持众多社交网站,但不支持微博,可以点<a href="http://www.imallen.com/blog/2013/05/12/add-support-for-weibo-and-dribbble-to-greyshade.html">这里</a>查看解决方法</li>
<li><p>写博客时用到的命令rake new_post[&ldquo;title&rdquo;]，在zsh下无效，会出现<code>zsh: no matches found</code>的错误，原因：zsh中若出现‘*’, ‘(’, ‘|’, ‘&lt;’, ‘[’, or ‘?’符号，则将其识别为查找文件名的通配符</p>

<ul>
<li><p>快速解决：用引号括起来$ rake &ldquo;new_post[arch-linux-reinstall-glibc.markdown]&rdquo;</p></li>
<li><p>彻底解决：取消zsh的通配(GLOB), 在.zshrc中加入alias rake=&ldquo;noglob rake&#8221;点</p>

<p>  参考<a href="http://fancyoung.com/blog/use-octopress-new-post-function-with-zsh/">这里</a></p></li>
</ul>
</li>
<li>安装多说评论系统,请点击<a href="http://beyondvincent.com/blog/2013/07/27/107-hello-page-of-github/">这里</a>，需要注意的是,在文章的C步中,船哥有个地方笔误了,请将<code>post/duoshuo1.html</code>改为<code>post/duoshuo.html</code></li>
</ol>


<p>参考</p>

<ol>
<li><a href="http://beyondvincent.com/blog/2013/08/03/108-creating-a-github-blog-using-octopress/">利用Octopress搭建一个Github博客</a></li>
<li><a href="http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/">Clone Your Octopress to Blog From Two Places</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
