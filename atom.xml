<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[AllenToFight Blog]]></title>
  <link href="http://xiekunRonaldo.github.io/atom.xml" rel="self"/>
  <link href="http://xiekunRonaldo.github.io/"/>
  <updated>2014-08-31T14:23:18+08:00</updated>
  <id>http://xiekunRonaldo.github.io/</id>
  <author>
    <name><![CDATA[AllenToFight]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/08/12/swift/"/>
    <updated>2014-08-12T21:29:29+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/08/12/swift</id>
    <content type="html"><![CDATA[<h4>变量定义</h4>

<p>常量用let,变量用var</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var myVariable = 42
</span><span class='line'>myVariable = 50
</span><span class='line'>let myConstant = 42
</span><span class='line'>let explicitDouble: Double = 70
</span></code></pre></td></tr></table></div></figure>


<p>变量的值不会自动转化为其他类型的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let label = "The width is "
</span><span class='line'>let width = 94
</span><span class='line'>let widthLabel = label+String(width)</span></code></pre></td></tr></table></div></figure>


<p>String内的值替换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let apples = 3
</span><span class='line'>let oranges = 5
</span><span class='line'>let appleSummary = "I have \(apples) apples.”</span></code></pre></td></tr></table></div></figure>


<p>数组和字典</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var shoppingList = ["catfish", "water", "tulips", "blue paint"]
</span><span class='line'>
</span><span class='line'>shoppingList[1] = "bottle of water"
</span><span class='line'> 
</span><span class='line'>var occupations = [
</span><span class='line'>
</span><span class='line'>    "Malcolm": "Captain",
</span><span class='line'>
</span><span class='line'>    "Kaylee": "Mechanic",
</span><span class='line'>]
</span><span class='line'>occupations["Jayne"] = "Public Relations”
</span><span class='line'>
</span><span class='line'>let emptyArray = String[]()
</span><span class='line'>let emptyDictionary = Dictionary&lt;String, Float&gt;()
</span></code></pre></td></tr></table></div></figure>


<p>如果类型是能推断的，可以用[]创建一个空数组，用[:]创建一个空字典</p>

<h4>条件语句</h4>

<p>if&hellip;else&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let individualScores = [75, 43, 103, 87, 12]
</span><span class='line'>var teamScore = 0
</span><span class='line'>for score in individualScores {
</span><span class='line'>    if score &gt; 50 {
</span><span class='line'>        teamScore += 3
</span><span class='line'>    } else {
</span><span class='line'>        teamScore += 1
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>teamScore</span></code></pre></td></tr></table></div></figure>


<p>注意，在if条件语句中，condition必须是bool表达式，所以类似<code>if score {...}</code>这样的代码是错误的
if和optional value组成的条件表达式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var optionalString: String? = "Hello"
</span><span class='line'>optionalString == nil
</span><span class='line'> 
</span><span class='line'>var optionalName: String? = "John Appleseed"
</span><span class='line'>var greeting = "Hello!"
</span><span class='line'>if let name = optionalName {
</span><span class='line'>    greeting = "Hello, \(name)"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>switch和case语句支持多种类型的比较,不限于integer</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vegetable = "red pepper"
</span><span class='line'>switch vegetable {
</span><span class='line'>case "celery":
</span><span class='line'>    let vegetableComment = "Add some raisins and make ants on a log."
</span><span class='line'>case "cucumber", "watercress":
</span><span class='line'>    let vegetableComment = "That would make a good tea sandwich."
</span><span class='line'>case let x where x.hasSuffix("pepper"):
</span><span class='line'>    let vegetableComment = "Is it a spicy \(x)?"
</span><span class='line'>default:
</span><span class='line'>    let vegetableComment = "Everything tastes good in soup."
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意:执行完case语句，程序就从switch语句里终止了，所以无需break!</p>

<p>遍历dictionary</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let interestingNumbers = [
</span><span class='line'>    "Prime": [2, 3, 5, 7, 11, 13],
</span><span class='line'>    "Fibonacci": [1, 1, 2, 3, 5, 8],
</span><span class='line'>    "Square": [1, 4, 9, 16, 25],
</span><span class='line'>]
</span><span class='line'>var largest = 0
</span><span class='line'>for (kind, numbers) in interestingNumbers {
</span><span class='line'>    for number in numbers {
</span><span class='line'>        if number &gt; largest {
</span><span class='line'>            largest = number
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>largest</span></code></pre></td></tr></table></div></figure>


<p>while语句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var n = 2
</span><span class='line'>while n &lt; 100 {
</span><span class='line'>    n = n * 2
</span><span class='line'>}
</span><span class='line'>n
</span><span class='line'> 
</span><span class='line'>var m = 2
</span><span class='line'>do {
</span><span class='line'>    m = m * 2
</span><span class='line'>} while m &lt; 100
</span><span class='line'>m</span></code></pre></td></tr></table></div></figure>


<p><code>..</code>的妙用,以下两个循环是等价的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var firstForLoop = 0
</span><span class='line'>for i in 0..3 {
</span><span class='line'>    firstForLoop += i
</span><span class='line'>}
</span><span class='line'>firstForLoop
</span><span class='line'> 
</span><span class='line'>var secondForLoop = 0
</span><span class='line'>for var i = 0; i &lt; 3; ++i {
</span><span class='line'>    secondForLoop += 1
</span><span class='line'>}
</span><span class='line'>secondForLoop</span></code></pre></td></tr></table></div></figure>


<h4>函数和闭包</h4>

<p>函数的声明
用->将参数与返回值区分开来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func greet(name: String, day: String) -&gt; String {
</span><span class='line'>    return "Hello \(name), today is \(day)."
</span><span class='line'>}
</span><span class='line'>greet("Bob", "Tuesday")</span></code></pre></td></tr></table></div></figure>


<p>用tuple从函数中返回多个值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func getGasPrices() -&gt; (Double, Double, Double) {
</span><span class='line'>    return (3.59, 3.69, 3.79)
</span><span class='line'>}
</span><span class='line'>getGasPrices()</span></code></pre></td></tr></table></div></figure>


<p>函数也能接收不定数量的参数，将它们封成到一个数组里</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sumOf(numbers: Int...) -&gt; Int {
</span><span class='line'>    var sum = 0
</span><span class='line'>    for number in numbers {
</span><span class='line'>        sum += number
</span><span class='line'>    }
</span><span class='line'>    return sum
</span><span class='line'>}
</span><span class='line'>sumOf()
</span><span class='line'>sumOf(42, 597, 12)</span></code></pre></td></tr></table></div></figure>


<p>函数也能嵌套，内嵌的函数能访问声明在外部函数的变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func returnFifteen() -&gt; Int {
</span><span class='line'>    var y = 10
</span><span class='line'>    func add() {
</span><span class='line'>        y += 5
</span><span class='line'>    }
</span><span class='line'>    add()
</span><span class='line'>    return y
</span><span class='line'>}
</span><span class='line'>returnFifteen()</span></code></pre></td></tr></table></div></figure>


<p>函数是first-class类型，这意味着函数也能返回另一个函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func makeIncrementer() -&gt; (Int -&gt; Int) {
</span><span class='line'>    func addOne(number: Int) -&gt; Int {
</span><span class='line'>        return 1 + number
</span><span class='line'>    }
</span><span class='line'>    return addOne
</span><span class='line'>}
</span><span class='line'>var increment = makeIncrementer()
</span><span class='line'>increment(7)</span></code></pre></td></tr></table></div></figure>


<p>函数的参数也能是函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool {
</span><span class='line'>    for item in list {
</span><span class='line'>        if condition(item) {
</span><span class='line'>            return true
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>}
</span><span class='line'>func lessThanTen(number: Int) -&gt; Bool {
</span><span class='line'>    return number &lt; 10
</span><span class='line'>}
</span><span class='line'>var numbers = [20, 19, 7, 12]
</span><span class='line'>hasAnyMatches(numbers, lessThanTen)</span></code></pre></td></tr></table></div></figure>


<p>函数实际上是闭包的一种特殊形式，我们可以用{}来写一个匿名的闭包,用in来将参数和返回类型区分开来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numbers.map({
</span><span class='line'>    (number: Int) -&gt; Int in
</span><span class='line'>    let result = 3 * number
</span><span class='line'>    return result
</span><span class='line'>    })</span></code></pre></td></tr></table></div></figure>


<p>如果一个closure的类型是已知的，比如已知一个delegate的回调，我们可以省略参数的类型，返回类型或两者都省略,以上可以改写成以下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numbers.map({ number in 3 * number })</span></code></pre></td></tr></table></div></figure>


<p>我们也可以用数字而不是名字来表示参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sort([1, 5, 3, 12, 2]) { $0 &gt; $1 }</span></code></pre></td></tr></table></div></figure>


<h4>对象和类</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Shape {
</span><span class='line'>    var numberOfSides = 0
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        return "A shape with \(numberOfSides) sides."
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var shape = Shape()
</span><span class='line'>shape.numberOfSides = 7
</span><span class='line'>var shapeDescription = shape.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p><code>init</code>的使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class NamedShape {
</span><span class='line'>    var numberOfSides: Int = 0
</span><span class='line'>    var name: String
</span><span class='line'>    
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        return "A shape with \(numberOfSides) sides."
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>每一个property都需要赋值，可以在它声明的时候(如numberOfSlides)也可以在initializer里(如name)
定义deinit来创建一个deinitializer如果你需要在对象被释放前做一些清理工作的话
继承时，如果要重写superclass的方法，必须要在重写的方法前加override</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Square: NamedShape {
</span><span class='line'>    var sideLength: Double
</span><span class='line'>    
</span><span class='line'>    init(sideLength: Double, name: String) {
</span><span class='line'>        self.sideLength = sideLength
</span><span class='line'>        super.init(name: name)
</span><span class='line'>        numberOfSides = 4
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    func area() -&gt;  Double {
</span><span class='line'>        return sideLength * sideLength
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    override func simpleDescription() -&gt; String {
</span><span class='line'>        return "A square with sides of length \(sideLength)."
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let test = Square(sideLength: 5.2, name: "my test square")
</span><span class='line'>test.area()
</span><span class='line'>test.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p>为property定义getter和setter</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class EquilateralTriangle: NamedShape {
</span><span class='line'>    var sideLength: Double = 0.0
</span><span class='line'>    
</span><span class='line'>    init(sideLength: Double, name: String) {
</span><span class='line'>        self.sideLength = sideLength
</span><span class='line'>        super.init(name: name)
</span><span class='line'>        numberOfSides = 3
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    var perimeter: Double {
</span><span class='line'>    get {
</span><span class='line'>        return 3.0 * sideLength
</span><span class='line'>    }
</span><span class='line'>    set {
</span><span class='line'>        sideLength = newValue / 3.0
</span><span class='line'>    }
</span><span class='line'> }
</span><span class='line'> 
</span><span class='line'> override func simpleDescription() -&gt; String {
</span><span class='line'>          return "An equilateral triagle with sides of length \(sideLength)."
</span><span class='line'>      }
</span><span class='line'> }
</span><span class='line'>var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
</span><span class='line'>triangle.perimeter
</span><span class='line'>triangle.perimeter = 9.9
</span><span class='line'>triangle.sideLength</span></code></pre></td></tr></table></div></figure>


<p>在perimeter的setter方法中，新值有一个默认的名字newValue,我们可以在set后的括号里为这个值指定一个名字
如果你无需计算property的值，但需要在设置新值的前后做一些操作，可以用<code>willSet</code>和<code>didSet</code>,比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class TriangleAndSquare {
</span><span class='line'>    var triangle: EquilateralTriangle {
</span><span class='line'>      willSet {
</span><span class='line'>          square.sideLength = newValue.sideLength
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    var square: Square {
</span><span class='line'>      willSet {
</span><span class='line'>          triangle.sideLength = newValue.sideLength
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    init(size: Double, name: String) {
</span><span class='line'>        square = Square(sideLength: size, name: name)
</span><span class='line'>        triangle = EquilateralTriangle(sideLength: size, name: name)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
</span><span class='line'>triangleAndSquare.square.sideLength
</span><span class='line'>triangleAndSquare.triangle.sideLength
</span><span class='line'>triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
</span><span class='line'>triangleAndSquare.triangle.sideLength</span></code></pre></td></tr></table></div></figure>


<p>类方法与函数有一个很重要的区别，类方法里可以为参数指定一个别名,而函数不行，如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Counter {
</span><span class='line'>    var count: Int = 0
</span><span class='line'>    func incrementBy(amount: Int, numberOfTimes times: Int) {
</span><span class='line'>        count += amount * times
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var counter = Counter()
</span><span class='line'>counter.incrementBy(2, numberOfTimes: 7)</span></code></pre></td></tr></table></div></figure>


<p>当与optional values工作时，你可以在有关方法，属性和[]操作前写一个<code>?</code>如果在?前的值为nil,则一切在？后的操作都被忽略了，整个表达式的值也就是nil了，否则optional value unwrapped,所有?后表达式对应的值为optional value,无论如何，整个表达式的值都是optional value</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
</span><span class='line'>let sideLength = optionalSquare?.sideLength</span></code></pre></td></tr></table></div></figure>


<h4>Enumerations and Structures</h4>

<p>像类和其他类型一样,enumerations可以有方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Rank: Int {
</span><span class='line'>    case Ace = 1  //也可以用字符串或符点型来指定枚举的类型
</span><span class='line'>    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
</span><span class='line'>    case Jack, Queen, King
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        switch self {
</span><span class='line'>        case .Ace:
</span><span class='line'>            return "ace"
</span><span class='line'>        case .Jack:
</span><span class='line'>            return "jack"
</span><span class='line'>        case .Queen:
</span><span class='line'>            return "queen"
</span><span class='line'>        case .King:
</span><span class='line'>            return "king"
</span><span class='line'>        default:
</span><span class='line'>            return String(self.toRaw())
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let ace = Rank.Ace
</span><span class='line'>let aceRawValue = ace.toRaw() //1</span></code></pre></td></tr></table></div></figure>


<p>用<code>toRaw</code>和<code>fromRaw</code>函数来对raw value和枚举值进行相互转换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let convertedRank = Rank.fromRaw(3) {
</span><span class='line'>    let threeDescription = convertedRank.simpleDescription()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The member values of an enumeration are actual values, not just another way of writing their raw values.如果没有一个有意义的raw value，你不需要再指定它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Suit {
</span><span class='line'>    case Spades, Hearts, Diamonds, Clubs
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        switch self {
</span><span class='line'>        case .Spades:
</span><span class='line'>            return "spades"
</span><span class='line'>        case .Hearts:
</span><span class='line'>            return "hearts"
</span><span class='line'>        case .Diamonds:
</span><span class='line'>            return "diamonds"
</span><span class='line'>        case .Clubs:
</span><span class='line'>            return "clubs"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let hearts = Suit.Hearts
</span><span class='line'>let heartsDescription = hearts.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p>用struct来创建一个结构,struct支持类的很多方面，如方法和初始化，和类的最大区别是structures总量以copy的形式传递，而class则以引用的形式传递</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Card {
</span><span class='line'>    var rank: Rank
</span><span class='line'>    var suit: Suit
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let threeOfSpades = Card(rank: .Three, suit: .Spades)
</span><span class='line'>let threeOfSpadesDescription = threeOfSpades.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p>Instances of the same enumeration member can have different values associated with them.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum ServerResponse {
</span><span class='line'>    case Result(String, String)
</span><span class='line'>    case Error(String)
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>let success = ServerResponse.Result("6:00 am", "8:09 pm")
</span><span class='line'>let failure = ServerResponse.Error("Out of cheese.")
</span><span class='line'> 
</span><span class='line'>switch success {
</span><span class='line'>case let .Result(sunrise, sunset):
</span><span class='line'>    let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)."
</span><span class='line'>case let .Error(error):
</span><span class='line'>    let serverResponse = "Failure...  \(error)"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意sunrise和sunset如何匹配switch中case的条件而从ServerResponse里值取出来的</p>

<h4>协议和Extensions</h4>

<p>用<code>protocol</code>来声明一个协议</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol ExampleProtocol {
</span><span class='line'>    var simpleDescription: String { get }
</span><span class='line'>    mutating func adjust()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>class SimpleClass: ExampleProtocol {
</span><span class='line'>    var simpleDescription: String = "A very simple class."
</span><span class='line'>    var anotherProperty: Int = 69105
</span><span class='line'>    func adjust() {
</span><span class='line'>        simpleDescription += "  Now 100% adjusted."
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var a = SimpleClass()
</span><span class='line'>a.adjust()
</span><span class='line'>let aDescription = a.simpleDescription
</span><span class='line'> 
</span><span class='line'>struct SimpleStructure: ExampleProtocol {
</span><span class='line'>    var simpleDescription: String = "A simple structure"
</span><span class='line'>    mutating func adjust() {
</span><span class='line'>        simpleDescription += " (adjusted)"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var b = SimpleStructure()
</span><span class='line'>b.adjust()
</span><span class='line'>let bDescription = b.simpleDescription</span></code></pre></td></tr></table></div></figure>


<p>注意在struct中mutating的使用,class中的方法无需标记为mutating,因为类中的方法总是可以改变类的
用extensions来为一个已知的类型添加功能，比如新的方法和computed properties</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Int: ExampleProtocol {
</span><span class='line'>    var simpleDescription: String {
</span><span class='line'>    return "The number \(self)"
</span><span class='line'>    }
</span><span class='line'>    mutating func adjust() {
</span><span class='line'>        self += 42
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>7.simpleDescription</span></code></pre></td></tr></table></div></figure>


<p>You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let protocolValue: ExampleProtocol = a
</span><span class='line'>protocolValue.simpleDescription
</span><span class='line'>// protocolValue.anotherProperty  // Uncomment to see the error”</span></code></pre></td></tr></table></div></figure>


<p>尽管protocolValue有一个运行时的类型SimpleClass,但编译器仍把它当作ExampleProtocol的一种类型，也就是说说了定义时协议对应的方法，你不能调用它实际所属类的方法，属性</p>

<h4>Generics</h4>

<p>在尖括号里写一个名字来创建一个generic函数或类型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; ItemType[] {
</span><span class='line'>    var result = ItemType[]()
</span><span class='line'>    for i in 0..times {
</span><span class='line'>        result += item
</span><span class='line'>    }
</span><span class='line'>    return result
</span><span class='line'>}
</span><span class='line'>repeat("knock", 4)</span></code></pre></td></tr></table></div></figure>


<p>我们既可以将这种形式用在函数和方法上，也可以用在类，枚举，结构体的定义上</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Reimplement the Swift standard library's optional type
</span><span class='line'>enum OptionalValue&lt;T&gt; {
</span><span class='line'>    case None
</span><span class='line'>    case Some(T)
</span><span class='line'>}
</span><span class='line'>var possibleInteger: OptionalValue&lt;Int&gt; = .None
</span><span class='line'>possibleInteger = .Some(100)</span></code></pre></td></tr></table></div></figure>


<p>在类型名后加一个where来指定一些必须条件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Bool {
</span><span class='line'>    for lhsItem in lhs {
</span><span class='line'>        for rhsItem in rhs {
</span><span class='line'>            if lhsItem == rhsItem {
</span><span class='line'>                return true
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>}
</span><span class='line'>anyCommonElements([1, 2, 3], [3])</span></code></pre></td></tr></table></div></figure>


<p>练习
Modify the anyCommonElements function to make a function that returns an array of the elements that any two sequences have in common.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element:     Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Array&lt;T.GeneratorType.Element&gt; {
</span><span class='line'>    var toReturn = Array&lt;T.GeneratorType.Element&gt;()
</span><span class='line'>    for lhsItem in lhs {
</span><span class='line'>        for rhsItem in rhs {
</span><span class='line'>            if lhsItem == rhsItem {
</span><span class='line'>                toReturn.append(lhsItem)
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return toReturn
</span><span class='line'>}
</span><span class='line'>anyCommonElements([1, 2, 3], [3])</span></code></pre></td></tr></table></div></figure>


<p>在一些简单的情况下，可以省略where，只在分号后写一个protocol或是类名，&lt;T: Equatable>和<T where T: Equatable>是一样的
Swift是类型安全的语言,如果你的代码希望的是String类型，类型安全将阻止你赋Int值给它</p>

<h4>常量和变量的命名</h4>

<p>我们几乎可以用任何字符来命名常量和变量，包括Unicode字符</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let π = 3.14159
</span><span class='line'>let 你好 = "你好世界"
</span><span class='line'>let 🐶🐮 = "dogcow”</span></code></pre></td></tr></table></div></figure>


<p>一旦你声明了某种类型的常量和变量，你就不能为它赋予其他类型的变量</p>

<h4>打印</h4>

<p>打印变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println(friendlyWelcome)</span></code></pre></td></tr></table></div></figure>


<p>打印中包含字符替换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The current value of friendlyWelcome is \(friendlyWelcome)")</span></code></pre></td></tr></table></div></figure>


<h4>注释</h4>

<p>不像C语言中的多行注释，Swift的多行注释是可以嵌套的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* this is the start of the first multiline comment
</span><span class='line'>/* this is the second, nested multiline comment */
</span><span class='line'>this is the end of the first multiline comment */</span></code></pre></td></tr></table></div></figure>


<h4>分号的使用</h4>

<p>如果一行中包含多条语句，就得用分号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let cat = "🐱"; println(cat)
</span><span class='line'>// prints "🐱”</span></code></pre></td></tr></table></div></figure>


<h4>整型</h4>

<ul>
<li>整型范围</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
</span><span class='line'>let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8”</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Int型和UInt
在32位OS上，(U)Int和(U)Int32的大小一样
在64位OS上，(U)Int和(U)Int64的大小一样
只有在你确实需要和OS本身的字大小一样的非整形类型时才用UInt，否则尽量用Int

<h4>浮点型</h4></li>
<li>Double代表了64位的浮点数，有至少15位小数的精度</li>
<li>Float代表了32位，只有6位小数的精度

<h4>Numeric Literals</h4>

<p>整型字面量可以写成以下形式</p></li>
<li>10进制，无前缀</li>
<li>二进度，0b前缀</li>
<li>八进制，0o前缀</li>
<li>十六进制，0x前缀</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let decimalInteger = 17
</span><span class='line'>let binaryInteger = 0b10001       // 17 in binary notation
</span><span class='line'>let octalInteger = 0o21           // 17 in octal notation
</span><span class='line'>let hexadecimalInteger = 0x11     // 17 in hexadecimal notation”</span></code></pre></td></tr></table></div></figure>


<p>浮点型可以是十制的(无前缀),也可以是十六进制的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.25e2 means 1.25 × 102, or 125.0.
</span><span class='line'>1.25e-2 means 1.25 × 10-2, or 0.0125.
</span><span class='line'>0xFp2 means 15 × 2*2, or 60.0.
</span><span class='line'>0xFp-2 means 15 × (2的-2次方), or 3.75.</span></code></pre></td></tr></table></div></figure>


<h4>整型转换</h4>

<p>溢出会报错</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let cannotBeNegative: UInt8 = -1
</span><span class='line'>// UInt8 cannot store negative numbers, and so this will report an error
</span><span class='line'>let tooBig: Int8 = Int8.max + 1
</span><span class='line'>// Int8 cannot store a number larger than its maximum value,
</span><span class='line'>// and so this will also report an error</span></code></pre></td></tr></table></div></figure>


<p>来看以下例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let twoThousand: UInt16 = 2_000
</span><span class='line'>let one: UInt8 = 1
</span><span class='line'>let twoThousandAndOne = twoThousand + UInt16(one)</span></code></pre></td></tr></table></div></figure>


<p>以上的UInt16是必须的,因为两个变量的类型不同</p>

<h4>整形和浮点型的转换</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let three = 3
</span><span class='line'>let pointOneFourOneFiveNine = 0.14159
</span><span class='line'>let pi = Double(three) + pointOneFourOneFiveNine</span></code></pre></td></tr></table></div></figure>


<p>浮点型转为整型，只保留整数,不会出现四舍五入这种情况</p>

<h4>Type Aliases</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typealias AudioSample = UInt16
</span><span class='line'>var maxAmplitudeFound = AudioSample.min</span></code></pre></td></tr></table></div></figure>


<h4>Bool型</h4>

<p>Swift的类型安全阻止了任何非bool型的值自动替换成Bool型的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let i = 1
</span><span class='line'>if i {
</span><span class='line'>    // this example will not compile, and will report an error
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>不过，以下使用方式却是对的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let i = 1
</span><span class='line'>if i == 1 {
</span><span class='line'>    // this example will compile successfully
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Tuples</h4>

<p>tuple将多个值组合一个复合的值，并且这些值可以是不同类型的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let http404Error = (404, "Not Found")
</span><span class='line'>
</span><span class='line'>let (statusCode, statusMessage) = http404Error
</span><span class='line'>println("The status code is \(statusCode)")
</span><span class='line'>// prints "The status code is 404"
</span><span class='line'>println("The status message is \(statusMessage)")
</span><span class='line'>// prints "The status message is Not Found</span></code></pre></td></tr></table></div></figure>


<p>如果你只需要一部分tuple的值 ，你可以用_来忽略你不需要的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let (justTheStatusCode, _) = http404Error
</span><span class='line'>println("The status code is \(justTheStatusCode)")
</span><span class='line'>// prints "The status code is 404</span></code></pre></td></tr></table></div></figure>


<p>也可以用以下方式来获取tuple里的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The status code is \(http404Error.0)")
</span><span class='line'>// prints "The status code is 404"
</span><span class='line'>println("The status message is \(http404Error.1)")
</span><span class='line'>// prints "The status message is Not Found</span></code></pre></td></tr></table></div></figure>


<p>在定义tuple的时候可以为每个element赋值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let http200Status = (statusCode: 200, description: "OK")
</span><span class='line'>println("The status code is \(http200Status.statusCode)")
</span><span class='line'>// prints "The status code is 200"
</span><span class='line'>println("The status message is \(http200Status.description)")
</span><span class='line'>// prints "The status message is OK"</span></code></pre></td></tr></table></div></figure>


<p>注意:Tuples仅仅适用于临时的一组相关的数据,它并不适用于复杂数据类型的创建</p>

<h4>Optionals</h4>

<p>Swift’s optionals let you indicate the absence of a value for any type at all, without the need for special constants.</p>

<h4>Forced Unwrapping</h4>

<p>当我们确定optional<code>确定</code>含有一个值时，我们可以在这个optional的名字后面加一个!来获取它的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if convertedNumber {
</span><span class='line'>    println("\(possibleNumber) has an integer value of \(convertedNumber!)")
</span><span class='line'>} else {
</span><span class='line'>    println("\(possibleNumber) could not be converted to an integer")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Optional Binding</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let constantName = someOptional {
</span><span class='line'>    statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们可以按如下方式重写之前的<code>possibleNumber</code>的例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let actualNumber = possibleNumber.toInt() {
</span><span class='line'>    println("\(possibleNumber) has an integer value of \(actualNumber)")
</span><span class='line'>} else {
</span><span class='line'>    println("\(possibleNumber) could not be converted to an integer")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以赋予一个optional 值为nil,非optional的则不行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var serverResponseCode: Int? = 404
</span><span class='line'>// serverResponseCode contains an actual Int value of 404
</span><span class='line'>serverResponseCode = nil</span></code></pre></td></tr></table></div></figure>


<p>如果在定义一个optional value时不提供一个默认值，则它为nil</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var surveyAnswer: String?
</span><span class='line'>// surveyAnswer is automatically set to nil”</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是swift的nil与oc中的nil不同,oc中的nil是一个指定不存在的对象的指针，而swift中的nil则不是指针，它只是表示某种类型的值不存在，任何类型的optional都能设置为nil，而不仅仅是对象</p>

<h4>Implicitly Unwrapped Optional</h4>

<p>也就是类型后加!,仔细看以下的区别</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let possibleString: String? = "An optional string."
</span><span class='line'>println(possibleString!) // requires an exclamation mark to access its value
</span><span class='line'>// prints "An optional string."
</span><span class='line'> 
</span><span class='line'>let assumedString: String! = "An implicitly unwrapped optional string."
</span><span class='line'>println(assumedString)  // no exclamation mark is needed to access its value
</span><span class='line'>// prints "An implicitly unwrapped optional string.
</span><span class='line'>
</span><span class='line'>if assumedString {
</span><span class='line'>    println(assumedString)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>断言</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let age = -3
</span><span class='line'>assert(age &gt;= 0, "A person's age cannot be less than zero")
</span><span class='line'>// this causes the assertion to trigger, because age is not &gt;= 0</span></code></pre></td></tr></table></div></figure>


<p>也可以不写string</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>assert(age &gt;= 0)</span></code></pre></td></tr></table></div></figure>


<p>注意assert里的string不支持<code>\()</code>形式的替换</p>

<h4>基本操作</h4>

<p>Swift允许你对浮点值进行%的运算
赋值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let b = 10
</span><span class='line'>var a = 5
</span><span class='line'>a = b</span></code></pre></td></tr></table></div></figure>


<p>不过不像C，赋值本身不返回值，所以以下是非法的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if x = y {
</span><span class='line'>    // this is not valid, because x = y does not return a value
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>不像C，Swift默认情况下不允许进行算术运算时的值溢出
两个Character的值，或者一个Character和一个String的值，能相加组成一个新的String的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let dog: Character = "🐶"
</span><span class='line'>let cow: Character = "🐮"
</span><span class='line'>let dogCow = dog + cow
</span><span class='line'>// dogCow is equal to "🐶🐮”</span></code></pre></td></tr></table></div></figure>


<h4>求余运算符%</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-9 % 4   // equals -1</span></code></pre></td></tr></table></div></figure>


<p>除数的符号是被忽略的，也就是说a % b和a % -b的值是一样的
浮点数的求余操作</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>8 % 2.5   // equals 0.5</span></code></pre></td></tr></table></div></figure>


<h4>比较操作符</h4>

<p><code>===</code>可以用来测试两个对象的引用是否指向同一个对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let name = "world"
</span><span class='line'>if name == "world" {
</span><span class='line'>    println("hello, world")
</span><span class='line'>} else {
</span><span class='line'>    println("I'm sorry \(name), but I don't recognize you")
</span><span class='line'>}
</span><span class='line'>// prints "hello, world", because name is indeed equal to "world"</span></code></pre></td></tr></table></div></figure>


<h4>Range操作</h4>

<p>闭区间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for index in 1...5 {
</span><span class='line'>    println("\(index) times 5 is \(index * 5)")
</span><span class='line'>}
</span><span class='line'>// 1 times 5 is 5
</span><span class='line'>// 2 times 5 is 10
</span><span class='line'>// 3 times 5 is 15
</span><span class='line'>// 4 times 5 is 20
</span><span class='line'>// 5 times 5 is 25”</span></code></pre></td></tr></table></div></figure>


<p>开区间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Anna", "Alex", "Brian", "Jack"]
</span><span class='line'>let count = names.count
</span><span class='line'>for i in 0..count {
</span><span class='line'>    println("Person \(i + 1) is called \(names[i])")
</span><span class='line'>}
</span><span class='line'>// Person 1 is called Anna
</span><span class='line'>// Person 2 is called Alex
</span><span class='line'>// Person 3 is called Brian
</span><span class='line'>// Person 4 is called Jack</span></code></pre></td></tr></table></div></figure>


<h4>字符串和字符</h4>

<p>Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.
注意OC中的string相关的API，Swift都的String都能使用</p>

<h5>String Literals</h5>

<ul>
<li>转义字符\0(空字符),\(返斜杆),\t,\n,\r,\&ldquo;,`</li>
<li>单字节的Unicode scalars,\xnn,nn是两位十六进制的数字</li>
<li>两个字节的Unicode scalars,\unnnn,nnnn是一个四位十六进制的数字</li>
<li>四个字节的Unicode scalars,\Unnnnnnnn,nnnnnnnn是八位的十六进制的数字</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"
</span><span class='line'>// "Imagination is more important than knowledge" - Einstein
</span><span class='line'>let dollarSign = "\x24"        // $,  Unicode scalar U+0024
</span><span class='line'>let blackHeart = "\u2665"      // ♥,  Unicode scalar U+2665
</span><span class='line'>let sparklingHeart = "\U0001F496"  // 💖, Unicode scalar U+1F496”</span></code></pre></td></tr></table></div></figure>


<h4>初始化一个空字符串</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var emptyString = ""               // empty string literal
</span><span class='line'>var anotherEmptyString = String()  // initializer syntax
</span><span class='line'>// these two strings are both empty, and are equivalent to each other</span></code></pre></td></tr></table></div></figure>


<p>判断一个String的值是否是空的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if emptyString.isEmpty {
</span><span class='line'>    println("Nothing to see here")
</span><span class='line'>}
</span><span class='line'>// prints "Nothing to see here</span></code></pre></td></tr></table></div></figure>


<p>你可以在定义一个字符串时用var和let来表示字符串是否可变</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var variableString = "Horse"
</span><span class='line'>variableString += " and carriage"
</span><span class='line'>// variableString is now "Horse and carriage"
</span><span class='line'> 
</span><span class='line'>let constantString = "Highlander"
</span><span class='line'>constantString += " and another Highlander"
</span><span class='line'>// this reports a compile-time error - a constant string cannot be modified</span></code></pre></td></tr></table></div></figure>


<h4>Strings是值类型</h4>

<p>也就是说如果string的值被传入函数或方法，或被赋值时，它是被copy的！幕后，Swift的编译器优化了string的使用，所以copy只有在真正需要的时候才发生,这意味着你无需担心性能总量</p>

<h5>遍历string中的字符</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for character in "Dog!🐶" {
</span><span class='line'>    println(character)
</span><span class='line'>}
</span><span class='line'>// D
</span><span class='line'>// o
</span><span class='line'>// g
</span><span class='line'>// !
</span><span class='line'>// 🐶”</span></code></pre></td></tr></table></div></figure>


<p>创建一个character</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let yenSign: Character = "¥"</span></code></pre></td></tr></table></div></figure>


<h4>计算Characters的个数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
</span><span class='line'>println("unusualMenagerie has \(countElements(unusualMenagerie)) characters")
</span><span class='line'>// prints "unusualMenagerie has 40 characters”</span></code></pre></td></tr></table></div></figure>


<p>不同的Unicode字符或同一Unicode字符的不同表示形式在内存中占的空间不一样，基于此，swift中的字符并不占用同样的内存，所以要计算一个string的长度，我们必须逐个遍历字符</p>

<p><code>Note</code> also that the character count returned by countElements is not always the same as the length property of an NSString that contains the same characters. The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode characters within the string. To reflect this fact, the length property from NSString is called utf16count when it is accessed on a Swift String value.</p>

<h4>连接字符串和字符</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let string1 = "hello"
</span><span class='line'>let string2 = " there"
</span><span class='line'>let character1: Character = "!"
</span><span class='line'>let character2: Character = "?"
</span><span class='line'> 
</span><span class='line'>let stringPlusCharacter = string1 + character1        // equals "hello!"
</span><span class='line'>let stringPlusString = string1 + string2              // equals "hello there"
</span><span class='line'>let characterPlusString = character1 + string1        // equals "!hello"
</span><span class='line'>let characterPlusCharacter = character1 + character2  // equals "!?”</span></code></pre></td></tr></table></div></figure>


<h4>比较字符串</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let quotation = "We're a lot alike, you and I."
</span><span class='line'>let sameQuotation = "We're a lot alike, you and I."
</span><span class='line'>if quotation == sameQuotation {
</span><span class='line'>    println("These two strings are considered equal")
</span><span class='line'>}
</span><span class='line'>// prints "These two strings are considered equal</span></code></pre></td></tr></table></div></figure>


<h5>前缀和后缀的比较</h5>

<p>hasPrefix和hasSuffix
前缀</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let romeoAndJuliet = [
</span><span class='line'>    "Act 1 Scene 1: Verona, A public place",
</span><span class='line'>    "Act 1 Scene 2: Capulet's mansion",
</span><span class='line'>    "Act 1 Scene 3: A room in Capulet's mansion",
</span><span class='line'>    "Act 1 Scene 4: A street outside Capulet's mansion",
</span><span class='line'>    "Act 1 Scene 5: The Great Hall in Capulet's mansion",
</span><span class='line'>    "Act 2 Scene 1: Outside Capulet's mansion",
</span><span class='line'>    "Act 2 Scene 2: Capulet's orchard",
</span><span class='line'>    "Act 2 Scene 3: Outside Friar Lawrence's cell",
</span><span class='line'>    "Act 2 Scene 4: A street in Verona",
</span><span class='line'>    "Act 2 Scene 5: Capulet's mansion",
</span><span class='line'>    "Act 2 Scene 6: Friar Lawrence's cell"
</span><span class='line'>]
</span><span class='line'>
</span><span class='line'>var act1SceneCount = 0
</span><span class='line'>for scene in romeoAndJuliet {
</span><span class='line'>    if scene.hasPrefix("Act 1 ") {
</span><span class='line'>        ++act1SceneCount
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println("There are \(act1SceneCount) scenes in Act 1")
</span><span class='line'>// prints "There are 5 scenes in Act 1</span></code></pre></td></tr></table></div></figure>


<p>后缀</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var mansionCount = 0
</span><span class='line'>var cellCount = 0
</span><span class='line'>for scene in romeoAndJuliet {
</span><span class='line'>    if scene.hasSuffix("Capulet's mansion") {
</span><span class='line'>        ++mansionCount
</span><span class='line'>    } else if scene.hasSuffix("Friar Lawrence's cell") {
</span><span class='line'>        ++cellCount
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
</span><span class='line'>// prints "6 mansion scenes; 2 cell scenes”</span></code></pre></td></tr></table></div></figure>


<h5>大小写转换</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let normal = "Could you help me, please?""
</span><span class='line'>let shouty = normal.uppercaseString
</span><span class='line'>// shouty is equal to "COULD YOU HELP ME, PLEASE?"
</span><span class='line'>let whispered = normal.lowercaseString
</span><span class='line'>// whispered is equal to "could you help me, please?”</span></code></pre></td></tr></table></div></figure>


<h4>Unicode p118</h4>

<h4>Collection 类型</h4>

<h5>Array</h5>

<p>不同于OC中的array(可存储不同类型的对象)，array存储了同类型的对象，无需一定要存储对象，也可存储Int等类型
以下两个定义等价</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var shoppingList: String[] = ["Eggs", "Milk"]
</span><span class='line'>var shoppingList = ["Eggs", "Milk"]</span></code></pre></td></tr></table></div></figure>


<h5>访问或修改array</h5>

<p>计算array的大小</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>“println("The shopping list contains \(shoppingList.count) items.")
</span><span class='line'>// prints "The shopping list contains 2 items.”</span></code></pre></td></tr></table></div></figure>


<p>用isEmpty来判断coun得否为0</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if shoppingList.isEmpty {
</span><span class='line'>    println("The shopping list is empty.")
</span><span class='line'>} else {
</span><span class='line'>    println("The shopping list is not empty.")
</span><span class='line'>}
</span><span class='line'>// prints "The shopping list is not empty."</span></code></pre></td></tr></table></div></figure>


<p>添加元素</p>

<ul>
<li>用append</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList.append("Flour")
</span><span class='line'>// shoppingList now contains 3 items, and someone is making pancakes”</span></code></pre></td></tr></table></div></figure>


<ul>
<li>用+=</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList += "Baking Powder"
</span><span class='line'>// shoppingList now contains 4 items”
</span><span class='line'>
</span><span class='line'>shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
</span><span class='line'>// shoppingList now contains 7 items”</span></code></pre></td></tr></table></div></figure>


<p>用Range来改变数组里一些元素的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList[4...6] = ["Bananas", "Apples"]
</span><span class='line'>// shoppingList now contains 6 items”</span></code></pre></td></tr></table></div></figure>


<p>在某位置插入元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList.insert("Maple Syrup", atIndex: 0)
</span><span class='line'>// shoppingList now contains 7 items
</span><span class='line'>// "Maple Syrup" is now the first item in the list”</span></code></pre></td></tr></table></div></figure>


<p>移除元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let mapleSyrup = shoppingList.removeAtIndex(0)
</span><span class='line'>let apples = shoppingList.removeLast()</span></code></pre></td></tr></table></div></figure>


<p>遍历</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for item in shoppingList {
</span><span class='line'>    println(item)
</span><span class='line'>}
</span><span class='line'>// Six eggs
</span><span class='line'>// Milk
</span><span class='line'>// Flour
</span><span class='line'>// Baking Powder
</span><span class='line'>// Bananas”</span></code></pre></td></tr></table></div></figure>


<p>如果你在遍历时需要知道对应的index，可以用以下方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (index, value) in enumerate(shoppingList) {
</span><span class='line'>    println("Item \(index + 1): \(value)")
</span><span class='line'>}
</span><span class='line'>// Item 1: Six eggs
</span><span class='line'>// Item 2: Milk
</span><span class='line'>// Item 3: Flour
</span><span class='line'>// Item 4: Baking Powder
</span><span class='line'>// Item 5: Bananas</span></code></pre></td></tr></table></div></figure>


<h4>创建和初始化Array</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someInts = Int[]()
</span><span class='line'>println("someInts is of type Int[] with \(someInts.count) items.")
</span><span class='line'>// prints "someInts is of type Int[] with 0 items.</span></code></pre></td></tr></table></div></figure>


<p>注意以下例子，虽然someInt=[]不指定任何类型，但从前段代码可知它的元素是Int类型的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>someInts.append(3)
</span><span class='line'>// someInts now contains 1 value of type Int
</span><span class='line'>someInts = []
</span><span class='line'>// someInts is now an empty array, but is still of type Int[]</span></code></pre></td></tr></table></div></figure>


<p>指定default值和数目的初始化</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var threeDoubles = Double[](count: 3, repeatedValue: 0.0)
</span><span class='line'>// threeDoubles is of type Double[], and equals [0.0, 0.0, 0.0]
</span><span class='line'>
</span><span class='line'>var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)
</span><span class='line'>// anotherThreeDoubles is inferred as Double[], and equals [2.5, 2.5, 2.5]</span></code></pre></td></tr></table></div></figure>


<p>最后我们能通过+来将两个数组连成一个</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var sixDoubles = threeDoubles + anotherThreeDoubles
</span><span class='line'>// sixDoubles is inferred as Double[], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]”</span></code></pre></td></tr></table></div></figure>


<h4>字典</h4>

<p>对key的唯一要求是hashable,Enumeration member values without associated values (as described in Enumerations) are also hashable by default.
以下两个定义是等价的，swift能推测出它的类型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]”
</span><span class='line'>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]
</span></code></pre></td></tr></table></div></figure>


<h4>访问和修改字典</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The dictionary of airports contains \(airports.count) items.")
</span><span class='line'>// prints "The dictionary of airports contains 2 items.</span></code></pre></td></tr></table></div></figure>


<p>方法updateValue(forKey:)的使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let oldValue = airports.updateValue("Dublin International", forKey: "DUB") {
</span><span class='line'>    println("The old value for DUB was \(oldValue).")
</span><span class='line'>}
</span><span class='line'>// prints "The old value for DUB was Dublin.</span></code></pre></td></tr></table></div></figure>


<p>注意，此方法对应的是key对应的旧值，返回的是一个optional value
用[]获取的值也是optional vlaue</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let airportName = airports["DUB"] {
</span><span class='line'>    println("The name of the airport is \(airportName).")
</span><span class='line'>} else {
</span><span class='line'>    println("That airport is not in the airports dictionary.")
</span><span class='line'>}
</span><span class='line'>// prints "The name of the airport is Dublin International.</span></code></pre></td></tr></table></div></figure>


<p>我们可以将nil赋予key对应的值来移除此key</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>airports["APL"] = "Apple International"
</span><span class='line'>// "Apple International" is not the real airport for APL, so delete it
</span><span class='line'>airports["APL"] = nil
</span><span class='line'>// APL has now been removed from the dictionary</span></code></pre></td></tr></table></div></figure>


<p>也可以用<code>removeValueForKey</code>方法
此方法返回的是key对应的旧值,或者nil(如果不存在的话)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let removedValue = airports.removeValueForKey("DUB") {
</span><span class='line'>    println("The removed airport's name is \(removedValue).")
</span><span class='line'>} else {
</span><span class='line'>    println("The airports dictionary does not contain a value for DUB.")
</span><span class='line'>}
</span><span class='line'>// prints "The removed airport's name is Dublin International.”</span></code></pre></td></tr></table></div></figure>


<h5>遍历字典</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (airportCode, airportName) in airports {
</span><span class='line'>    println("\(airportCode): \(airportName)")
</span><span class='line'>}
</span><span class='line'>// TYO: Tokyo
</span><span class='line'>// LHR: London Heathrow
</span><span class='line'>
</span><span class='line'>for airportCode in airports.keys {
</span><span class='line'>    println("Airport code: \(airportCode)")
</span><span class='line'>}
</span><span class='line'>// Airport code: TYO
</span><span class='line'>// Airport code: LHR
</span><span class='line'> 
</span><span class='line'>for airportName in airports.values {
</span><span class='line'>    println("Airport name: \(airportName)")
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//用keys或values创建一个数组
</span><span class='line'>let airportCodes = Array(airports.keys)
</span><span class='line'>// airportCodes is ["TYO", "LHR"]
</span><span class='line'> 
</span><span class='line'>let airportNames = Array(airports.values)
</span><span class='line'>// airportNames is ["Tokyo", "London Heathrow"]</span></code></pre></td></tr></table></div></figure>


<h4>创建一个空的字典</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var namesOfIntegers = Dictionary&lt;Int, String&gt;()</span></code></pre></td></tr></table></div></figure>


<p>注意以下,namesIntegers能被推断出是&lt;Int,String></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>namesOfIntegers[16] = "sixteen"
</span><span class='line'>// namesOfIntegers now contains 1 key-value pair
</span><span class='line'>namesOfIntegers = [:]</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>Behind the scenes, Swift’s array and dictionary types are implemented as generic collections</p>

<h4>Mutability Of Collections</h4>

<p>对字典来说,immutability意味着你不能改变一个key对应的值，而对数组来说，你只是不能改变它的大小，但仍然能改变某个index对应的值</p>

<h4>条件语句</h4>

<p>注意,swift的switch中的case后无需跟着break，因为执行完case里的语句就自动break了，cases也能匹配不同的类型，包括range,tuples或转换为某一具体的类型</p>

<h5>For Loops</h5>

<ul>
<li>For-In</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for index in 1...5 {
</span><span class='line'>    println("\(index) times 5 is \(index * 5)")
</span><span class='line'>}
</span><span class='line'>// 1 times 5 is 5
</span><span class='line'>// 2 times 5 is 10
</span><span class='line'>// 3 times 5 is 15
</span><span class='line'>// 4 times 5 is 20
</span><span class='line'>// 5 times 5 is 25”</span></code></pre></td></tr></table></div></figure>


<p>如果你不需要index，可以用<code>_</code>来忽略它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let base = 3
</span><span class='line'>let power = 10
</span><span class='line'>var answer = 1
</span><span class='line'>for _ in 1...power {
</span><span class='line'>    answer *= base
</span><span class='line'>}
</span><span class='line'>println("\(base) to the power of \(power) is \(answer)")
</span><span class='line'>// prints "3 to the power of 10 is 59049</span></code></pre></td></tr></table></div></figure>


<p>array,dictionary,characters的for-in</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Anna", "Alex", "Brian", "Jack"]
</span><span class='line'>for name in names {
</span><span class='line'>    println("Hello, \(name)!")
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
</span><span class='line'>for (animalName, legCount) in numberOfLegs {
</span><span class='line'>    println("\(animalName)s have \(legCount) legs")
</span><span class='line'>}
</span><span class='line'>// spiders have 8 legs
</span><span class='line'>// ants have 6 legs
</span><span class='line'>// cats have 4 legs
</span><span class='line'>
</span><span class='line'>for character in "Hello" {
</span><span class='line'>    println(character)
</span><span class='line'>}
</span><span class='line'>// H
</span><span class='line'>// e
</span><span class='line'>// l
</span><span class='line'>// l
</span><span class='line'>// o</span></code></pre></td></tr></table></div></figure>


<h5>For-Condition-Increment</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for var index = 0; index &lt; 3; ++index {
</span><span class='line'>    println("index is \(index)")
</span><span class='line'>}
</span><span class='line'>// index is 0
</span><span class='line'>// index is 1
</span><span class='line'>// index is 2</span></code></pre></td></tr></table></div></figure>


<p>注意for后无需括号</p>

<h5>条件语句</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var temperatureInFahrenheit = 30
</span><span class='line'>if temperatureInFahrenheit &lt;= 32 {
</span><span class='line'>    println("It's very cold. Consider wearing a scarf.")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>switch语句</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someCharacter: Character = "e"
</span><span class='line'>switch someCharacter {
</span><span class='line'>case "a", "e", "i", "o", "u":
</span><span class='line'>    println("\(someCharacter) is a vowel")
</span><span class='line'>case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
</span><span class='line'>"n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
</span><span class='line'>    println("\(someCharacter) is a consonant")
</span><span class='line'>default:
</span><span class='line'>    println("\(someCharacter) is not a vowel or a consonant")
</span><span class='line'>}
</span><span class='line'>// prints "e is a vowel”</span></code></pre></td></tr></table></div></figure>


<p>注意，以下方式不行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anotherCharacter: Character = "a"
</span><span class='line'>switch anotherCharacter {
</span><span class='line'>case "a":
</span><span class='line'>case "A":
</span><span class='line'>    println("The letter A")
</span><span class='line'>default:
</span><span class='line'>    println("Not the letter A")
</span><span class='line'>}
</span><span class='line'>// this will report a compile-time error</span></code></pre></td></tr></table></div></figure>


<p>每个case里必须对应相应的语句</p>

<h5>Range Matching</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let count = 3_000_000_000_000
</span><span class='line'>let countedThings = "stars in the Milky Way"
</span><span class='line'>var naturalCount: String
</span><span class='line'>switch count {
</span><span class='line'>case 0:
</span><span class='line'>    naturalCount = "no"
</span><span class='line'>case 1...3:
</span><span class='line'>    naturalCount = "a few"
</span><span class='line'>case 4...9:
</span><span class='line'>    naturalCount = "several"
</span><span class='line'>case 10...99:
</span><span class='line'>    naturalCount = "tens of"
</span><span class='line'>case 100...999:
</span><span class='line'>    naturalCount = "hundreds of"
</span><span class='line'>case 1000...999_999:
</span><span class='line'>    naturalCount = "thousands of"
</span><span class='line'>default:
</span><span class='line'>    naturalCount = "millions and millions of"
</span><span class='line'>}
</span><span class='line'>println("There are \(naturalCount) \(countedThings).")
</span><span class='line'>// prints "There are millions and millions of stars in the Milky Way.”</span></code></pre></td></tr></table></div></figure>


<h5>Tuples</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let somePoint = (1, 1)
</span><span class='line'>switch somePoint {
</span><span class='line'>case (0, 0):
</span><span class='line'>    println("(0, 0) is at the origin")
</span><span class='line'>case (_, 0):
</span><span class='line'>    println("(\(somePoint.0), 0) is on the x-axis")
</span><span class='line'>case (0, _):
</span><span class='line'>    println("(0, \(somePoint.1)) is on the y-axis")
</span><span class='line'>case (-2...2, -2...2):
</span><span class='line'>    println("(\(somePoint.0), \(somePoint.1)) is inside the box")
</span><span class='line'>default:
</span><span class='line'>    println("(\(somePoint.0), \(somePoint.1)) is outside of the box")
</span><span class='line'>}
</span><span class='line'>// prints "(1, 1) is inside the box”</span></code></pre></td></tr></table></div></figure>


<h4>Value Bindings</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anotherPoint = (2, 0)
</span><span class='line'>switch anotherPoint {
</span><span class='line'>case (let x, 0):
</span><span class='line'>    println("on the x-axis with an x value of \(x)")
</span><span class='line'>case (0, let y):
</span><span class='line'>    println("on the y-axis with a y value of \(y)")
</span><span class='line'>case let (x, y):
</span><span class='line'>    println("somewhere else at (\(x), \(y))")
</span><span class='line'>}
</span><span class='line'>// prints "on the x-axis with an x value of 2”</span></code></pre></td></tr></table></div></figure>


<h5>where的使用</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let yetAnotherPoint = (1, -1)
</span><span class='line'>switch yetAnotherPoint {
</span><span class='line'>case let (x, y) where x == y:
</span><span class='line'>    println("(\(x), \(y)) is on the line x == y")
</span><span class='line'>case let (x, y) where x == -y:
</span><span class='line'>    println("(\(x), \(y)) is on the line x == -y")
</span><span class='line'>case let (x, y):
</span><span class='line'>    println("(\(x), \(y)) is just some arbitrary point")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Control Transfer语句</h5>

<p>注意FallThrough的使用,来看以下例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let integerToDescribe = 5
</span><span class='line'>var description = "The number \(integerToDescribe) is"
</span><span class='line'>switch integerToDescribe {
</span><span class='line'>case 2, 3, 5, 7, 11, 13, 17, 19:
</span><span class='line'>    description += " a prime number, and also"
</span><span class='line'>    fallthrough
</span><span class='line'>default:
</span><span class='line'>    description += " an integer."
</span><span class='line'>}
</span><span class='line'>println(description)
</span><span class='line'>// prints "The number 5 is a prime number, and also an integer.”</span></code></pre></td></tr></table></div></figure>


<h4>Labeled语句</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gameLoop: while square != finalSquare {
</span><span class='line'>    if ++diceRoll == 7 { diceRoll = 1 }
</span><span class='line'>    switch square + diceRoll {
</span><span class='line'>    case finalSquare:
</span><span class='line'>        // diceRoll will move us to the final square, so the game is over
</span><span class='line'>        break gameLoop
</span><span class='line'>    case let newSquare where newSquare &gt; finalSquare:
</span><span class='line'>        // diceRoll will move us beyond the final square, so roll again
</span><span class='line'>        continue gameLoop
</span><span class='line'>    default:
</span><span class='line'>        // this is a valid move, so find out its effect
</span><span class='line'>        square += diceRoll
</span><span class='line'>        square += board[square]
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println("Game over!")”</span></code></pre></td></tr></table></div></figure>


<h4>函数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayHello(personName: String) -&gt; String {
</span><span class='line'>    let greeting = "Hello, " + personName + "!"
</span><span class='line'>    return greeting
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>println(sayHello("Anna"))
</span><span class='line'>// prints "Hello, Anna!"
</span><span class='line'>println(sayHello("Brian"))
</span><span class='line'>// prints "Hello, Brian!”
</span><span class='line'>
</span><span class='line'>func sayHelloWorld() -&gt; String {
</span><span class='line'>    return "hello, world"
</span><span class='line'>}
</span><span class='line'>println(sayHelloWorld())
</span><span class='line'>// prints "hello, world”</span></code></pre></td></tr></table></div></figure>


<p>无返回值的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayGoodbye(personName: String) {
</span><span class='line'>    println("Goodbye, \(personName)!")
</span><span class='line'>}
</span><span class='line'>sayGoodbye("Dave")
</span><span class='line'>// prints "Goodbye, Dave!"</span></code></pre></td></tr></table></div></figure>


<p>注意，实际上，虽然函数没写返回值，但它返回的是一个空的tuple<code>()</code></p>

<h5>返回多个值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func count(string: String) -&gt; (vowels: Int, consonants: Int, others: Int) {
</span><span class='line'>    var vowels = 0, consonants = 0, others = 0
</span><span class='line'>    for character in string {
</span><span class='line'>        switch String(character).lowercaseString {
</span><span class='line'>        case "a", "e", "i", "o", "u":
</span><span class='line'>            ++vowels
</span><span class='line'>        case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
</span><span class='line'>        "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
</span><span class='line'>            ++consonants
</span><span class='line'>        default:
</span><span class='line'>            ++others
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return (vowels, consonants, others)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let total = count("some arbitrary string!")
</span><span class='line'>println("\(total.vowels) vowels and \(total.consonants) consonants")
</span><span class='line'>// prints "6 vowels and 13 consonants”</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>,.vowerls和.consonants依然可用!!!</p>

<h5>External Parameter Names</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunction(externalParameterName localParameterName: Int) {
</span><span class='line'>    // function body goes here, and can use localParameterName
</span><span class='line'>    // to refer to the argument value for that parameter
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func join(string s1: String, toString s2: String, withJoiner joiner: String)
</span><span class='line'>    -&gt; String {
</span><span class='line'>        return s1 + joiner + s2
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>join(string: "hello", toString: "world", withJoiner: ", ")</span></code></pre></td></tr></table></div></figure>


<h5>Shorthand External Parameter Names</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool {
</span><span class='line'>    for character in string {
</span><span class='line'>        if character == characterToFind {
</span><span class='line'>            return true
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let containsAVee = containsCharacter(string: "aardvark", characterToFind: "v")
</span><span class='line'>// containsAVee equals true, because "aardvark" contains a "v”</span></code></pre></td></tr></table></div></figure>


<h4>参数的默认值</h4>

<p>将有默认值的参数放在最后</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func join(string s1: String, toString s2: String,
</span><span class='line'>    withJoiner joiner: String = " ") -&gt; String {
</span><span class='line'>        return s1 + joiner + s2
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>join(string: "hello", toString: "world", withJoiner: "-")
</span><span class='line'>// returns "hello-world"
</span><span class='line'>
</span><span class='line'>join(string: "hello", toString: "world")
</span><span class='line'>// returns "hello world"</span></code></pre></td></tr></table></div></figure>


<h5>External Names for Parameters with Default Values</h5>

<p>Swift provides an automatic external name for any defaulted parameter you define
故可以像如下调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>join("hello", "world", joiner: "-")</span></code></pre></td></tr></table></div></figure>


<h5>Variadic Parameters</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func arithmeticMean(numbers: Double...) -&gt; Double {
</span><span class='line'>    var total: Double = 0
</span><span class='line'>    for number in numbers {
</span><span class='line'>        total += number
</span><span class='line'>    }
</span><span class='line'>    return total / Double(numbers.count)
</span><span class='line'>}
</span><span class='line'>arithmeticMean(1, 2, 3, 4, 5)
</span><span class='line'>// returns 3.0, which is the arithmetic mean of these five numbers
</span><span class='line'>arithmeticMean(3, 8, 19)
</span><span class='line'>// returns 10.0, which is the arithmetic mean of these three numbers</span></code></pre></td></tr></table></div></figure>


<p>一个函数至多只能有一个variadic参数，它必须总是在所有参数的最后!</p>

<h5>Constant 和 Variable 参数</h5>

<p>函数的参数默认是constant的,如果试图修改它将导致错误,我们可以在参数前加var来让它可修改</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func alignRight(var string: String, count: Int, pad: Character) -&gt; String {
</span><span class='line'>    let amountToPad = count - countElements(string)
</span><span class='line'>    for _ in 1...amountToPad {
</span><span class='line'>        string = pad + string
</span><span class='line'>    }
</span><span class='line'>    return string
</span><span class='line'>}
</span><span class='line'>let originalString = "hello"
</span><span class='line'>let paddedString = alignRight(originalString, 10, "-")
</span><span class='line'>// paddedString is equal to "-----hello"
</span><span class='line'>// originalString is still equal to "hello”</span></code></pre></td></tr></table></div></figure>


<h5>In-Out参数</h5>

<p>来看个demo就明白In-Out是如何使用的了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoInts(inout a: Int, inout b: Int) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoInts(&someInt, &anotherInt)
</span><span class='line'>println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
</span><span class='line'>// prints "someInt is now 107, and anotherInt is now 3”</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是In-out参数不能有默认值,variadic参数不能与inout一起使用,let也不行</p>

<h5>函数类型</h5>

<p>可以像以下这么用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var mathFunction: (Int, Int) -&gt; Int = addTwoInts
</span><span class='line'>println("Result: \(mathFunction(2, 3))")</span></code></pre></td></tr></table></div></figure>


<p>同样的函数签名也可以赋值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mathFunction = multiplyTwoInts
</span><span class='line'>println("Result: \(mathFunction(2, 3))")
</span><span class='line'>// prints "Result: 6</span></code></pre></td></tr></table></div></figure>


<p>也可以根据Swift的自动推断功能像以下方法使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anotherMathFunction = addTwoInts</span></code></pre></td></tr></table></div></figure>


<h5>充当参数的函数类型</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func printMathResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int) {
</span><span class='line'>    println("Result: \(mathFunction(a, b))")
</span><span class='line'>}
</span><span class='line'>printMathResult(addTwoInts, 3, 5)
</span><span class='line'>// prints "Result: 8”</span></code></pre></td></tr></table></div></figure>


<h5>作为返回类型的函数类型</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func stepForward(input: Int) -&gt; Int {
</span><span class='line'>    return input + 1
</span><span class='line'>}
</span><span class='line'>func stepBackward(input: Int) -&gt; Int {
</span><span class='line'>    return input - 1
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
</span><span class='line'>    return backwards ? stepBackward : stepForward
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var currentValue = 3
</span><span class='line'>let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
</span><span class='line'>// moveNearerToZero now refers to the stepBackward() function
</span><span class='line'>
</span><span class='line'>println("Counting to zero:")
</span><span class='line'>// Counting to zero:
</span><span class='line'>while currentValue != 0 {
</span><span class='line'>    println("\(currentValue)... ")
</span><span class='line'>    currentValue = moveNearerToZero(currentValue)
</span><span class='line'>}
</span><span class='line'>println("zero!")
</span><span class='line'>// 3...
</span><span class='line'>// 2...
</span><span class='line'>// 1...
</span><span class='line'>// zero!</span></code></pre></td></tr></table></div></figure>


<h5>嵌套函数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
</span><span class='line'>    func stepForward(input: Int) -&gt; Int { return input + 1 }
</span><span class='line'>    func stepBackward(input: Int) -&gt; Int { return input - 1 }
</span><span class='line'>    return backwards ? stepBackward : stepForward
</span><span class='line'>}
</span><span class='line'>var currentValue = -4
</span><span class='line'>let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
</span><span class='line'>// moveNearerToZero now refers to the nested stepForward() function
</span><span class='line'>while currentValue != 0 {
</span><span class='line'>    println("\(currentValue)... ")
</span><span class='line'>    currentValue = moveNearerToZero(currentValue)
</span><span class='line'>}
</span><span class='line'>println("zero!")
</span><span class='line'>// -4...
</span><span class='line'>// -3...
</span><span class='line'>// -2...
</span><span class='line'>// -1...
</span><span class='line'>// zero!</span></code></pre></td></tr></table></div></figure>


<h4>闭包</h4>

<p>类似OC中的block</p>

<h5>Sort函数</h5>

<p>第一种使用方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</span><span class='line'>//demo 1
</span><span class='line'>func backwards(s1: String, s2: String) -&gt; Bool {
</span><span class='line'>    return s1 &gt; s2
</span><span class='line'>}
</span><span class='line'>var reversed = sort(names, backwards)</span></code></pre></td></tr></table></div></figure>


<p>第二种</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in
</span><span class='line'>    return s1 &gt; s2
</span><span class='line'>    })</span></code></pre></td></tr></table></div></figure>


<p>closure的body和声明用in关键词分隔开来</p>

<h5>Inferring Type From Context</h5>

<p>由于sort的closure是以参数的形式传入函数，所以swift能从推测出闭包的参数类型和返回值类型,所以我们可以按以下方式来写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { s1, s2 in return s1 &gt; s2 } )</span></code></pre></td></tr></table></div></figure>


<p>也可以省略return,因为默认是有return这个关键字的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { s1, s2 in  s1 &gt; s2 } )</span></code></pre></td></tr></table></div></figure>


<h5>Shorthand Argument Names</h5>

<p>Swift默认为内联的参数名指定了诸如$0, $1等名字
If you use these shorthand argument names within your closure expression, you can omit the closure’s argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type. The in keyword can also be omitted, because the closure expression is made up entirely of its body:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { $0 &gt; $1 } )</span></code></pre></td></tr></table></div></figure>


<p>以上的demo中,$0和$1分别指向了闭包的第一个和第二个String参数</p>

<h5>Operators Function</h5>

<p>There’s actually an even shorter way to write the closure expression above. Swift’s String type defines its string-specific implementation of the greater-than operator (>) as a function that has two parameters of type String, and returns a value of type Bool. This exactly matches the function type needed for the sort function’s second parameter. Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, &gt;)</span></code></pre></td></tr></table></div></figure>


<h5>Trailing Closures</h5>

<p>如果你将一个闭包指定为一个函数的最后一个参数，并且这个闭包表达式很长，你可以将它作为一个trailing closure,它是一个写在函数的括号之外的closure</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunctionThatTakesAClosure(closure: () -&gt; ()) {
</span><span class='line'>    // function body goes here
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// here's how you call this function without using a trailing closure:
</span><span class='line'> 
</span><span class='line'>someFunctionThatTakesAClosure({
</span><span class='line'>    // closure's body goes here
</span><span class='line'>    })
</span><span class='line'> 
</span><span class='line'>// here's how you call this function with a trailing closure instead:
</span><span class='line'> 
</span><span class='line'>someFunctionThatTakesAClosure() {
</span><span class='line'>    // trailing closure's body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>:如果一个closure expression是一个函数的惟参数,则无需要括号，故以上也可以写成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>someFunctionThatTakesAClosure {
</span><span class='line'>    // trailing closure's body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看一个Array中的map方法的例子，只有一个参数，也是一个closure</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let digitNames = [
</span><span class='line'>    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
</span><span class='line'>    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
</span><span class='line'>]
</span><span class='line'>let numbers = [16, 58, 510]
</span><span class='line'>
</span><span class='line'>let strings = numbers.map {
</span><span class='line'>    (var number) -&gt; String in
</span><span class='line'>    var output = ""
</span><span class='line'>    while number &gt; 0 {
</span><span class='line'>        output = digitNames[number % 10]! + output
</span><span class='line'>        number /= 10
</span><span class='line'>    }
</span><span class='line'>    return output
</span><span class='line'>}
</span><span class='line'>// strings is inferred to be of type String[]
</span><span class='line'>// its value is ["OneSix", "FiveEight", "FiveOneZero"]</span></code></pre></td></tr></table></div></figure>


<h5>Capturing Values</h5>

<p>Swift中closure的最简单形式是一个内嵌的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
</span><span class='line'>    var runningTotal = 0
</span><span class='line'>    func incrementor() -&gt; Int {
</span><span class='line'>        runningTotal += amount
</span><span class='line'>        return runningTotal
</span><span class='line'>    }
</span><span class='line'>    return incrementor
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>because it modifies the runningTotal variable each time it is called, incrementor captures a reference to the current runningTotal variable, and not just a copy of its initial value. Capturing a reference ensures sure that runningTotal does not disappear when the call to makeIncrementor ends, and ensures that runningTotal will continue to be available the next time that the incrementor function is called.
注意以下的调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let incrementByTen = makeIncrementor(forIncrement: 10)
</span><span class='line'>
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 10
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 20
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 30</span></code></pre></td></tr></table></div></figure>


<p>If you create another incrementor, it will have its own stored reference to a new, separate runningTotal variable</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let incrementBySeven = makeIncrementor(forIncrement: 7)
</span><span class='line'>incrementBySeven()
</span><span class='line'>// returns a value of 7
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 40</span></code></pre></td></tr></table></div></figure>


<p>incrementByTen捕获的变量与incrementBySeven捕获的无关</p>

<h5>Closure是引用类型</h5>

<p>也就是说如果你将closure赋给两个不同的常量或变量，这两个常量或变量将指向一样的closure</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let alsoIncrementByTen = incrementByTen
</span><span class='line'>alsoIncrementByTen()
</span><span class='line'>// returns a value of 50</span></code></pre></td></tr></table></div></figure>


<h4>Enumerations</h4>

<p>Enumerations in Swift are first-class types in their own right. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial member value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</p>

<h5>Enumeration Syntax</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum CompassPoint {
</span><span class='line'>    case North
</span><span class='line'>    case South
</span><span class='line'>    case East
</span><span class='line'>    case West
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<pre><code>    Unlike C and Objective-C, Swift enumeration members are not assigned a default integer value when they are created. In the CompassPoints example above, North, South, East and West do not implicitly equal 0, 1, 2 and 3. Instead, the different enumeration members are fully-fledged values in their own right, with an explicitly-defined type of CompassPoint.
</code></pre>

<p>多个成员值可以出现在同一行上，用<code>,</code>分开</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Planet {
</span><span class='line'>    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看以下例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var directionToHead = CompassPoint.West
</span><span class='line'>directionToHead = .East</span></code></pre></td></tr></table></div></figure>


<p>一旦知道了directionToHead的类型，它的type(CompassPoint)可以省略</p>

<h5>Switch..case</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>directionToHead = .South
</span><span class='line'>switch directionToHead {
</span><span class='line'>case .North:
</span><span class='line'>    println("Lots of planets have a north")
</span><span class='line'>case .South:
</span><span class='line'>    println("Watch out for penguins")
</span><span class='line'>case .East:
</span><span class='line'>    println("Where the sun rises")
</span><span class='line'>case .West:
</span><span class='line'>    println("Where the skies are blue")
</span><span class='line'>}
</span><span class='line'>// prints "Watch out for penguins</span></code></pre></td></tr></table></div></figure>


<h5>Associated Values</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Barcode {
</span><span class='line'>    case UPCA(Int, Int, Int)
</span><span class='line'>    case QRCode(String)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var productBarcode = Barcode.UPCA(8, 85909_51226, 3)
</span><span class='line'>productBarcode = .QRCode("ABCDEFGHIJKLMNOP")
</span><span class='line'>
</span><span class='line'>switch productBarcode {
</span><span class='line'>case .UPCA(let numberSystem, let identifier, let check):
</span><span class='line'>    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
</span><span class='line'>case .QRCode(let productCode):
</span><span class='line'>    println("QR code with value of \(productCode).")
</span><span class='line'>}
</span><span class='line'>// prints "QR code with value of ABCDEFGHIJKLMNOP.”</span></code></pre></td></tr></table></div></figure>


<p>If all of the associated values for a enumeration member are extracted as constants, or if all are extracted as variables, you can place a single var or let annotation before the member name, for brevity:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>switch productBarcode {
</span><span class='line'>case let .UPCA(numberSystem, identifier, check):
</span><span class='line'>    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
</span><span class='line'>case let .QRCode(productCode):
</span><span class='line'>    println("QR code with value of \(productCode).")
</span><span class='line'>}
</span><span class='line'>// prints "QR code with value of ABCDEFGHIJKLMNOP.”</span></code></pre></td></tr></table></div></figure>


<h5>Raw Values</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum ASCIIControlCharacter: Character {
</span><span class='line'>    case Tab = "\t"
</span><span class='line'>    case LineFeed = "\n"
</span><span class='line'>    case CarriageReturn = "\r"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The raw value for a particular enumeration member is always the same. Associated values are set when you create a new constant or variable based on one of the enumeration’s members, and can be different each time you do so.
注意，如果整型被用来作为raw values,如果其他enumeration member无值，则其他的将会自动增长</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Planet: Int {
</span><span class='line'>    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>.venus = 2,&hellip;依此类推
用toRaw方法来获取一个enumeration member的rawValue值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let earthsOrder = Planet.Earth.toRaw()
</span><span class='line'>// earthsOrder is 3</span></code></pre></td></tr></table></div></figure>


<p>用fromRaw来获取拥有一个raw value的enumberation member</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let possiblePlanet = Planet.fromRaw(7)</span></code></pre></td></tr></table></div></figure>


<p>注意fromRaw返回的是optional value,所以可以像如下这个写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let positionToFind = 9
</span><span class='line'>if let somePlanet = Planet.fromRaw(positionToFind) {
</span><span class='line'>    switch somePlanet {
</span><span class='line'>    case .Earth:
</span><span class='line'>        println("Mostly harmless")
</span><span class='line'>    default:
</span><span class='line'>        println("Not a safe place for humans")
</span><span class='line'>    }
</span><span class='line'>} else {
</span><span class='line'>    println("There isn't a planet at position \(positionToFind)")
</span><span class='line'>}
</span><span class='line'>// prints "There isn't a planet at position 9”</span></code></pre></td></tr></table></div></figure>


<h4>Classes和Structures</h4>

<p>Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures. In Swift, you define a class or a structure in a single file, and the external interface to that class or structure is automatically made available for other code to use.</p>

<h5>二者的比较</h5>

<p>共同之处</p>

<ul>
<li>Define properties to store values</li>
<li>Define methods to provide functionality</li>
<li>Define subscripts to provide access to their values using subscript syntax</li>
<li>Define initializers to set up their initial state</li>
<li>Be extended to expand their functionality beyond a default implementation</li>
<li><p>Conform to protocols to provide standard functionality of a certain kind
类有的，而Structure木有的</p></li>
<li><p>Inheritance enables one class to inherit the characteristics of another.</p></li>
<li>Type casting enables you to check and interpret the type of a class instance at runtime.</li>
<li>Deinitializers enable an instance of a class to free up any resources it has assigned.</li>
<li>Reference counting allows more than one reference to a class instance.
<code>注意</code>Structures总是被copies的而不用引用计数

<h5>语法定义</h5></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Resolution {
</span><span class='line'>    var width = 0
</span><span class='line'>    var height = 0
</span><span class='line'>}
</span><span class='line'>class VideoMode {
</span><span class='line'>    var resolution = Resolution()
</span><span class='line'>    var interlaced = false
</span><span class='line'>    var frameRate = 0.0
</span><span class='line'>    var name: String?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Class and Structures Instances</h5>

<p>创建对象实例</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someResolution = Resolution()
</span><span class='line'>let someVideoMode = VideoMode()</span></code></pre></td></tr></table></div></figure>


<h5>访问属性</h5>

<p>可以层层访问，注意以下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The width of someVideoMode is \(someVideoMode.resolution.width)")
</span><span class='line'>// prints "The width of someVideoMode is 0”</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>
Unlike Objective-C, Swift enables you to set sub-properties of a structure property directly. In the last example above, the width property of the resolution property of someVideoMode is set directly, without your needing to set the entire resolution property to a new value.</p>

<h5>Memberwise Initializers for Structure Types</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vga = Resolution(width: 640, height: 480)</span></code></pre></td></tr></table></div></figure>


<p>不过不像structures,类的对象初始化时没有这样默认的成员初始化</p>

<h4>Structus和Enumerations是值类型</h4>

<p>也就是说当它赋给一个变量或专给函数时，它们是copy的
实际上,Swift中的所有基本类型，整型，浮点型，bool型，string，array和dictionary都是值类型，不过幕后都以structure的形式呈现
demo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum CompassPoint {
</span><span class='line'>    case North, South, East, West
</span><span class='line'>}
</span><span class='line'>var currentDirection = CompassPoint.West
</span><span class='line'>let rememberedDirection = currentDirection
</span><span class='line'>currentDirection = .East
</span><span class='line'>if rememberedDirection == .West {
</span><span class='line'>    println("The remembered direction is still .West")
</span><span class='line'>}
</span><span class='line'>// prints "The remembered direction is still .West”</span></code></pre></td></tr></table></div></figure>


<h4>类是引用类型</h4>

<p>我们可以判断两个变量是否指向同一个类的对象
可以用<code>===</code></p>

<h4>选择类或是Structure</h4>

<p>structure总是按值传递，class总是按引用传递</p>

<h4>Assignment and Copy Behavior for Collection Types</h4>

<ul>
<li>Assignment and Copy Behavior for Dictionaries
当你将一个dictionary赋予一个常量或变量，或者将它传入函数时,dictionary就被copied了
如果keys/values是值类型,它们也在赋值或作为参数传入函数时也被copy了，不过如果它们是引用类型的话，只是引用copy了，对象并未被copy，这种copy规则与一个structure的properties一样，如果structure被copy的话</li>
<li>Assignment and Copy Behavior for Arrays
array的copy规则与dictionary的大大不同!array的copy只发生在你所做的修改会改变array的大小的时候</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var a = [1, 2, 3]
</span><span class='line'>var b = a
</span><span class='line'>var c = a
</span><span class='line'>
</span><span class='line'>a[0] = 42
</span><span class='line'>println(a[0])
</span><span class='line'>// 42
</span><span class='line'>println(b[0])
</span><span class='line'>// 42
</span><span class='line'>println(c[0])
</span><span class='line'>// 42
</span><span class='line'>
</span><span class='line'>a.append(4)
</span><span class='line'>a[0] = 777
</span><span class='line'>println(a[0])
</span><span class='line'>// 777
</span><span class='line'>println(b[0])
</span><span class='line'>// 42
</span><span class='line'>println(c[0])
</span><span class='line'>// 42</span></code></pre></td></tr></table></div></figure>


<h4>确保array是唯一的</h4>

<p>通过对一个array的变量调用unshare方法，你能确保这个这个变量对这个array的唯一性，也就是说如果有多个变量指向同一个array,如果你对其中的某一个变量调用unshare方法，这个array就被copy了,所以这个变量有此array的独立拷贝,不过如果只有一个变量指向此array,则copy不会发生
在以上的例子中,假设我们调用了如下语句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b.unshare()</span></code></pre></td></tr></table></div></figure>


<p>则结果如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b[0] = -105
</span><span class='line'>println(a[0])
</span><span class='line'>// 777
</span><span class='line'>println(b[0])
</span><span class='line'>// -105
</span><span class='line'>println(c[0])
</span><span class='line'>// 42</span></code></pre></td></tr></table></div></figure>


<h5>Checking Whether Two Arrays Share the Same Elements</h5>

<p>Check whether two arrays or subarrays share the same storage and elements by comparing them with the identity operators (=== and !==).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if b === c {
</span><span class='line'>    println("b and c still share the same array elements.")
</span><span class='line'>} else {
</span><span class='line'>    println("b and c now refer to two independent sets of array elements.")
</span><span class='line'>}
</span><span class='line'>// prints "b and c now refer to two independent sets of array elements.</span></code></pre></td></tr></table></div></figure>


<p>Alternatively, use the identity operators to check whether two subarrays share the same elements. The example below compares two identical subarrays from b and confirms that they refer to the same elements:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if b[0...1] === b[0...1] {
</span><span class='line'>    println("These two subarrays share the same elements.")
</span><span class='line'>} else {
</span><span class='line'>    println("These two subarrays do not share the same elements.")
</span><span class='line'>}
</span><span class='line'>// prints "These two subarrays share the same elements.”</span></code></pre></td></tr></table></div></figure>


<h5>强制array的copy</h5>

<p>调用array的copy方法,这个方法只是对array进行<code>浅复制</code></p>

<h4>Properties</h4>

<p>Properties associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.</p>

<p>Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties.</p>

<p>In addition, you can define property observers to monitor changes in a property’s value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</p>

<h5>Stored Properties</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct FixedLengthRange {
</span><span class='line'>    var firstValue: Int
</span><span class='line'>    let length: Int
</span><span class='line'>}
</span><span class='line'>var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
</span><span class='line'>// the range represents integer values 0, 1, and 2
</span><span class='line'>rangeOfThreeItems.firstValue = 6
</span><span class='line'>// the range now represents integer values 6, 7, and 8</span></code></pre></td></tr></table></div></figure>


<h5>Stored Properties of Constant Structure Instances</h5>

<p>如果你创建了一个structure的instance，并且将这个instance赋予一个常量,你不能通过这个常量修改这个instance的properties,即使它们被声明为variable properties</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
</span><span class='line'>// this range represents integer values 0, 1, 2, and 3
</span><span class='line'>rangeOfFourItems.firstValue = 6
</span><span class='line'>// this will report an error, even thought firstValue is a variable property</span></code></pre></td></tr></table></div></figure>


<p>这是因为structure是值类型的缘故,如果一个值类型的instance被标记为常量，则它的property也是
不过class与此不同，class照样可修改instance的variable properties，既然它被赋值为一个常量</p>

<h5>Lazy Stored Properties</h5>

<p>A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the @lazy attribute before its declaration.</p>

<p><code>注意</code>
You must always declare a lazy property as a variable (with the var keyword), because its initial value may not be retrieved until after instance initialization completes. Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.</p>

<p>Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance’s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.</p>

<p>The example below uses a lazy stored property to avoid unnecessary initialization of a complex class. This example defines two classes called DataImporter and DataManager, neither of which is shown in full:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class DataImporter {
</span><span class='line'>    /*
</span><span class='line'>    DataImporter is a class to import data from an external file.
</span><span class='line'>    The class is assumed to take a non-trivial amount of time to initialize.
</span><span class='line'>    */
</span><span class='line'>    var fileName = "data.txt"
</span><span class='line'>    // the DataImporter class would provide data importing functionality here
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class DataManager {
</span><span class='line'>    @lazy var importer = DataImporter()
</span><span class='line'>    var data = String[]()
</span><span class='line'>    // the DataManager class would provide data management functionality here
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>let manager = DataManager()
</span><span class='line'>manager.data += "Some data"
</span><span class='line'>manager.data += "Some more data"
</span><span class='line'>// the DataImporter instance for the importer property has not yet been created</span></code></pre></td></tr></table></div></figure>


<p>只有在importer的property首次被访问的时候，importer才被创建</p>

<h4>Computed Properties</h4>

<p>主要用来计算，而非存储，主要提供了一个getter和一个可选的setter</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>struct Rect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    var center: Point {
</span><span class='line'>    get {
</span><span class='line'>        let centerX = origin.x + (size.width / 2)
</span><span class='line'>        let centerY = origin.y + (size.height / 2)
</span><span class='line'>        return Point(x: centerX, y: centerY)
</span><span class='line'>    }
</span><span class='line'>    set(newCenter) {
</span><span class='line'>        origin.x = newCenter.x - (size.width / 2)
</span><span class='line'>        origin.y = newCenter.y - (size.height / 2)
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var square = Rect(origin: Point(x: 0.0, y: 0.0),
</span><span class='line'>    size: Size(width: 10.0, height: 10.0))
</span><span class='line'>let initialSquareCenter = square.center
</span><span class='line'>square.center = Point(x: 15.0, y: 15.0)
</span><span class='line'>println("square.origin is now at (\(square.origin.x), \(square.origin.y))")
</span><span class='line'>// prints "square.origin is now at (10.0, 10.0)</span></code></pre></td></tr></table></div></figure>


<h5>Shorthand Setter Declaration</h5>

<p>如果一个computed property的setter并不为新值定义一个名字,则新值的默认名为newValue</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct AlternativeRect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    var center: Point {
</span><span class='line'>    get {
</span><span class='line'>        let centerX = origin.x + (size.width / 2)
</span><span class='line'>        let centerY = origin.y + (size.height / 2)
</span><span class='line'>        return Point(x: centerX, y: centerY)
</span><span class='line'>    }
</span><span class='line'>    set {
</span><span class='line'>        origin.x = newValue.x - (size.width / 2)
</span><span class='line'>        origin.y = newValue.y - (size.height / 2)
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>只读的Computed Properties
一个computed property如果只有一个getter，而没有setter，则它被称为read-only computed property,它只能返回一个值(通过.)而不能赋值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Cuboid {
</span><span class='line'>    var width = 0.0, height = 0.0, depth = 0.0
</span><span class='line'>    var volume: Double {
</span><span class='line'>    return width * height * depth
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
</span><span class='line'>println("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
</span><span class='line'>// prints "the volume of fourByFiveByTwo is 40.0”</span></code></pre></td></tr></table></div></figure>


<p> <code>注意</code>你必须用var来声明computed properties(即使是只读的也一样),let只用于constant properties</p>

<p> #####Property Observer
Property observers observe and respond to changes in a property’s value. Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</p>

<p>You can add property observers to any stored properties you define, apart from lazy stored properties. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass</p>

<p><code>注意</code>
You don’t need to define property observers for non-overridden computed properties, because you can observe and respond to changes to their value from directly within the computed property’s setter.</p>

<p>you have the option to define either or both of these observers on a property:</p>

<ul>
<li>willSet is called just before the value is stored.</li>
<li>didSet is called immediately after the new value is stored.</li>
</ul>


<p>If you implement a willSet observer, it is passed the new property value as a constant parameter. You can specify a name for this parameter as part of your willSet implementation. If you choose not to write the parameter name and parentheses within your implementation, the parameter will still be made available with a default parameter name of newValue.</p>

<p>Similarly, if you implement a didSet observer, it will be passed a constant parameter containing the old property value. You can name the parameter if you wish, or use the default parameter name of oldValue.</p>

<p><code>注意</code>
willSet and didSet observers are not called when a property is first initialized. They are only called when the property’s value is set outside of an initialization context.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class StepCounter {
</span><span class='line'>    var totalSteps: Int = 0 {
</span><span class='line'>    willSet(newTotalSteps) {
</span><span class='line'>        println("About to set totalSteps to \(newTotalSteps)")
</span><span class='line'>    }
</span><span class='line'>    didSet {
</span><span class='line'>        if totalSteps &gt; oldValue  {
</span><span class='line'>            println("Added \(totalSteps - oldValue) steps")
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let stepCounter = StepCounter()
</span><span class='line'>stepCounter.totalSteps = 200
</span><span class='line'>// About to set totalSteps to 200
</span><span class='line'>// Added 200 steps
</span><span class='line'>stepCounter.totalSteps = 360
</span><span class='line'>// About to set totalSteps to 360
</span><span class='line'>// Added 160 steps
</span><span class='line'>stepCounter.totalSteps = 896
</span><span class='line'>// About to set totalSteps to 896
</span><span class='line'>// Added 536 steps</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>
If you assign a value to a property within its own didSet observer, the new value that you assign will replace the one that was just set</p>

<h4>全局和局部变量</h4>

<p>The capabilities described above for computing and observing properties are also available to global variables and local variables.</p>

<p>The global and local variables you have encountered in previous chapters have all been stored variables. Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.</p>

<p>However, you can also define computed variables and define observers for stored variables, in either a global or local scope. Computed variables calculate rather than store a value, and are written in the same way as computed properties.</p>

<p><code>注意</code>
Global constants and variables are always computed lazily, in a similar manner to Lazy Stored Properties. Unlike lazy stored properties, global constants and variables do not need to be marked with the @lazy attribute.</p>

<p>Local constants and variables are never computed lazily.</p>

<h4>Type Properties</h4>

<p>For value types (that is, structures and enumerations), you can define stored and computed type properties. For classes, you can define computed type properties only.</p>

<p>Stored type properties for value types can be variables or constants. Computed type properties are always declared as variable properties, in the same way as
computed instance properties.</p>

<p><code>注意</code>
Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>

<h5>Type property语法</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct SomeStructure {
</span><span class='line'>    static var storedTypeProperty = "Some value."
</span><span class='line'>    static var computedTypeProperty: Int {
</span><span class='line'>    // return an Int value here
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>enum SomeEnumeration {
</span><span class='line'>    static var storedTypeProperty = "Some value."
</span><span class='line'>    static var computedTypeProperty: Int {
</span><span class='line'>    // return an Int value here
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>class SomeClass {
</span><span class='line'>    class var computedTypeProperty: Int {
</span><span class='line'>    // return an Int value here
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Querying and Setting Type Properties</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println(SomeClass.computedTypeProperty)
</span><span class='line'>// prints "42"
</span><span class='line'> 
</span><span class='line'>println(SomeStructure.storedTypeProperty)
</span><span class='line'>// prints "Some value."
</span><span class='line'>SomeStructure.storedTypeProperty = "Another value."
</span><span class='line'>println(SomeStructure.storedTypeProperty)
</span><span class='line'>// prints "Another value."</span></code></pre></td></tr></table></div></figure>


<p>再来看一个例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct AudioChannel {
</span><span class='line'>    static let thresholdLevel = 10
</span><span class='line'>    static var maxInputLevelForAllChannels = 0
</span><span class='line'>    var currentLevel: Int = 0 {
</span><span class='line'>    didSet {
</span><span class='line'>        if currentLevel &gt; AudioChannel.thresholdLevel {
</span><span class='line'>            // cap the new audio level to the threshold level
</span><span class='line'>            currentLevel = AudioChannel.thresholdLevel
</span><span class='line'>        }
</span><span class='line'>        if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels {
</span><span class='line'>            // store this as the new overall maximum input level
</span><span class='line'>            AudioChannel.maxInputLevelForAllChannels = currentLevel
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>
In the first of these two checks, the didSet observer sets currentLevel to a different value. This does not, however, cause the observer to be called again.</p>

<h4>方法</h4>

<p>与C不同,Swift中的Structure和enumerations能定义方法</p>

<h5>Instance Methods</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Counter {
</span><span class='line'>    var count = 0
</span><span class='line'>    func increment() {
</span><span class='line'>        count++
</span><span class='line'>    }
</span><span class='line'>    func incrementBy(amount: Int) {
</span><span class='line'>        count += amount
</span><span class='line'>    }
</span><span class='line'>    func reset() {
</span><span class='line'>        count = 0
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let counter = Counter()
</span><span class='line'>// the initial counter value is 0
</span><span class='line'>counter.increment()
</span><span class='line'>// the counter's value is now 1
</span><span class='line'>counter.incrementBy(5)
</span><span class='line'>// the counter's value is now 6
</span><span class='line'>counter.reset()
</span><span class='line'>// the counter's value is now 0</span></code></pre></td></tr></table></div></figure>


<h5>Local and External Parameter Names for Methods</h5>

<p>Function parameters can have both a local name (for use within the function’s body) and an external name (for use when calling the function)</p>

<p>The same is true for method parameters, because methods are just functions that are associated with a type. However, the default behavior of local names and external names is <code>different</code> for functions and methods.</p>

<p>Specifically, Swift gives the first parameter name in a method a local parameter name by default, and gives the second and subsequent parameter names both local and external parameter names by default.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Counter {
</span><span class='line'>    var count: Int = 0
</span><span class='line'>    func incrementBy(amount: Int, numberOfTimes: Int) {
</span><span class='line'>        count += amount * numberOfTimes
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let counter = Counter()
</span><span class='line'>counter.incrementBy(5, numberOfTimes: 3)
</span><span class='line'>// counter value is now 15</span></code></pre></td></tr></table></div></figure>


<p>This default behavior effectively treats the method as if you had written a hash symbol (#) before the numberOfTimes parameter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func incrementBy(amount: Int, #numberOfTimes: Int) {
</span><span class='line'>    count += amount * numberOfTimes
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Modifying External Parameter Name Behavior for Methods</h5>

<p>Sometimes it’s useful to provide an external parameter name for a method’s first parameter, even though this is not the default behavior. You can either add an explicit external name yourself, or you can prefix the first parameter’s name with a hash symbol to use the local name as an external name too.</p>

<p>Conversely, if you do not want to provide an external name for the second or subsequent parameter of a method, override the default behavior by using an underscore character (_) as an explicit external parameter name for that parameter.</p>

<h5>The self Property</h5>

<p>以上的可以改成以下的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func increment() {
</span><span class='line'>    self.count++
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method.</p>

<p>The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance. In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way. You use the implicit self property to distinguish between the parameter name and the property name.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    func isToTheRightOfX(x: Double) -&gt; Bool {
</span><span class='line'>        return self.x &gt; x
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let somePoint = Point(x: 4.0, y: 5.0)
</span><span class='line'>if somePoint.isToTheRightOfX(1.0) {
</span><span class='line'>    println("This point is to the right of the line where x == 1.0")
</span><span class='line'>}
</span><span class='line'>// prints "This point is to the right of the line where x == 1.0”</span></code></pre></td></tr></table></div></figure>


<h4>Modifying Value Types from Within Instance Methods</h4>

<p>Structures 和 enumerations都是值类型,值类型的属性是不能在它的instance方法里修改的,不过你可以在方法名前加mutating来对property进行修改</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>        x += deltaX
</span><span class='line'>        y += deltaY
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var somePoint = Point(x: 1.0, y: 1.0)
</span><span class='line'>somePoint.moveByX(2.0, y: 3.0)
</span><span class='line'>println("The point is now at (\(somePoint.x), \(somePoint.y))")
</span><span class='line'>// prints "The point is now at (3.0, 4.0)”</span></code></pre></td></tr></table></div></figure>


<p>The method can also assign a completely new instance to its implicit self property, and this new instance will replace the existing one when the method ends.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>        self = Point(x: x + deltaX, y: y + deltaY)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Mutating methods for enumerations can set the implicit self parameter to be a different member from the same enumeration:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum TriStateSwitch {
</span><span class='line'>    case Off, Low, High
</span><span class='line'>    mutating func next() {
</span><span class='line'>        switch self {
</span><span class='line'>        case Off:
</span><span class='line'>            self = Low
</span><span class='line'>        case Low:
</span><span class='line'>            self = High
</span><span class='line'>        case High:
</span><span class='line'>            self = Off
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var ovenLight = TriStateSwitch.Low
</span><span class='line'>ovenLight.next()
</span><span class='line'>// ovenLight is now equal to .High
</span><span class='line'>ovenLight.next()
</span><span class='line'>// ovenLight is now equal to .Off</span></code></pre></td></tr></table></div></figure>


<h4>Type Methods</h4>

<p> 对class,在方法的func关键字前加class,对structure和enumeration,在func前加static</p>

<p>  <code>注意</code>:In Objective-C, you can define type-level methods only for Objective-C classes. In Swift, you can define type-level methods for all classes, structures, and enumerations. Each type method is explicitly scoped to the type it supports.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//对类而言
</span><span class='line'>class SomeClass {
</span><span class='line'>    class func someTypeMethod() {
</span><span class='line'>        // type method implementation goes here
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>SomeClass.someTypeMethod()
</span><span class='line'>//对structure和enumeration而言
</span></code></pre></td></tr></table></div></figure>


<p>在一个type方法的方法体里,self指的是type本身</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct LevelTracker {
</span><span class='line'>    static var highestUnlockedLevel = 1
</span><span class='line'>    static func unlockLevel(level: Int) {
</span><span class='line'>        if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
</span><span class='line'>    }
</span><span class='line'>    static func levelIsUnlocked(level: Int) -&gt; Bool {
</span><span class='line'>        return level &lt;= highestUnlockedLevel
</span><span class='line'>    }
</span><span class='line'>    var currentLevel = 1
</span><span class='line'>    mutating func advanceToLevel(level: Int) -&gt; Bool {
</span><span class='line'>        if LevelTracker.levelIsUnlocked(level) {
</span><span class='line'>            currentLevel = level
</span><span class='line'>            return true
</span><span class='line'>        } else {
</span><span class='line'>            return false
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>与Player类的结合使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Player {
</span><span class='line'>    var tracker = LevelTracker()
</span><span class='line'>    let playerName: String
</span><span class='line'>    func completedLevel(level: Int) {
</span><span class='line'>        LevelTracker.unlockLevel(level + 1)
</span><span class='line'>        tracker.advanceToLevel(level + 1)
</span><span class='line'>    }
</span><span class='line'>    init(name: String) {
</span><span class='line'>        playerName = name
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Subscripts</h4>

<p>You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript. Subscripts are not limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom type’s needs.</p>

<h5>Subscript Syntax</h5>

<p>不像其他的instance方法,subscripts可以是读写的或是只读的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subscript(index: Int) -&gt; Int {
</span><span class='line'>    get {
</span><span class='line'>        // return an appropriate subscript value here
</span><span class='line'>    }
</span><span class='line'>    set(newValue) {
</span><span class='line'>        // perform a suitable setting action here
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于只读的computed property,对只读的subscripts,我们可以去掉get关键字</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subscript(index: Int) -&gt; Int {
</span><span class='line'>    // return an appropriate subscript value here
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct TimesTable {
</span><span class='line'>    let multiplier: Int
</span><span class='line'>    subscript(index: Int) -&gt; Int {
</span><span class='line'>        return multiplier * index
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let threeTimesTable = TimesTable(multiplier: 3)
</span><span class='line'>println("six times three is \(threeTimesTable[6])")
</span><span class='line'>// prints "six times three is 18”</span></code></pre></td></tr></table></div></figure>


<h5>Subscript Options</h5>

<p>Subscripts能接收任意数量的参数，并且这些参数可以是任意类型的
Subscripts能接收variable 参数 和 variadic 参数,但不能使用in-out参数或是为参数提供默认值</p>

<p>A class or structure can provide as many subscript implementations as it needs, and the appropriate subscript to be used will be inferred based on the types of the value or values that are contained within the subscript braces at the point that the subscript is used. This definition of multiple subscripts is known as subscript overloading.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Matrix {
</span><span class='line'>    let rows: Int, columns: Int
</span><span class='line'>    var grid: Double[]
</span><span class='line'>    init(rows: Int, columns: Int) {
</span><span class='line'>        self.rows = rows
</span><span class='line'>        self.columns = columns
</span><span class='line'>        grid = Array(count: rows * columns, repeatedValue: 0.0)
</span><span class='line'>    }
</span><span class='line'>    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
</span><span class='line'>        return row &gt;= 0 && row &lt; rows && column &gt;= 0 && column &lt; columns
</span><span class='line'>    }
</span><span class='line'>    subscript(row: Int, column: Int) -&gt; Double {
</span><span class='line'>        get {
</span><span class='line'>            assert(indexIsValidForRow(row, column: column), "Index out of range")
</span><span class='line'>            return grid[(row * columns) + column]
</span><span class='line'>        }
</span><span class='line'>        set {
</span><span class='line'>            assert(indexIsValidForRow(row, column: column), "Index out of range")
</span><span class='line'>            grid[(row * columns) + column] = newValue
</span><span class='line'>        }
</span><span class='line'>     }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var matrix = Matrix(rows: 2, columns: 2)
</span><span class='line'>
</span><span class='line'>matrix[0, 1] = 1.5
</span><span class='line'>matrix[1, 0] = 3.2
</span><span class='line'>
</span><span class='line'>let someValue = matrix[2, 2]
</span><span class='line'>// this triggers an assert, because [2, 2] is outside of the matrix bounds
</span></code></pre></td></tr></table></div></figure>


<h4>继承</h4>

<p>只有类能继承
Classes can also add property observers to inherited properties in order to be notified when the value of a property changes. Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Vehicle {
</span><span class='line'>    var numberOfWheels: Int
</span><span class='line'>    var maxPassengers: Int
</span><span class='line'>    func description() -&gt; String {
</span><span class='line'>        return "\(numberOfWheels) wheels; up to \(maxPassengers) passengers"
</span><span class='line'>    }
</span><span class='line'>    init() {
</span><span class='line'>        numberOfWheels = 0
</span><span class='line'>        maxPassengers = 1
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let someVehicle = Vehicle()
</span></code></pre></td></tr></table></div></figure>


<h5>Subclassing</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Bicycle: Vehicle {
</span><span class='line'>    init() {
</span><span class='line'>        super.init()
</span><span class='line'>        numberOfWheels = 2
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let bicycle = Bicycle()
</span><span class='line'>println("Bicycle: \(bicycle.description())")
</span><span class='line'>// Bicycle: 2 wheels; up to 1 passengers</span></code></pre></td></tr></table></div></figure>


<p>The Bicycle class also defines an initializer to set up its tailored characteristics. The initializer for Bicycle calls super.init(), the initializer for the Bicycle class’s superclass, Vehicle, and ensures that all of the inherited properties are initialized by Vehicle before Bicycle tries to modify them.</p>

<p><code>注意</code>:initializers are not inherited by default in Swift</p>

<h4>Overriding</h4>

<p>A subclass can provide its own custom implementation of an instance method, class method, instance property, or subscript that it would otherwise inherit from a superclass. This is known as overriding.
子类重写父类的方法必须加override</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Car: Vehicle {
</span><span class='line'>    var speed: Double = 0.0
</span><span class='line'>    init() {
</span><span class='line'>        super.init()
</span><span class='line'>        maxPassengers = 5
</span><span class='line'>        numberOfWheels = 4
</span><span class='line'>    }
</span><span class='line'>    override func description() -&gt; String {
</span><span class='line'>        return super.description() + "; "
</span><span class='line'>            + "traveling at \(speed) mph"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let car = Car()
</span><span class='line'>println("Car: \(car.description())")
</span><span class='line'>// Car: 4 wheels; up to 5 passengers; traveling at 0.0 mph</span></code></pre></td></tr></table></div></figure>


<h5>Overriding Properties</h5>

<p>You can override an inherited instance or class property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes</p>

<p>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.</p>

<p>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.</p>

<p><code>注意</code>
If you provide a setter as part of a property override, you must also provide a getter for that override. If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning super.someProperty from the getter, as in the SpeedLimitedCar example below.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SpeedLimitedCar: Car {
</span><span class='line'>    override var speed: Double  {
</span><span class='line'>    get {
</span><span class='line'>        return super.speed
</span><span class='line'>    }
</span><span class='line'>    set {
</span><span class='line'>        super.speed = min(newValue, 40.0)
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let limitedCar = SpeedLimitedCar()
</span><span class='line'>limitedCar.speed = 60.0
</span><span class='line'>println("SpeedLimitedCar: \(limitedCar.description())")
</span><span class='line'>// SpeedLimitedCar: 4 wheels; up to 5 passengers; traveling at 40.0 mph</span></code></pre></td></tr></table></div></figure>


<h5>Overriding Property Observers</h5>

<p>You can use property overriding to add property observers to an inherited property. This enables you to be notified when the value of the inherited property changes, regardless of how that property was originally implemented</p>

<p><code>注意</code></p>

<p>You cannot add property observers to inherited constant stored properties or inherited read-only computed properties. The value of these properties cannot be set, and so it is not appropriate to provide a willSet or didSet implementation as part of an override.</p>

<p>Note also that you cannot provide both an overriding setter and an overriding property observer. If you want to observe changes to a property’s value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class AutomaticCar: Car {
</span><span class='line'>    var gear = 1
</span><span class='line'>    override var speed: Double {
</span><span class='line'>    didSet {
</span><span class='line'>        gear = Int(speed / 10.0) + 1
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>    override func description() -&gt; String {
</span><span class='line'>        return super.description() + " in gear \(gear)"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let automatic = AutomaticCar()
</span><span class='line'>automatic.speed = 35.0
</span><span class='line'>println("AutomaticCar: \(automatic.description())")
</span><span class='line'>// AutomaticCar: 4 wheels; up to 5 passengers; traveling at 35.0 mph in gear 4</span></code></pre></td></tr></table></div></figure>


<h5>Preventing Overrides</h5>

<p>我们可以在方法，属性或subscript前加@final来阻止它们被继承</p>

<p>Methods, properties or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.</p>

<p>你也可以用@final来阻止类被继承</p>

<h4>初始化</h4>

<h5>Setting Initial Values for Stored Properties</h5>

<p>Classes and structures must set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties cannot be left in an indeterminate state.</p>

<p>我们可以在initializer内为一个stored property设置一个初始值,或在它的定义中为其指定一个默认值
Stored properties cannot be left in an indeterminate state.</p>

<p><code>注意</code>
When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers.</p>

<h5>Initializers</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Fahrenheit {
</span><span class='line'>    var temperature: Double
</span><span class='line'>    init() {
</span><span class='line'>        temperature = 32.0
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var f = Fahrenheit()
</span><span class='line'>println("The default temperature is \(f.temperature)° Fahrenheit")
</span><span class='line'>// prints "The default temperature is 32.0° Fahrenheit"</span></code></pre></td></tr></table></div></figure>


<h5>Default Property Values</h5>

<p><code>注意</code>
If a property always takes the same initial value, provide a default value rather than setting a value within an initializer. The end result is the same, but the default value ties the property’s initialization more closely to its declaration. It makes for shorter, clearer initializers and <code>enables you to infer the type of the property from its default value</code>. The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.</p>

<p>之前的demo可以换成以下形式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Fahrenheit {
</span><span class='line'>    var temperature = 32.0
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Customizing Initialization</h5>

<p>You can customize the initialization process with input parameters and optional property types,or by modifying constant properties during initialization</p>

<ul>
<li>Initialization Parameters
You can provide initialization parameters as part of an initializer’s definition, to define the types and names of values that customize the initialization process.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Celsius {
</span><span class='line'>    var temperatureInCelsius: Double = 0.0
</span><span class='line'>    init(fromFahrenheit fahrenheit: Double) {
</span><span class='line'>        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
</span><span class='line'>    }
</span><span class='line'>    init(fromKelvin kelvin: Double) {
</span><span class='line'>        temperatureInCelsius = kelvin - 273.15
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
</span><span class='line'>// boilingPointOfWater.temperatureInCelsius is 100.0
</span><span class='line'>let freezingPointOfWater = Celsius(fromKelvin: 273.15)
</span><span class='line'>// freezingPointOfWater.temperatureInCelsius is 0.0</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Local and External Parameter Names
As with function and method parameters, initialization parameters can have both a local name for use within the initializer’s body and an external name for use when calling the initializer.</li>
</ul>


<p>However, initializers do not have an identifying function name before their parentheses in the way that functions and methods do. Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called. Because of this,<code>Swift provides an automatic external name for every parameter in an initializer if you don’t provide an external name yourself</code>.</p>

<p><code>注意</code>
If you do not want to provide an external name for a parameter in an initializer, provide an underscore (_) as an explicit external name for that parameter to override the default behavior described above.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Color {
</span><span class='line'>    let red = 0.0, green = 0.0, blue = 0.0
</span><span class='line'>    init(red: Double, green: Double, blue: Double) {
</span><span class='line'>        self.red   = red
</span><span class='line'>        self.green = green
</span><span class='line'>        self.blue  = blue
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>
It is not possible to call this initializer without using the external names. External names must always be used in an intializer if they are defined, and omitting them is a compile-time error:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let veryGreen = Color(0.0, 1.0, 0.0)
</span><span class='line'>// this reports a compile-time error - external names are required</span></code></pre></td></tr></table></div></figure>


<h5>Optional Property Types</h5>

<p>Properties of optional type are automatically initialized with a value of nil, indicating that the property is deliberately intended to have “no value yet” during initialization.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SurveyQuestion {
</span><span class='line'>    var text: String
</span><span class='line'>    var response: String?
</span><span class='line'>    init(text: String) {
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    func ask() {
</span><span class='line'>        println(text)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
</span><span class='line'>cheeseQuestion.ask()
</span><span class='line'>// prints "Do you like cheese?"
</span><span class='line'>cheeseQuestion.response = "Yes, I do like cheese.”</span></code></pre></td></tr></table></div></figure>


<h5>Modifying Constant Properties During Initialization</h5>

<p>You can modify the value of a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes.</p>

<p><code>注意</code>
For class instances, a constant property can only be modified during initialization by the class that introduces it. It cannot be modified by a subclass.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SurveyQuestion {
</span><span class='line'>    let text: String
</span><span class='line'>    var response: String?
</span><span class='line'>    init(text: String) {
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    func ask() {
</span><span class='line'>        println(text)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let beetsQuestion = SurveyQuestion(text: "How about beets?")
</span><span class='line'>beetsQuestion.ask()
</span><span class='line'>// prints "How about beets?"
</span><span class='line'>beetsQuestion.response = "I also like beets. (But not with cheese.)”</span></code></pre></td></tr></table></div></figure>


<h5>Default Initializers</h5>

<p>Swift provides a default initializer for any structure or base class that provides default values for all of its properties and does not provide at least one initializer itself. The default initializer simply creates a new instance with all of its properties set to their default values.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ShoppingListItem {
</span><span class='line'>    var name: String?
</span><span class='line'>    var quantity = 1
</span><span class='line'>    var purchased = false
</span><span class='line'>}
</span><span class='line'>var item = ShoppingListItem()</span></code></pre></td></tr></table></div></figure>


<h5>Memberwise Initializers for Structure Types</h5>

<p>In addition to the default initializers mentioned above, structure types automatically receive a memberwise initializer if they provide default values for all of their stored properties and do not define any of their own custom initializers.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>let twoByTwo = Size(width: 2.0, height: 2.0)</span></code></pre></td></tr></table></div></figure>


<h5>Initializer Delegation for Value Types</h5>

<p>Initializers can call other initializers to perform part of an instance’s initialization. This process, known as initializer delegation, avoids duplicating code across multiple initializers.</p>

<p>对于值类型而言,它们的initializer delegation相对比较简单,because they can only delegate to another initializer that they provide themselves.
而类则可以继承,This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization.</p>

<p>For value types, you use self.init to refer to other initializers from the same value type when writing your own custom initializers. You can only call self.init from within an initializer.</p>

<p>Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise structure initializer, if it is a structure) for that type.</p>

<p><code>注意</code>
If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct Rect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    init() {}
</span><span class='line'>    init(origin: Point, size: Size) {
</span><span class='line'>        self.origin = origin
</span><span class='line'>        self.size = size
</span><span class='line'>    }
</span><span class='line'>    init(center: Point, size: Size) {
</span><span class='line'>        let originX = center.x - (size.width / 2)
</span><span class='line'>        let originY = center.y - (size.height / 2)
</span><span class='line'>        self.init(origin: Point(x: originX, y: originY), size: size)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let basicRect = Rect()
</span><span class='line'>// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)
</span><span class='line'>
</span><span class='line'>let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
</span><span class='line'>    size: Size(width: 5.0, height: 5.0))
</span><span class='line'>// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)
</span><span class='line'>
</span><span class='line'>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
</span><span class='line'>    size: Size(width: 3.0, height: 3.0))
</span><span class='line'>// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></code></pre></td></tr></table></div></figure>


<p>The init(center:size:) initializer could have assigned the new values of origin and size to the appropriate properties itself. However, it is more convenient (and clearer in intent) for the init(center:size:) initializer to take advantage of an existing initializer that already provides exactly that functionality.</p>

<h4>类继承和初始化</h4>

<p>All of a class’s stored properties—including any properties the class inherits from its superclass—must be assigned an initial value during initialization.</p>

<p>Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value. These are known as designated initializers and convenience initializers</p>

<h5>Designated Initializers and Convenience Initializers</h5>

<p>Designated initializers are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</p>

<p>Classes tend to have very few designated initializers, and it is quite common for a class to have only one. Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain.</p>

<p>Every class must have at least one designated initializer. In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass</p>

<p>Convenience initializers are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</p>

<p>You do not have to provide convenience initializers if your class does not require them. Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent</p>

<h5>Initializer Chaining</h5>

<p>To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:</p>

<ul>
<li>规则1
Designated initializers must call a designated initializer from their immediate superclass.</li>
<li>规则2
Convenience initializers must call another initializer available in the same class.</li>
<li>规则3
Convenience initializers must ultimately end up calling a designated initializer.</li>
</ul>


<p>A simple way to remember this is:</p>

<ul>
<li>Designated initializers must always delegate up.</li>
<li>Convenience initializers must always delegate across.
关系可以用以下两张图表示
<img src="http://xiekunRonaldo.github.io/images/2014/8/initialize.png">
<img src="http://xiekunRonaldo.github.io/images/2014/8/complex_initialize.png"></li>
</ul>


<h5>Two-Phase Initialization</h5>

<p>Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</p>

<p>Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly.</p>

<p>Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:</p>

<ul>
<li><p>Safety check 1
A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.</p></li>
<li><p>Safety check 2
A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</p></li>
<li>Safety check 3
A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class). If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.</li>
<li>Safety check 4
An initializer cannot call any instance methods, read the values of any instance properties, or refer to self as a value until after the first phase of initialization is complete.</li>
</ul>


<p>The class instance is not fully valid until the first phase ends. Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.</p>

<p>Here’s how two-phase initialization plays out, based on the four safety checks above:</p>

<ol>
<li>Phase 1

<ul>
<li>A designated or convenience initializer is called on a class.</li>
<li>Memory for a new instance of that class is allocated. The memory is not yet initialized.</li>
<li>A designated initializer for that class confirms that all stored properties introduced by that class have a value. The memory for these stored properties is now initialized.</li>
<li>The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.</li>
<li>This continues up the class inheritance chain until the top of the chain is reached.</li>
<li>Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete.</li>
</ul>
</li>
<li>Phase 2

<ul>
<li>Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access self and can modify its properties, call its instance methods, and so on.</li>
<li>Finally, any convenience initializers in the chain have the option to customize the instance and to work with self.

<h4>Initializer Inheritance and Overriding</h4>

<p>Unlike subclasses in Objective-C, Swift subclasses do not not inherit their superclass initializers by default.</p></li>
</ul>
</li>
</ol>


<p>If you want your custom subclass to present one or more of the same initializers as its superclass—perhaps to perform some customization during initialization—you can provide an overriding implementation of the same initializer within your custom subclass.</p>

<p>If the initializer you are overriding is a designated initializer, you can override its implementation in your subclass and call the superclass version of the initializer from within your overriding version.</p>

<p>If the initializer you are overriding is a convenience initializer, your override must call another designated initializer from its own subclass</p>

<p><code>注意</code></p>

<pre><code>Unlike methods, properties, and subscripts, you do not need to write the override keyword when overriding an initializer.
</code></pre>

<h5>Automatic Initializer Inheritance</h5>

<p>Subclasses do not not inherit their superclass initializers by default. However, superclass initializers are automatically inherited if certain conditions are met. In practice, this means that you do not need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it is safe to do so.</p>

<p>Assuming that you provide default values for <code>any</code> new properties you introduce in a subclass, the following two rules apply:</p>

<ul>
<li><p>Rule 1</p>

<p>  If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.</p></li>
<li><p>Rule 2</p>

<p>  If your subclass provides an implementation of <code>all</code> of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.</p></li>
</ul>


<p>These rules apply even if your subclass adds further convenience initializers.</p>

<p><code>注意</code></p>

<pre><code>A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.
</code></pre>

<h5>Syntax for Designated and Convenience Initializers</h5>

<ul>
<li>Designated initializers</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init(parameters) {
</span><span class='line'>  statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Convenience initializers</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>convenience init(parameters) {
</span><span class='line'>    statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Designated and Convenience Initializers in Action</h5>

<p>以下显示了designated initializers, convenience initializers, and automatic initializer inheritance in action,定义了三个类Food,RecipeIngredient,ShoppingListItem的继承关系</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//Food
</span><span class='line'>class Food {
</span><span class='line'>    var name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>    convenience init() {
</span><span class='line'>        self.init(name: "[Unnamed]")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//Designated initializer
</span><span class='line'>let namedMeat = Food(name: "Bacon")
</span><span class='line'>// namedMeat's name is "Bacon”
</span><span class='line'>
</span><span class='line'>let mysteryMeat = Food()</span></code></pre></td></tr></table></div></figure>


<p>Food的initializer chain图</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/8/initialize.png"></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RecipeIngredient: Food {
</span><span class='line'>    var quantity: Int
</span><span class='line'>    init(name: String, quantity: Int) {
</span><span class='line'>        self.quantity = quantity
</span><span class='line'>        super.init(name: name)
</span><span class='line'>    }
</span><span class='line'>    convenience init(name: String) {
</span><span class='line'>        self.init(name: name, quantity: 1)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let oneMysteryItem = RecipeIngredient()
</span><span class='line'>let oneBacon = RecipeIngredient(name: "Bacon")
</span><span class='line'>let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)
</span></code></pre></td></tr></table></div></figure>


<p>图示如下</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/8/recipeIngredient.png"></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ShoppingListItem: RecipeIngredient {
</span><span class='line'>    var purchased = false
</span><span class='line'>    var description: String {
</span><span class='line'>    var output = "\(quantity) x \(name.lowercaseString)"
</span><span class='line'>        output += purchased ? " ✔" : " ✘"
</span><span class='line'>        return output
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>以上三个类的继承图</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/8/foodchaining.png">
You can use all three of the inherited initializers to create a new ShoppingListItem instance:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>“var breakfastList = [
</span><span class='line'>    ShoppingListItem(),
</span><span class='line'>    ShoppingListItem(name: "Bacon"),
</span><span class='line'>    ShoppingListItem(name: "Eggs", quantity: 6),
</span><span class='line'>]
</span><span class='line'>breakfastList[0].name = "Orange juice"
</span><span class='line'>breakfastList[0].purchased = true
</span><span class='line'>for item in breakfastList {
</span><span class='line'>    println(item.description)
</span><span class='line'>}
</span><span class='line'>// 1 x orange juice ✔
</span><span class='line'>// 1 x bacon ✘
</span><span class='line'>// 6 x eggs ✘”</span></code></pre></td></tr></table></div></figure>


<h5>用closure或是函数来设置一个默认值</h5>

<p>If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property，Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeClass {
</span><span class='line'>    let someProperty: SomeType = {
</span><span class='line'>        // create a default value for someProperty inside this closure
</span><span class='line'>        // someValue must be of the same type as SomeType
</span><span class='line'>        return someValue
</span><span class='line'>        }()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Note that the closure’s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately</p>

<p><code>注意</code></p>

<pre><code>If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed. This means that you cannot access any other property values from within your closure, even if those properties have default values. You also cannot use the implicit self property, or call any of the instance’s methods.
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Checkerboard {
</span><span class='line'>    let boardColors: Bool[] = {
</span><span class='line'>        var temporaryBoard = Bool[]()
</span><span class='line'>        var isBlack = false
</span><span class='line'>        for i in 1...10 {
</span><span class='line'>            for j in 1...10 {
</span><span class='line'>                temporaryBoard.append(isBlack)
</span><span class='line'>                isBlack = !isBlack
</span><span class='line'>            }
</span><span class='line'>            isBlack = !isBlack
</span><span class='line'>        }
</span><span class='line'>        return temporaryBoard
</span><span class='line'>        }()
</span><span class='line'>    func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
</span><span class='line'>        return boardColors[(row * 10) + column]
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let board = Checkerboard()
</span><span class='line'>println(board.squareIsBlackAtRow(0, column: 1))
</span><span class='line'>// prints "true"
</span><span class='line'>println(board.squareIsBlackAtRow(9, column: 9))
</span><span class='line'>// prints "false”</span></code></pre></td></tr></table></div></figure>


<h4>Deinitialization</h4>

<p>A deinitializer is called immediately before a class instance is deallocated. You write deinitializers with the <code>deinit</code> keyword, similar to how intializers are written with the init keyword. <code>Deinitializers are only available on class types</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>deinit {
</span><span class='line'>    // perform the deinitialization
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看一个demo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Bank {
</span><span class='line'>    static var coinsInBank = 10_000
</span><span class='line'>    static func vendCoins(var numberOfCoinsToVend: Int) -&gt; Int {
</span><span class='line'>        numberOfCoinsToVend = min(numberOfCoinsToVend, coinsInBank)
</span><span class='line'>        coinsInBank -= numberOfCoinsToVend
</span><span class='line'>        return numberOfCoinsToVend
</span><span class='line'>    }
</span><span class='line'>    static func receiveCoins(coins: Int) {
</span><span class='line'>        coinsInBank += coins
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Player {
</span><span class='line'>    var coinsInPurse: Int
</span><span class='line'>    init(coins: Int) {
</span><span class='line'>        coinsInPurse = Bank.vendCoins(coins)
</span><span class='line'>    }
</span><span class='line'>    func winCoins(coins: Int) {
</span><span class='line'>        coinsInPurse += Bank.vendCoins(coins)
</span><span class='line'>    }
</span><span class='line'>    deinit {
</span><span class='line'>        Bank.receiveCoins(coinsInPurse)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var playerOne: Player? = Player(coins: 100)
</span><span class='line'>println("A new player has joined the game with \(playerOne!.coinsInPurse) coins")
</span><span class='line'>// prints "A new player has joined the game with 100 coins"
</span><span class='line'>println("There are now \(Bank.coinsInBank) coins left in the bank")
</span><span class='line'>// prints "There are now 9900 coins left in the bank”
</span><span class='line'>
</span><span class='line'>playerOne!.winCoins(2_000)
</span><span class='line'>println("PlayerOne won 2000 coins & now has \(playerOne!.coinsInPurse) coins")
</span><span class='line'>// prints "PlayerOne won 2000 coins & now has 2100 coins"
</span><span class='line'>println("The bank now only has \(Bank.coinsInBank) coins left")
</span><span class='line'>// prints "The bank now only has 7900 coins left”
</span><span class='line'>
</span><span class='line'>playerOne = nil
</span><span class='line'>println("PlayerOne has left the game")
</span><span class='line'>// prints "PlayerOne has left the game"
</span><span class='line'>println("The bank now has \(Bank.coinsInBank) coins")
</span><span class='line'>// prints "The bank now has 10000 coins”</span></code></pre></td></tr></table></div></figure>


<h4>ARC</h4>

<p>Swift也用arc,不过，需要注意的是arc只适用于类对象,不适用于Structure和enumeration这类值类型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        println("\(name) is being initialized")
</span><span class='line'>    }
</span><span class='line'>    deinit {
</span><span class='line'>        println("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>reference1 = Person(name: "John Appleseed")
</span><span class='line'>// prints "John Appleseed is being initialized"
</span><span class='line'>
</span><span class='line'>reference2 = reference1
</span><span class='line'>reference3 = reference1
</span><span class='line'>reference1 = nil
</span><span class='line'>reference2 = nil
</span><span class='line'>
</span><span class='line'>reference3 = nil
</span><span class='line'>// prints "John Appleseed is being deinitialized”
</span></code></pre></td></tr></table></div></figure>


<p>类对象之间的循环引用
You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references
我们来看看循环引用是如何造成的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>    var apartment: Apartment?
</span><span class='line'>    deinit { println("\(name) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class Apartment {
</span><span class='line'>    let number: Int
</span><span class='line'>    init(number: Int) { self.number = number }
</span><span class='line'>    var tenant: Person?
</span><span class='line'>    deinit { println("Apartment #\(number) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var john: Person?
</span><span class='line'>var number73: Apartment?
</span><span class='line'>
</span><span class='line'>john = Person(name: "John Appleseed")
</span><span class='line'>number73 = Apartment(number: 73)
</span><span class='line'>
</span><span class='line'>john!.apartment = number73
</span><span class='line'>number73!.tenant = john
</span></code></pre></td></tr></table></div></figure>


<p>现在我们来看看 cycle retain图</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/8/cycleretain.png"></p>

<h4>如何解决</h4>

<p>Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.</p>

<p>Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization.</p>

<ul>
<li>Weak References</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>    var apartment: Apartment?
</span><span class='line'>    deinit { println("\(name) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class Apartment {
</span><span class='line'>    let number: Int
</span><span class='line'>    init(number: Int) { self.number = number }
</span><span class='line'>    weak var tenant: Person?
</span><span class='line'>    deinit { println("Apartment #\(number) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var john: Person?
</span><span class='line'>var number73: Apartment?
</span><span class='line'> 
</span><span class='line'>john = Person(name: "John Appleseed")
</span><span class='line'>number73 = Apartment(number: 73)
</span><span class='line'> 
</span><span class='line'>john!.apartment = number73
</span><span class='line'>number73!.tenant = john
</span></code></pre></td></tr></table></div></figure>


<p>我们来看看引用图</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/8/weakref.png"></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = nil
</span><span class='line'>// prints "John Appleseed is being deinitialized”
</span><span class='line'>number73 = nil
</span><span class='line'>// prints "Apartment #73 is being deinitialized”
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Unowned References
Unlike a weak reference, an unowned reference is assumed to always have a value, Because of this, an unowned reference is always defined as a non-optional type.</li>
</ul>


<p>ARC cannot set the reference to nil when the instance it refers to is deallocated, <code>because variables of a non-optional type cannot be set to nil.</code></p>

<p>来看一个例子，这个例子中，我们定义了两个类,Customer和CreditCard,与之前不同，CreditCard肯定对应着一个Customer,故用unowned</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Customer {
</span><span class='line'>    let name: String
</span><span class='line'>    var card: CreditCard?
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>    deinit { println("\(name) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class CreditCard {
</span><span class='line'>    let number: Int
</span><span class='line'>    unowned let customer: Customer
</span><span class='line'>    init(number: Int, customer: Customer) {
</span><span class='line'>        self.number = number
</span><span class='line'>        self.customer = customer
</span><span class='line'>    }
</span><span class='line'>    deinit { println("Card #\(number) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var john: Customer?
</span><span class='line'>john = Customer(name: "John Appleseed")
</span><span class='line'>john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://xiekunRonaldo.github.io/images/2014/8/unowned.png"></p>

<h5>Unowned References and Implicitly Unwrapped Optional Properties</h5>

<p>in two classes ,both properties should always have a value, and neither property should ever be nil once initialization is complete. In this scenario, it is useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</p>

<p>This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle. This section shows you how to set up such a relationship.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Country {
</span><span class='line'>    let name: String
</span><span class='line'>    let capitalCity: City!
</span><span class='line'>    init(name: String, capitalName: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.capitalCity = City(name: capitalName, country: self)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class City {
</span><span class='line'>    let name: String
</span><span class='line'>    unowned let country: Country
</span><span class='line'>    init(name: String, country: Country) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.country = country
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The initializer for City is called from within the initializer for Country. However, the initializer for Country cannot pass self to the City initializer until a new Country instance is fully initialized, as described in Two-Phase Initialization.</p>

<p>To cope with this requirement, you declare the capitalCity property of Country as an implicitly unwrapped optional property, indicated by the exclamation mark at the end of its type annotation (City!). This means that the capitalCity property has a default value of nil, like any other optional, but can be accessed without the need to unwrap its value as described in Implicitly Unwrapped Optionals.</p>

<p>Because capitalCity has a default nil value, a new Country instance is considered fully initialized as soon as the Country instance sets its name property within its initializer</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var country = Country(name: "Canada", capitalName: "Ottawa")
</span><span class='line'>println("\(country.name)'s capital city is called \(country.capitalCity.name)")
</span><span class='line'>// prints "Canada's capital city is called Ottawa”</span></code></pre></td></tr></table></div></figure>


<h5>Strong Reference Cycles for Closures</h5>

<p>closure有可能导致循环引用，因为closure也是引用类型,Swift提供了一个叫做<code>closure capture list</code>的方式来解决此类问题
我们先看看closure引用的循环引用是如何产生的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HTMLElement {
</span><span class='line'>    
</span><span class='line'>    let name: String
</span><span class='line'>    let text: String?
</span><span class='line'>    
</span><span class='line'>    @lazy var asHTML: () -&gt; String = {
</span><span class='line'>        if let text = self.text {
</span><span class='line'>            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>        } else {
</span><span class='line'>            return "&lt;\(self.name) /&gt;"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(name: String, text: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        println("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>println(paragraph!.asHTML())
</span><span class='line'>// prints "&lt;p&gt;hello, world&lt;/p&gt;"</span></code></pre></td></tr></table></div></figure>


<p>The asHTML property is named and used somewhat like an instance method. However, because asHTML is a closure property rather than an instance method, you can replace the default value of the asHTML property with a custom closure, if you want to change the HTML rendering for a particular HTML element.</p>

<p><code>注意</code></p>

<pre><code>The asHTML property is declared as a lazy property, because it is only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that asHTML is a lazy property means that you can refer to self within the default closure, because the lazy property will not be accessed until after initialization has been completed and self is known to exist.

Even though the closure refers to self multiple times, it only captures one strong reference to the HTMLElement instance.
</code></pre>

<h5>解决closure导致的引用循环</h5>

<p>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition</p>

<p>A capture list defines the rules to use when capturing one or more reference types within the closure’s body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference</p>

<p><code>注意</code></p>

<pre><code>Swift requires you to write self.someProperty or self.someMethod (rather than just someProperty or someMethod) whenever you refer to a member of self within a closure. This helps you remember that it’s possible to capture self by accident.
</code></pre>

<h5>定义一个Cature List</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@lazy var someClosure: (Int, String) -&gt; String = {
</span><span class='line'>    [unowned self] (index: Int, stringToProcess: String) -&gt; String in
</span><span class='line'>    // closure body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果closure不指定参数列表或返回型(因为它们能从上下文中推测出,则可用以下形式代替</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@lazy var someClosure: () -&gt; String = {
</span><span class='line'>    [unowned self] in
</span><span class='line'>    // closure body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Weak and Unowned References</h5>

<p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>

<p>Weak references are <code>always</code> of an <code>optional type</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HTMLElement {
</span><span class='line'>    
</span><span class='line'>    let name: String
</span><span class='line'>    let text: String?
</span><span class='line'>    
</span><span class='line'>    @lazy var asHTML: () -&gt; String = {
</span><span class='line'>        [unowned self] in
</span><span class='line'>        if let text = self.text {
</span><span class='line'>            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>        } else {
</span><span class='line'>            return "&lt;\(self.name) /&gt;"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(name: String, text: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        println("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>println(paragraph!.asHTML())
</span><span class='line'>// prints "&lt;p&gt;hello, world&lt;/p&gt;”</span></code></pre></td></tr></table></div></figure>


<p><img src="http://xiekunRonaldo.github.io/images/2014/8/unownedblock.png"></p>

<h5>Optional Chaining</h5>

<p>If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil. Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.</p>

<p><code>注意</code></p>

<pre><code>Optional chaining in Swift is similar to messaging nil in Objective-C, but in a way that works for any type, and that can be checked for success or failure.
</code></pre>

<h5>Optional Chaining as an Alternative to Forced Unwrapping</h5>

<p>To reflect the fact that optional chaining can be called on a nil value, the result of an optional chaining call is always an optional value,even if the property, method, or subscript you are querying returns a non-optional value</p>

<p>Specifically, the result of an optional chaining call is of the same type as the expected return value, but wrapped in an optional,A property that normally returns an Int will return an Int? when accessed through optional chaining.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    var residence: Residence?
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class Residence {
</span><span class='line'>    var numberOfRooms = 1
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let john = Person()
</span><span class='line'>
</span><span class='line'>let roomCount = john.residence!.numberOfRooms
</span><span class='line'>// this triggers a runtime error
</span><span class='line'>
</span><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    println("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// prints "Unable to retrieve the number of rooms.”
</span><span class='line'>
</span><span class='line'>john.residence = Residence()
</span><span class='line'>
</span><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    println("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// prints "John's residence has 1 room(s).”</span></code></pre></td></tr></table></div></figure>


<h5>Defining Model Classes for Optional Chaining</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    var residence: Residence?
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Residence {
</span><span class='line'>    var rooms = Room[]()
</span><span class='line'>    var numberOfRooms: Int {
</span><span class='line'>    return rooms.count
</span><span class='line'>    }
</span><span class='line'>    subscript(i: Int) -&gt; Room {
</span><span class='line'>        return rooms[i]
</span><span class='line'>    }
</span><span class='line'>    func printNumberOfRooms() {
</span><span class='line'>        println("The number of rooms is \(numberOfRooms)")
</span><span class='line'>    }
</span><span class='line'>    var address: Address?
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Room {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Address {
</span><span class='line'>    var buildingName: String?
</span><span class='line'>    var buildingNumber: String?
</span><span class='line'>    var street: String?
</span><span class='line'>    func buildingIdentifier() -&gt; String? {
</span><span class='line'>        if buildingName {
</span><span class='line'>            return buildingName
</span><span class='line'>        } else if buildingNumber {
</span><span class='line'>            return buildingNumber
</span><span class='line'>        } else {
</span><span class='line'>            return nil
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h5>Calling Properties Through Optional Chaining</h5>

<p>you can use optional chaining to access a property on an optional value, and to check if that property access is successful. You cannot, however, set a property’s value through optional chaining.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let john = Person()
</span><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    println("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// prints "Unable to retrieve the number of rooms.”</span></code></pre></td></tr></table></div></figure>


<h5>Calling Methods Through Optional Chaining</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if john.residence?.printNumberOfRooms() {
</span><span class='line'>    println("It was possible to print the number of rooms.")
</span><span class='line'>} else {
</span><span class='line'>    println("It was not possible to print the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// prints "It was not possible to print the number of rooms.”</span></code></pre></td></tr></table></div></figure>


<h5>Calling Subscripts Through Optional Chaining</h5>

<p><code>注意</code></p>

<p>When you access a subscript on an optional value through optional chaining, you place the question mark before the subscript’s braces, not after. The optional chaining question mark always follows immediately after the part of the expression that is optional.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let firstRoomName = john.residence?[0].name {
</span><span class='line'>    println("The first room name is \(firstRoomName).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the first room name.")
</span><span class='line'>}
</span><span class='line'>// prints "Unable to retrieve the first room name.”
</span><span class='line'>
</span><span class='line'>let johnsHouse = Residence()
</span><span class='line'>johnsHouse.rooms += Room(name: "Living Room")
</span><span class='line'>johnsHouse.rooms += Room(name: "Kitchen")
</span><span class='line'>john.residence = johnsHouse
</span><span class='line'> 
</span><span class='line'>if let firstRoomName = john.residence?[0].name {
</span><span class='line'>    println("The first room name is \(firstRoomName).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the first room name.")
</span><span class='line'>}
</span><span class='line'>// prints "The first room name is Living Room."</span></code></pre></td></tr></table></div></figure>


<h5>Linking Multiple Levels of Chaining</h5>

<p>multiple levels of optional chaining do not add more levels of optionality to the returned value.</p>

<p>也就是说</p>

<ul>
<li>If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.</li>
<li>If the type you are trying to retrieve is already optional, it will not become more optional because of the chaining.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let johnsStreet = john.residence?.address?.street {
</span><span class='line'>    println("John's street name is \(johnsStreet).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the address.")
</span><span class='line'>}
</span><span class='line'>// prints "Unable to retrieve the address."
</span><span class='line'>
</span><span class='line'>let johnsAddress = Address()
</span><span class='line'>johnsAddress.buildingName = "The Larches"
</span><span class='line'>johnsAddress.street = "Laurel Street"
</span><span class='line'>john.residence!.address = johnsAddress
</span><span class='line'> 
</span><span class='line'>if let johnsStreet = john.residence?.address?.street {
</span><span class='line'>    println("John's street name is \(johnsStreet).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the address.")
</span><span class='line'>}
</span><span class='line'>// prints "John's street name is Laurel Street.”</span></code></pre></td></tr></table></div></figure>


<h5>Chaining on Methods With Optional Return Values</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
</span><span class='line'>    println("John's building identifier is \(buildingIdentifier).")
</span><span class='line'>}
</span><span class='line'>// prints "John's building identifier is The Larches.”
</span><span class='line'>
</span><span class='line'>if let upper = john.residence?.address?.buildingIdentifier()?.uppercaseString {
</span><span class='line'>    println("John's uppercase building identifier is \(upper).")
</span><span class='line'>}
</span><span class='line'>// prints "John's uppercase building identifier is THE LARCHES."</span></code></pre></td></tr></table></div></figure>


<h4>Type Casting</h4>

<p>Type casting is a way to check the type of an instance, and/or to treat that instance as if it is a different superclass or subclass from somewhere else in its own class hierarchy.</p>

<p>Type casting in Swift is implemented with the <code>is</code> and <code>as</code> operators.</p>

<p>You can also use type casting to check whether a type conforms to a protocol</p>

<h5>Defining a Class Hierarchy for Type Casting</h5>

<p>Defining a Class Hierarchy for Type Casting</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class MediaItem {
</span><span class='line'>    var name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Movie: MediaItem {
</span><span class='line'>    var director: String
</span><span class='line'>    init(name: String, director: String) {
</span><span class='line'>        self.director = director
</span><span class='line'>        super.init(name: name)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class Song: MediaItem {
</span><span class='line'>    var artist: String
</span><span class='line'>    init(name: String, artist: String) {
</span><span class='line'>        self.artist = artist
</span><span class='line'>        super.init(name: name)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let library = [
</span><span class='line'>    Movie(name: "Casablanca", director: "Michael Curtiz"),
</span><span class='line'>    Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
</span><span class='line'>    Movie(name: "Citizen Kane", director: "Orson Welles"),
</span><span class='line'>    Song(name: "The One And Only", artist: "Chesney Hawkes"),
</span><span class='line'>    Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
</span><span class='line'>]
</span><span class='line'>// the type of "library" is inferred to be MediaItem[]”
</span></code></pre></td></tr></table></div></figure>


<h5>Checking Type</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var movieCount = 0
</span><span class='line'>var songCount = 0
</span><span class='line'> 
</span><span class='line'>for item in library {
</span><span class='line'>    if item is Movie {
</span><span class='line'>        ++movieCount
</span><span class='line'>    } else if item is Song {
</span><span class='line'>        ++songCount
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>println("Media library contains \(movieCount) movies and \(songCount) songs")
</span><span class='line'>// prints "Media library contains 2 movies and 3 songs”</span></code></pre></td></tr></table></div></figure>


<h5>Downcasting</h5>

<p>Because downcasting can fail, the type cast operator comes in two different forms. The optional form, as?, returns an optional value of the type you are trying to downcast to. The forced form, as, attempts the downcast and force-unwraps the result as a single compound action.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for item in library {
</span><span class='line'>    if let movie = item as? Movie {
</span><span class='line'>        println("Movie: '\(movie.name)', dir. \(movie.director)")
</span><span class='line'>    } else if let song = item as? Song {
</span><span class='line'>        println("Song: '\(song.name)', by \(song.artist)")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// Movie: 'Casablanca', dir. Michael Curtiz
</span><span class='line'>// Song: 'Blue Suede Shoes', by Elvis Presley
</span><span class='line'>// Movie: 'Citizen Kane', dir. Orson Welles
</span><span class='line'>// Song: 'The One And Only', by Chesney Hawkes
</span><span class='line'>// Song: 'Never Gonna Give You Up', by Rick Astley”</span></code></pre></td></tr></table></div></figure>


<h4>Type Casting for Any and AnyObject</h4>

<p>Swift provides two special type aliases for working with non-specific types:</p>

<ul>
<li>AnyObject can represent an instance of any class type.</li>
<li>Any can represent an instance of any type at all, apart from function types.</li>
</ul>


<p><code>注意</code></p>

<p>Use Any and AnyObject only when you explicitly need the behavior and capabilities they provide. It is always better to be specific about the types you expect to work with in your code.</p>

<h5>AnyObject</h5>

<p>When working with Cocoa APIs, it is common to receive an array with a type of AnyObject[], or “an array of values of any object type”. This is because Objective-C does not have explicitly typed arrays</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someObjects: AnyObject[] = [
</span><span class='line'>    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
</span><span class='line'>    Movie(name: "Moon", director: "Duncan Jones"),
</span><span class='line'>    Movie(name: "Alien", director: "Ridley Scott")
</span><span class='line'>]
</span><span class='line'>
</span><span class='line'>for object in someObjects {
</span><span class='line'>    let movie = object as Movie
</span><span class='line'>    println("Movie: '\(movie.name)', dir. \(movie.director)")
</span><span class='line'>}
</span><span class='line'>// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
</span><span class='line'>// Movie: 'Moon', dir. Duncan Jones
</span><span class='line'>// Movie: 'Alien', dir. Ridley Scott”
</span><span class='line'>
</span><span class='line'>//或者 
</span><span class='line'>
</span><span class='line'>for movie in someObjects as Movie[] {
</span><span class='line'>    println("Movie: '\(movie.name)', dir. \(movie.director)")
</span><span class='line'>}
</span><span class='line'>// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
</span><span class='line'>// Movie: 'Moon', dir. Duncan Jones
</span><span class='line'>// Movie: 'Alien', dir. Ridley Scott”</span></code></pre></td></tr></table></div></figure>


<h5>Any</h5>

<p>Here’s an example of using Any to work with a mix of different types, including non-class types</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var things = Any[]()
</span><span class='line'> 
</span><span class='line'>things.append(0)
</span><span class='line'>things.append(0.0)
</span><span class='line'>things.append(42)
</span><span class='line'>things.append(3.14159)
</span><span class='line'>things.append("hello")
</span><span class='line'>things.append((3.0, 5.0))
</span><span class='line'>things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))</span></code></pre></td></tr></table></div></figure>


<p>You can use the is and as operators in a switch statement’s cases to discover the specific type of a constant or variable that is known <code>only</code> to be of type <code>Any</code> or <code>AnyObject</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for thing in things {
</span><span class='line'>    switch thing {
</span><span class='line'>    case 0 as Int:
</span><span class='line'>        println("zero as an Int")
</span><span class='line'>    case 0 as Double:
</span><span class='line'>        println("zero as a Double")
</span><span class='line'>    case let someInt as Int:
</span><span class='line'>        println("an integer value of \(someInt)")
</span><span class='line'>    case let someDouble as Double where someDouble &gt; 0:
</span><span class='line'>        println("a positive double value of \(someDouble)")
</span><span class='line'>    case is Double:
</span><span class='line'>        println("some other double value that I don't want to print")
</span><span class='line'>    case let someString as String:
</span><span class='line'>        println("a string value of \"\(someString)\"")
</span><span class='line'>    case let (x, y) as (Double, Double):
</span><span class='line'>    
</span><span class='line'>println("an (x, y) point at \(x), \(y)")
</span><span class='line'>    case let movie as Movie:
</span><span class='line'>        println("a movie called '\(movie.name)', dir. \(movie.director)")
</span><span class='line'>    default:
</span><span class='line'>        println("something else")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// zero as an Int
</span><span class='line'>// zero as a Double
</span><span class='line'>// an integer value of 42
</span><span class='line'>// a positive double value of 3.14159
</span><span class='line'>// a string value of "hello"
</span><span class='line'>// an (x, y) point at 3.0, 5.0
</span><span class='line'>// a movie called 'Ghostbusters', dir. Ivan Reitman</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<pre><code>The cases of a switch statement use the forced version of the type cast operator (as, not as?) to check and cast to a specific type. This check is always safe within the context of a switch case statement.
</code></pre>

<h5>Nested Types</h5>

<p>Nest supporting enumerations, classes, and structures within the definition of the type they support.</p>

<p>To nest a type within another type, write its definition within the outer braces of the type it supports. Types can be nested to <code>as many levels as are required</code>.</p>

<h5>Nested Types in Action</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct BlackjackCard {
</span><span class='line'>// nested Suit enumeration
</span><span class='line'>    enum Suit: Character {
</span><span class='line'>        case Spades = "♠", Hearts = "♡", Diamonds = "♢", Clubs = "♣"
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // nested Rank enumeration
</span><span class='line'>    enum Rank: Int {
</span><span class='line'>        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
</span><span class='line'>        case Jack, Queen, King, Ace
</span><span class='line'>        struct Values {
</span><span class='line'>            let first: Int, second: Int?
</span><span class='line'>        }
</span><span class='line'>        var values: Values {
</span><span class='line'>        switch self {
</span><span class='line'>        case .Ace:
</span><span class='line'>            return Values(first: 1, second: 11)
</span><span class='line'>        case .Jack, .Queen, .King:
</span><span class='line'>            return Values(first: 10, second: nil)
</span><span class='line'>        default:
</span><span class='line'>            return Values(first: self.toRaw(), second: nil)
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>  }
</span><span class='line'>    
</span><span class='line'>    // BlackjackCard properties and methods
</span><span class='line'>    let rank: Rank, suit: Suit
</span><span class='line'>    var description: String {
</span><span class='line'>    var output = "suit is \(suit.toRaw()),"
</span><span class='line'>        output += " value is \(rank.values.first)"
</span><span class='line'>        if let second = rank.values.second {
</span><span class='line'>            output += " or \(second)"
</span><span class='line'>        }
</span><span class='line'>        return output
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
</span><span class='line'>println("theAceOfSpades: \(theAceOfSpades.description)")
</span><span class='line'>// prints "theAceOfSpades: suit is ♠, value is 1 or 11”</span></code></pre></td></tr></table></div></figure>


<p>Even though Rank and Suit are nested within BlackjackCard, their type can be inferred from context,“\and so the initialization of this instance is able to refer to the enumeration members by their member names (.Ace and .Spades) alone.</p>

<h5>Referring to Nested Types</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let heartsSymbol = BlackjackCard.Suit.Hearts.toRaw()
</span><span class='line'>// heartsSymbol is "♡”</span></code></pre></td></tr></table></div></figure>


<h4>Extensions</h4>

<p>Extensions add new functionality to an existing class, structure, or enumeration type,类似OC中的类别,Unlike Objective-C categories, Swift extensions do not have names
Swift中的Extensions能做以下事情</p>

<ul>
<li>添加computed properties和computed static properties</li>
<li>定义instance methods和type methods</li>
<li>提供新的initializers</li>
<li>定义subscripts</li>
<li>定义并使用nested types</li>
<li>让一个已存在的type遵循某个协议</li>
</ul>


<p><code>注意</code></p>

<pre><code>If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.
</code></pre>

<h5>语法</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SomeType {
</span><span class='line'>    // new functionality to add to SomeType goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>An extension can extend an existing type to make it adopt one or more protocols.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SomeType: SomeProtocol, AnotherProtocol {
</span><span class='line'>    // implementation of protocol requirements goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Computed Properties</h5>

<p>Extensions can add computed instance properties and computed type properties to existing types</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Double {
</span><span class='line'>    var km: Double { return self * 1_000.0 }
</span><span class='line'>    var m: Double { return self }
</span><span class='line'>    var cm: Double { return self / 100.0 }
</span><span class='line'>    var mm: Double { return self / 1_000.0 }
</span><span class='line'>    var ft: Double { return self / 3.28084 }
</span><span class='line'>}
</span><span class='line'>let oneInch = 25.4.mm
</span><span class='line'>println("One inch is \(oneInch) meters")
</span><span class='line'>// prints "One inch is 0.0254 meters"
</span><span class='line'>let threeFeet = 3.ft
</span><span class='line'>println("Three feet is \(threeFeet) meters")
</span><span class='line'>// prints "Three feet is 0.914399970739201 meters”
</span><span class='line'>
</span><span class='line'>let aMarathon = 42.km + 195.m
</span><span class='line'>println("A marathon is \(aMarathon) meters long")
</span><span class='line'>// prints "A marathon is 42195.0 meters long”</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<pre><code>Extensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.
</code></pre>

<h5>Initializers</h5>

<p>Extensions can add new initializers to existing types. This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the type’s original implementation.</p>

<p><code>Extensions can add new convenience initializers to a class, but they cannot add new designated initializers or deinitializers to a class</code>. Designated initializers and deinitializers must always be provided by the original class implementation.</p>

<p><code>注意</code></p>

<pre><code>If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and does not define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extension’s initializer.

This would not be the case if you had written the initializer as part of the value type’s original implementation
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}
</span><span class='line'>struct Rect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let defaultRect = Rect()
</span><span class='line'>let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
</span><span class='line'>    size: Size(width: 5.0, height: 5.0))
</span><span class='line'>    
</span><span class='line'>extension Rect {
</span><span class='line'>    init(center: Point, size: Size) {
</span><span class='line'>        let originX = center.x - (size.width / 2)
</span><span class='line'>        let originY = center.y - (size.height / 2)
</span><span class='line'>        self.init(origin: Point(x: originX, y: originY), size: size)
</span><span class='line'>    }
</span><span class='line'>}    
</span><span class='line'>
</span><span class='line'>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
</span><span class='line'>    size: Size(width: 3.0, height: 3.0))
</span><span class='line'>// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<pre><code>If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.
</code></pre>

<h5>Methods</h5>

<p>Extensions can add new instance methods and type methods to existing types.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Int {
</span><span class='line'>    func repetitions(task: () -&gt; ()) {
</span><span class='line'>        for i in 0..self {
</span><span class='line'>            task()
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>3.repetitions({
</span><span class='line'>    println("Hello!")
</span><span class='line'>    })
</span><span class='line'>// Hello!
</span><span class='line'>// Hello!
</span><span class='line'>// Hello!
</span><span class='line'>
</span><span class='line'>//或者
</span><span class='line'>3.repetitions {
</span><span class='line'>    println("Goodbye!")
</span><span class='line'>}
</span><span class='line'>// Goodbye!
</span><span class='line'>// Goodbye!
</span><span class='line'>// Goodbye!</span></code></pre></td></tr></table></div></figure>


<h5>Mutating Instance Methods</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Int {
</span><span class='line'>    mutating func square() {
</span><span class='line'>        self = self * self
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var someInt = 3
</span><span class='line'>someInt.square()
</span><span class='line'>// someInt is now 9</span></code></pre></td></tr></table></div></figure>


<h5>Subscripts</h5>

<p>Extensions can add new subscripts to an existing type.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>“extension Int {
</span><span class='line'>    subscript(digitIndex: Int) -&gt; Int {
</span><span class='line'>        var decimalBase = 1
</span><span class='line'>            for _ in 1...digitIndex {
</span><span class='line'>                decimalBase *= 10
</span><span class='line'>            }
</span><span class='line'>            return (self / decimalBase) % 10
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>746381295[0]
</span><span class='line'>// returns 5
</span><span class='line'>746381295[1]
</span><span class='line'>// returns 9
</span><span class='line'>746381295[2]
</span><span class='line'>// returns 2
</span><span class='line'>746381295[8]
</span><span class='line'>// returns 7</span></code></pre></td></tr></table></div></figure>


<h5>Nested Types</h5>

<p>Extensions can add new nested types to existing classes, structures and enumerations:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Character {
</span><span class='line'>    enum Kind {
</span><span class='line'>        case Vowel, Consonant, Other
</span><span class='line'>    }
</span><span class='line'>    var kind: Kind {
</span><span class='line'>    switch String(self).lowercaseString {
</span><span class='line'>    case "a", "e", "i", "o", "u":
</span><span class='line'>        return .Vowel
</span><span class='line'>    case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
</span><span class='line'>    "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
</span><span class='line'>        return .Consonant
</span><span class='line'>    default:
</span><span class='line'>        return .Other
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func printLetterKinds(word: String) {
</span><span class='line'>    println("'\(word)' is made up of the following kinds of letters:")
</span><span class='line'>    for character in word {
</span><span class='line'>        switch character.kind {
</span><span class='line'>        case .Vowel:
</span><span class='line'>            print("vowel ")
</span><span class='line'>        case .Consonant:
</span><span class='line'>            print("consonant ")
</span><span class='line'>        case .Other:
</span><span class='line'>            print("other ")
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    print("\n")
</span><span class='line'>}
</span><span class='line'>printLetterKinds("Hello")
</span><span class='line'>// 'Hello' is made up of the following kinds of letters:
</span><span class='line'>// consonant vowel consonant consonant vowel</span></code></pre></td></tr></table></div></figure>


<h4>Protocol</h4>

<p>A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality.</p>

<p>Protocols can <code>require</code> that conforming types have specific instance properties, instance methods, type methods, operators, and subscripts.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol SomeProtocol {
</span><span class='line'>    // protocol definition goes here
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct SomeStructure: FirstProtocol, AnotherProtocol {
</span><span class='line'>    // structure definition goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>If a class has a <code>superclass</code>, list the superclass name before any protocols it adopts, followed by a comma:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
</span><span class='line'>    // class definition goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Property Requirements</h5>

<p>A protocol can require any conforming type to provide an instance property or type property with a particular name and type.</p>

<p>The protocol doesn’t specify whether the property should be a stored property or a computed property—it only specifies the required property name and type. The protocol also specifies whether each property must be gettable or gettable and settable.</p>

<p>If a protocol requires a property to be gettable and settable, that property requirement cannot be fulfilled by a constant stored property or a read-only computed property.</p>

<p>Property requirements are always declared as variable properties, prefixed with the var keyword.</p>

<p>Gettable and settable properties are indicated by writing { get set } after their type declaration, and gettable properties are indicated by writing { get }.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol SomeProtocol {
</span><span class='line'>    var mustBeSettable: Int { get set }
</span><span class='line'>    var doesNotNeedToBeSettable: Int { get }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<pre><code>Always prefix type property requirements with the class keyword when you define them in a protocol. This is true even though type property requirements are prefixed with the static keyword when implemented by a structure or enumeration:
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol AnotherProtocol {
</span><span class='line'>    class var someTypeProperty: Int { get set }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Here’s an example of a protocol with a single instance property requirement:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol FullyNamed {
</span><span class='line'>    var fullName: String { get }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct Person: FullyNamed {
</span><span class='line'>    var fullName: String
</span><span class='line'>}
</span><span class='line'>let john = Person(fullName: "John Appleseed")
</span><span class='line'>// john.fullName is "John Appleseed”</span></code></pre></td></tr></table></div></figure>


<p>Swift reports an error at compile-time if a protocol requirement is not fulfilled.</p>

<p>Here’s a more complex class, which also adopts and conforms to the FullyNamed
protocol:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Starship: FullyNamed {
</span><span class='line'>    var prefix: String?
</span><span class='line'>    var name: String
</span><span class='line'>    init(name: String, prefix: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.prefix = prefix
</span><span class='line'>    }
</span><span class='line'>    var fullName: String {
</span><span class='line'>    return (prefix ? prefix! + " " : "") + name
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
</span><span class='line'>// ncc1701.fullName is "USS Enterprise”</span></code></pre></td></tr></table></div></figure>


<h5>Method Requirements</h5>

<p>Protocols can require specific instance methods and type methods to be implemented by conforming types. These methods are written as part of the protocol’s definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body. Variadic parameters are allowed, subject to the same rules as for normal methods.</p>

<p><code>注意</code></p>

<p>Protocols use the same syntax as normal methods, but are not allowed to specify default values for method parameters.</p>

<p>As with type property requirements, you always prefix type method requirements with the class keyword when they are defined in a protocol. This is true even though type method requirements are prefixed with the static keyword when implemented by a structure or enumeration:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol SomeProtocol {
</span><span class='line'>    class func someTypeMethod()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看一个demo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol RandomNumberGenerator {
</span><span class='line'>    func random() -&gt; Double
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class LinearCongruentialGenerator: RandomNumberGenerator {
</span><span class='line'>    var lastRandom = 42.0
</span><span class='line'>    let m = 139968.0
</span><span class='line'>    let a = 3877.0
</span><span class='line'>    let c = 29573.0
</span><span class='line'>    func random() -&gt; Double {
</span><span class='line'>        lastRandom = ((lastRandom * a + c) % m)
</span><span class='line'>        return lastRandom / m
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let generator = LinearCongruentialGenerator()
</span><span class='line'>println("Here's a random number: \(generator.random())")
</span><span class='line'>// prints "Here's a random number: 0.37464991998171"
</span><span class='line'>println("And another one: \(generator.random())")
</span><span class='line'>// prints "And another one: 0.729023776863283”</span></code></pre></td></tr></table></div></figure>


<h5>Mutating Method Requirements</h5>

<p>It is sometimes necessary for a method to modify (or mutate) the instance it belongs to</p>

<p><code>注意</code></p>

<p>If you mark a protocol instance method requirement as mutating, you do not need to write the mutating keyword when writing an implementation of that method for a class. The mutating keyword is only used by structures and enumerations.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Togglable {
</span><span class='line'>    mutating func toggle()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>enum OnOffSwitch: Togglable {
</span><span class='line'>    case Off, On
</span><span class='line'>    mutating func toggle() {
</span><span class='line'>        switch self {
</span><span class='line'>        case Off:
</span><span class='line'>            self = On
</span><span class='line'>        case On:
</span><span class='line'>            self = Off
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var lightSwitch = OnOffSwitch.Off
</span><span class='line'>lightSwitch.toggle()
</span><span class='line'>// lightSwitch is now equal to .On”</span></code></pre></td></tr></table></div></figure>


<h5>Protocols as Types</h5>

<p>Protocols do not actually implement any functionality themselves. Nonetheless, any protocol you create will become a fully-fledged type for use in your code.
Because it is a type, you can use a protocol in many places where other types are allowed, including:</p>

<ul>
<li>As a parameter type or return type in a function, method, or initializer</li>
<li>As the type of a constant, variable, or property</li>
<li>As the type of items in an array, dictionary, or other container</li>
</ul>


<p>Here’s an example of a protocol used as a type:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Dice {
</span><span class='line'>    let sides: Int
</span><span class='line'>    let generator: RandomNumberGenerator
</span><span class='line'>    init(sides: Int, generator: RandomNumberGenerator) {
</span><span class='line'>        self.sides = sides
</span><span class='line'>        self.generator = generator
</span><span class='line'>    }
</span><span class='line'>    func roll() -&gt; Int {
</span><span class='line'>        return Int(generator.random() * Double(sides)) + 1
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
</span><span class='line'>for _ in 1...5 {
</span><span class='line'>    println("Random dice roll is \(d6.roll())")
</span><span class='line'>}
</span><span class='line'>// Random dice roll is 3
</span><span class='line'>// Random dice roll is 5
</span><span class='line'>// Random dice roll is 4
</span><span class='line'>// Random dice roll is 5
</span><span class='line'>// Random dice roll is 4</span></code></pre></td></tr></table></div></figure>


<h4>Delegation</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol DiceGame {
</span><span class='line'>    var dice: Dice { get }
</span><span class='line'>    func play()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>protocol DiceGameDelegate {
</span><span class='line'>    func gameDidStart(game: DiceGame)
</span><span class='line'>    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
</span><span class='line'>    func gameDidEnd(game: DiceGame)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class SnakesAndLadders: DiceGame {
</span><span class='line'>    let finalSquare = 25
</span><span class='line'>    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
</span><span class='line'>    var square = 0
</span><span class='line'>    var board: Int[]
</span><span class='line'>    init() {
</span><span class='line'>        board = Int[](count: finalSquare + 1, repeatedValue: 0)
</span><span class='line'>        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
</span><span class='line'>        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
</span><span class='line'>    }
</span><span class='line'>    var delegate: DiceGameDelegate?
</span><span class='line'>    func play() {
</span><span class='line'>        square = 0
</span><span class='line'>        delegate?.gameDidStart(self)
</span><span class='line'>        gameLoop: while square != finalSquare {
</span><span class='line'>            let diceRoll = dice.roll()
</span><span class='line'>            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
</span><span class='line'>            switch square + diceRoll {
</span><span class='line'>            case finalSquare:
</span><span class='line'>                break gameLoop
</span><span class='line'>            case let newSquare where newSquare &gt; finalSquare:
</span><span class='line'>                continue gameLoop
</span><span class='line'>            default:
</span><span class='line'>                square += diceRoll
</span><span class='line'>                square += board[square]
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        delegate?.gameDidEnd(self)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class DiceGameTracker: DiceGameDelegate {
</span><span class='line'>    var numberOfTurns = 0
</span><span class='line'>    func gameDidStart(game: DiceGame) {
</span><span class='line'>        numberOfTurns = 0
</span><span class='line'>        if game is SnakesAndLadders {
</span><span class='line'>            println("Started a new game of Snakes and Ladders")
</span><span class='line'>        }
</span><span class='line'>        println("The game is using a \(game.dice.sides)-sided dice")
</span><span class='line'>    }
</span><span class='line'>    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
</span><span class='line'>        ++numberOfTurns
</span><span class='line'>        println("Rolled a \(diceRoll)")
</span><span class='line'>    }
</span><span class='line'>    func gameDidEnd(game: DiceGame) {
</span><span class='line'>        println("The game lasted for \(numberOfTurns) turns")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let tracker = DiceGameTracker()
</span><span class='line'>let game = SnakesAndLadders()
</span><span class='line'>game.delegate = tracker
</span><span class='line'>game.play()
</span><span class='line'>// Started a new game of Snakes and Ladders
</span><span class='line'>// The game is using a 6-sided dice
</span><span class='line'>// Rolled a 3
</span><span class='line'>// Rolled a 5
</span><span class='line'>// Rolled a 4
</span><span class='line'>// Rolled a 5
</span><span class='line'>// The game lasted for 4 turns</span></code></pre></td></tr></table></div></figure>


<h5>Adding Protocol Conformance with an Extension</h5>

<p><code>注意</code></p>

<p>Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance’s type in an extension.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol TextRepresentable {
</span><span class='line'>    func asText() -&gt; String
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension Dice: TextRepresentable {
</span><span class='line'>    func asText() -&gt; String {
</span><span class='line'>        return "A \(sides)-sided dice"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
</span><span class='line'>println(d12.asText())
</span><span class='line'>// prints "A 12-sided dice”
</span><span class='line'>
</span><span class='line'>extension SnakesAndLadders: TextRepresentable {
</span><span class='line'>    func asText() -&gt; String {
</span><span class='line'>        return "A game of Snakes and Ladders with \(finalSquare) squares"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println(game.asText())
</span><span class='line'>// prints "A game of Snakes and Ladders with 25 squares”</span></code></pre></td></tr></table></div></figure>


<h5>Declaring Protocol Adoption with an Extension</h5>

<p>If a type already conforms to all of the requirements of a protocol, but has not yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Hamster {
</span><span class='line'>    var name: String
</span><span class='line'>    func asText() -&gt; String {
</span><span class='line'>        return "A hamster named \(name)"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>extension Hamster: TextRepresentable {}</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<p>Instances of Hamster can now be used wherever TextRepresentable is the required type:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let simonTheHamster = Hamster(name: "Simon")
</span><span class='line'>let somethingTextRepresentable: TextRepresentable = simonTheHamster
</span><span class='line'>println(somethingTextRepresentable.asText())
</span><span class='line'>// prints "A hamster named Simon”</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<pre><code>Types do not automatically adopt a protocol just by satisfying its requirements. They must always explicitly declare their adoption of the protocol.
</code></pre>

<h5>Collections of Protocol Types</h5>

<p>A protocol can be used as the type to be stored in a collection such as an array or a dictionary</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let things: TextRepresentable[] = [game, d12, simonTheHamster]
</span><span class='line'>
</span><span class='line'>for thing in things {
</span><span class='line'>    println(thing.asText())
</span><span class='line'>}
</span><span class='line'>// A game of Snakes and Ladders with 25 squares
</span><span class='line'>// A 12-sided dice
</span><span class='line'>// A hamster named Simon
</span></code></pre></td></tr></table></div></figure>


<h5>Protocol Inheritance</h5>

<p>A protocol can inherit one or more other protocols and can add further requirements on top of the requirements it inherits</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
</span><span class='line'>    // protocol definition goes here
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>protocol PrettyTextRepresentable: TextRepresentable {
</span><span class='line'>    func asPrettyText() -&gt; String
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension SnakesAndLadders: PrettyTextRepresentable {
</span><span class='line'>    func asPrettyText() -&gt; String {
</span><span class='line'>        var output = asText() + ":\n"
</span><span class='line'>        for index in 1...finalSquare {
</span><span class='line'>            switch board[index] {
</span><span class='line'>            case let ladder where ladder &gt; 0:
</span><span class='line'>                output += "▲ "
</span><span class='line'>            case let snake where snake &lt; 0:
</span><span class='line'>                output += "▼ "
</span><span class='line'>            default:
</span><span class='line'>                output += "○ "
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return output
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>println(game.asPrettyText())
</span><span class='line'>// A game of Snakes and Ladders with 25 squares:
</span><span class='line'>// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span></code></pre></td></tr></table></div></figure>


<h5>Protocol Composition</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Named {
</span><span class='line'>    var name: String { get }
</span><span class='line'>}
</span><span class='line'>protocol Aged {
</span><span class='line'>    var age: Int { get }
</span><span class='line'>}
</span><span class='line'>struct Person: Named, Aged {
</span><span class='line'>    var name: String
</span><span class='line'>    var age: Int
</span><span class='line'>}
</span><span class='line'>func wishHappyBirthday(celebrator: protocol&lt;Named, Aged&gt;) {
</span><span class='line'>    println("Happy birthday \(celebrator.name) - you're \(celebrator.age)!")
</span><span class='line'>}
</span><span class='line'>let birthdayPerson = Person(name: "Malcolm", age: 21)
</span><span class='line'>wishHappyBirthday(birthdayPerson)
</span><span class='line'>// prints "Happy birthday Malcolm - you're 21!"</span></code></pre></td></tr></table></div></figure>


<h5>Checking for Protocol Conformance</h5>

<p>You can use the is and as operators described in Type Casting to check for protocol conformance, and to cast to a specific protocol.</p>

<ul>
<li>The is operator returns true if an instance conforms to a protocol and returns false if it does not.</li>
<li>The as? version of the downcast operator returns an optional value of the protocol’s type, and this value is nil if the instance does not conform to that protocol.</li>
<li>The as version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast does not succeed.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@objc protocol HasArea {
</span><span class='line'>    var area: Double { get }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<p>You can check for protocol conformance <code>only if your protocol is marked with the @objc attribute</code>, as seen for the HasArea protocol above. This attribute indicates that the protocol should be exposed to Objective-C code and is described in Using Swift with Cocoa and Objective-C. Even if you are not interoperating with Objective-C, you need to mark your protocols with the @objc attribute if you want to be able to check for protocol conformance.</p>

<p>Note also that @objc protocols can be adopted <code>only by classes</code>, and not by structures or enumerations. If you mark your protocol as @objc in order to check for conformance, you will be able to apply that protocol only to class types.</p>

<p>Here are two classes, Circle and Country, both of which conform to the HasArea protocol:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Circle: HasArea {
</span><span class='line'>    let pi = 3.1415927
</span><span class='line'>    var radius: Double
</span><span class='line'>    var area: Double { return pi * radius * radius }
</span><span class='line'>    init(radius: Double) { self.radius = radius }
</span><span class='line'>}
</span><span class='line'>class Country: HasArea {
</span><span class='line'>    var area: Double
</span><span class='line'>    init(area: Double) { self.area = area }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Animal Class</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Animal {
</span><span class='line'>    var legs: Int
</span><span class='line'>    init(legs: Int) { self.legs = legs }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let objects: AnyObject[] = [
</span><span class='line'>    Circle(radius: 2.0),
</span><span class='line'>    Country(area: 243_610),
</span><span class='line'>    Animal(legs: 4)
</span><span class='line'>]
</span><span class='line'>
</span><span class='line'>for object in objects {
</span><span class='line'>    if let objectWithArea = object as? HasArea {
</span><span class='line'>        println("Area is \(objectWithArea.area)")
</span><span class='line'>    } else {
</span><span class='line'>        println("Something that doesn't have an area")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>// Area is 12.5663708
</span><span class='line'>// Area is 243610.0
</span><span class='line'>// Something that doesn't have an area</span></code></pre></td></tr></table></div></figure>


<h5>Optional Protocol Requirements</h5>

<p>You can define optional requirements for protocols
Optional property requirements, and optional method requirements that return a value, will always return an optional value of the appropriate type when they are accessed or called</p>

<p>You check for an implementation of an optional requirement by writing a question mark after the name of the requirement when it is called, such as someOptionalMethod?(someArgument).</p>

<p><code>注意</code></p>

<pre><code>Optional protocol requirements can only be specified if your protocol is marked with the @objc attribute. Even if you are not interoperating with Objective-C, you need to mark your protocols with the @objc attribute if you want to specify optional requirements.
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@objc protocol CounterDataSource {
</span><span class='line'>    @optional func incrementForCount(count: Int) -&gt; Int
</span><span class='line'>    @optional var fixedIncrement: Int { get }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@objc class Counter {
</span><span class='line'>    var count = 0
</span><span class='line'>    var dataSource: CounterDataSource?
</span><span class='line'>    func increment() {
</span><span class='line'>        if let amount = dataSource?.incrementForCount?(count) {
</span><span class='line'>            count += amount
</span><span class='line'>        } else if let amount = dataSource?.fixedIncrement? {
</span><span class='line'>            count += amount
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class ThreeSource: CounterDataSource {
</span><span class='line'>    let fixedIncrement = 3
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var counter = Counter()
</span><span class='line'>counter.dataSource = ThreeSource()
</span><span class='line'>for _ in 1...4 {
</span><span class='line'>    counter.increment()
</span><span class='line'>    println(counter.count)
</span><span class='line'>}
</span><span class='line'>// 3
</span><span class='line'>// 6
</span><span class='line'>// 9
</span><span class='line'>// 12
</span></code></pre></td></tr></table></div></figure>


<p>另一个例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class TowardsZeroSource: CounterDataSource {
</span><span class='line'>    func incrementForCount(count: Int) -&gt; Int {
</span><span class='line'>        if count == 0 {
</span><span class='line'>            return 0
</span><span class='line'>        } else if count &lt; 0 {
</span><span class='line'>            return 1
</span><span class='line'>        } else {
</span><span class='line'>            return -1
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>counter.count = -4
</span><span class='line'>counter.dataSource = TowardsZeroSource()
</span><span class='line'>for _ in 1...5 {
</span><span class='line'>    counter.increment()
</span><span class='line'>    println(counter.count)
</span><span class='line'>}
</span><span class='line'>// -3
</span><span class='line'>// -2
</span><span class='line'>// -1
</span><span class='line'>// 0
</span><span class='line'>// 0</span></code></pre></td></tr></table></div></figure>


<h4>Generics</h4>

<p>交换两个值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoValues(&someInt, &anotherInt)
</span><span class='line'>// someInt is now 107, and anotherInt is now 3
</span><span class='line'> 
</span><span class='line'>var someString = "hello"
</span><span class='line'>var anotherString = "world"
</span><span class='line'>swapTwoValues(&someString, &anotherString)
</span><span class='line'>// someString is now "world", and anotherString is now "hello”
</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<pre><code>You can use Swift’s existing swap function rather than providing your own implementation.
</code></pre>

<h5>Type Parameters</h5>

<p>Type parameters specify and name a placeholder type, and are written immediately after the function’s name, between a pair of matching angle brackets (such as <T>).</p>

<p>You can provide more than one type parameter by writing multiple type parameter names within the angle brackets, separated by commas.</p>

<h5>Naming Type Parameters</h5>

<p>It is traditional to use the single-character name T for the type parameter. However, you are can use any valid identifier as the type parameter name.</p>

<p><code>注意</code></p>

<pre><code>Always give type parameters UpperCamelCase names (such as T and KeyType) to indicate that they are a placeholder for a type, not a value.
</code></pre>

<h5>Generic Types</h5>

<p>In addition to generic functions, Swift enables you to define your own generic types. These are custom classes, structures, and enumerations that can work with any type, in a similar way to Array and Dictionary.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Stack&lt;T&gt; {
</span><span class='line'>    var items = T[]()
</span><span class='line'>    mutating func push(item: T) {
</span><span class='line'>        items.append(item)
</span><span class='line'>    }
</span><span class='line'>    mutating func pop() -&gt; T {
</span><span class='line'>        return items.removeLast()
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var stackOfStrings = Stack&lt;String&gt;()
</span><span class='line'>stackOfStrings.push("uno")
</span><span class='line'>stackOfStrings.push("dos")
</span><span class='line'>stackOfStrings.push("tres")
</span><span class='line'>stackOfStrings.push("cuatro")
</span><span class='line'>// the stack now contains 4 strings”
</span><span class='line'>
</span><span class='line'>let fromTheTop = stackOfStrings.pop()
</span><span class='line'>// fromTheTop is equal to "cuatro", and the stack now contains 3 strings</span></code></pre></td></tr></table></div></figure>


<h5>Type Constraints</h5>

<p>It is sometimes useful to enforce certain type constraints on the types that can be used with generic functions and generic types. <code>Type constraints specify that a type parameter must inherit from a specific class, or conform to a particular protocol or protocol composition.</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
</span><span class='line'>    // function body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Type Constraints in Action</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findIndex&lt;T&gt;(array: T[], valueToFind: T) -&gt; Int? {
</span><span class='line'>    for (index, value) in enumerate(array) {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是这个函数编译失败!问题出在以下</p>

<pre><code>if value == valueToFind
</code></pre>

<p>Not every type in Swift can be compared with the equal to operator (==).
我们可以写成如下方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? {
</span><span class='line'>    for (index, value) in enumerate(array) {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Equatable表示类型必须遵循Equatable协议,这样编译就能顺利通过了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
</span><span class='line'>// doubleIndex is an optional Int with no value, because 9.3 is not in the array
</span><span class='line'>let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
</span><span class='line'>// stringIndex is an optional Int containing a value of 2</span></code></pre></td></tr></table></div></figure>


<h5>Associated Types</h5>

<p>When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol’s definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted. Associated types are specified with the typealias keyword.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Container {
</span><span class='line'>    typealias ItemType
</span><span class='line'>    mutating func append(item: ItemType)
</span><span class='line'>    var count: Int { get }
</span><span class='line'>    subscript(i: Int) -&gt; ItemType { get }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct IntStack: Container {
</span><span class='line'>    // original IntStack implementation
</span><span class='line'>    var items = Int[]()
</span><span class='line'>    mutating func push(item: Int) {
</span><span class='line'>        items.append(item)
</span><span class='line'>    }
</span><span class='line'>    mutating func pop() -&gt; Int {
</span><span class='line'>        return items.removeLast()
</span><span class='line'>    }
</span><span class='line'>    // conformance to the Container protocol
</span><span class='line'>    typealias ItemType = Int
</span><span class='line'>    mutating func append(item: Int) {
</span><span class='line'>        self.push(item)
</span><span class='line'>    }
</span><span class='line'>    var count: Int {
</span><span class='line'>    return items.count
</span><span class='line'>    }
</span><span class='line'>    subscript(i: Int) -&gt; Int {
</span><span class='line'>        return items[i]
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>If you delete the typealias ItemType = Int line from the code above, everything still works, because it is clear what type should be used for ItemType.</p>

<p>You can also make the generic Stack type conform to the Container protocol:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Stack&lt;T&gt;: Container {
</span><span class='line'>    // original Stack&lt;T&gt; implementation
</span><span class='line'>    var items = T[]()
</span><span class='line'>    mutating func push(item: T) {
</span><span class='line'>        items.append(item)
</span><span class='line'>    }
</span><span class='line'>    mutating func pop() -&gt; T {
</span><span class='line'>        return items.removeLast()
</span><span class='line'>    }
</span><span class='line'>    // conformance to the Container protocol
</span><span class='line'>    mutating func append(item: T) {
</span><span class='line'>        self.push(item)
</span><span class='line'>    }
</span><span class='line'>    var count: Int {
</span><span class='line'>    return items.count
</span><span class='line'>    }
</span><span class='line'>    subscript(i: Int) -&gt; T {
</span><span class='line'>        return items[i]
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Extending an Existing Type to Specify an Associated Type</h5>

<p>Extending an Existing Type to Specify an Associated Type</p>

<p>Swift’s Array type already provides an append method, a count property, and a subscript with an Int index to retrieve its elements. These three capabilities match the requirements of the Container protocol. This means that you can extend Array to conform to the Container protocol simply by declaring that Array adopts the protocol. You do this with an empty extension</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Array: Container {}</span></code></pre></td></tr></table></div></figure>


<p>Array’s existing append method and subscript enable Swift to infer the appropriate type to use for ItemType, just as for the generic Stack type above. After defining this extension, you can use any Array as a Container.</p>

<h5>Where Clauses</h5>

<p>The example below defines a generic function called allItemsMatch</p>

<p>The two containers to be checked <code>do not have to be the same type of container</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func allItemsMatch&lt;
</span><span class='line'>    C1: Container, C2: Container
</span><span class='line'>    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;
</span><span class='line'>    (someContainer: C1, anotherContainer: C2) -&gt; Bool {
</span><span class='line'>        
</span><span class='line'>        // check that both containers contain the same number of items
</span><span class='line'>        if someContainer.count != anotherContainer.count {
</span><span class='line'>            return false
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        // check each pair of items to see if they are equivalent
</span><span class='line'>        for i in 0..someContainer.count {
</span><span class='line'>            if someContainer[i] != anotherContainer[i] {
</span><span class='line'>                return false
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        // all items match, so return true
</span><span class='line'>        return true
</span><span class='line'>        
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var stackOfStrings = Stack&lt;String&gt;()
</span><span class='line'>stackOfStrings.push("uno")
</span><span class='line'>stackOfStrings.push("dos")
</span><span class='line'>stackOfStrings.push("tres")
</span><span class='line'> 
</span><span class='line'>var arrayOfStrings = ["uno", "dos", "tres"]
</span><span class='line'> 
</span><span class='line'>if allItemsMatch(stackOfStrings, arrayOfStrings) {
</span><span class='line'>    println("All items match.")
</span><span class='line'>} else {
</span><span class='line'>    println("Not all items match.")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Advanced Operators</h4>

<p>These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.</p>

<p>Unlike arithmetic operators in C, arithmetic operators in Swift do not overflow by default. Overflow behavior is trapped and reported as an error</p>

<p>To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (&amp;+). All of these overflow operators begin with an ampersand (&amp;).</p>

<p>When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types. Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create</p>

<p>You’re not just limited to the predefined operators. Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values. These operators can be used and adopted in your code just like any of the predefined operators, and you can even extend existing types to support the custom operators you define.</p>

<h5>Bitwise Operators</h5>

<ul>
<li>Bitwise NOT Operator</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let initialBits: UInt8 = 0b00001111
</span><span class='line'>let invertedBits = ~initialBits  // equals 11110000</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Bitwise AND Operator</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let firstSixBits: UInt8 = 0b11111100
</span><span class='line'>let lastSixBits: UInt8  = 0b00111111
</span><span class='line'>let middleFourBits = firstSixBits & lastSixBits  // equals 00111100</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Bitwise OR Operator</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someBits: UInt8 = 0b10110010
</span><span class='line'>let moreBits: UInt8 = 0b01011110
</span><span class='line'>let combinedbits = someBits | moreBits  // equals 11111110</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Bitwise XOR Operator</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>“let firstBits: UInt8 = 0b00010100
</span><span class='line'>let otherBits: UInt8 = 0b00000101
</span><span class='line'>let outputBits = firstBits ^ otherBits  // equals 00010001</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Bitwise Left and Right Shift Operators

<ul>
<li>Shifting Behavior for Unsigned Integers</li>
<li>Any bits that are moved beyond the bounds of the integer’s storage are discarded.</li>
<li>Zeroes are inserted in the spaces left behind after the original bits are moved to the left or right.</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let shiftBits: UInt8 = 4   // 00000100 in binary
</span><span class='line'>shiftBits &lt;&lt; 1             // 00001000
</span><span class='line'>shiftBits &lt;&lt; 2             // 00010000
</span><span class='line'>shiftBits &lt;&lt; 5             // 10000000
</span><span class='line'>shiftBits &lt;&lt; 6             // 00000000
</span><span class='line'>shiftBits &gt;&gt; 2             // 00000001</span></code></pre></td></tr></table></div></figure>


<p>You can use bit shifting to encode and decode values within other data types:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let pink: UInt32 = 0xCC6699
</span><span class='line'>let redComponent = (pink & 0xFF0000) &gt;&gt; 16    // redComponent is 0xCC, or 204
</span><span class='line'>let greenComponent = (pink & 0x00FF00) &gt;&gt; 8   // greenComponent is 0x66, or 102
</span><span class='line'>let blueComponent = pink & 0x0000FF           // blueComponent is 0x99, or 153</span></code></pre></td></tr></table></div></figure>


<h5>Shifting Behavior for Signed Integers</h5>

<ul>
<li>When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the sign bit, rather than with a zero.

<h5>Overflow Operators</h5></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var willOverflow = UInt8.max
</span><span class='line'>// willOverflow equals 255, which is the largest value a UInt8 can hold
</span><span class='line'>willOverflow = willOverflow &+ 1
</span><span class='line'>// willOverflow is now equal to 0</span></code></pre></td></tr></table></div></figure>


<p>Value Underflow</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var willUnderflow = UInt8.min
</span><span class='line'>// willUnderflow equals 0, which is the smallest value a UInt8 can hold
</span><span class='line'>willUnderflow = willUnderflow &- 1
</span><span class='line'>// willUnderflow is now equal to 255</span></code></pre></td></tr></table></div></figure>


<h5>Division by Zero</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let x = 1
</span><span class='line'>let y = x &/ 0
</span><span class='line'>// y is equal to 0</span></code></pre></td></tr></table></div></figure>


<h5>Operator Functions</h5>

<p>Classes and structures can provide their own implementations of existing operators. This is known as <code>overloading</code> the existing operators.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Vector2D {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}
</span><span class='line'>@infix func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {
</span><span class='line'>    return Vector2D(x: left.x + right.x, y: left.y + right.y)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The example above shows how to implement the arithmetic addition operator (+) for a custom structure. The arithmetic addition operator is a binary operator because it operates on two targets and is said to be <code>infix</code> because it appears in between those two targets.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vector = Vector2D(x: 3.0, y: 1.0)
</span><span class='line'>let anotherVector = Vector2D(x: 2.0, y: 4.0)
</span><span class='line'>let combinedVector = vector + anotherVector
</span><span class='line'>// combinedVector is a Vector2D instance with values of (5.0, 5.0)</span></code></pre></td></tr></table></div></figure>


<h5>Prefix and Postfix Operators</h5>

<p>Classes and structures can also provide implementations of the standard unary operators.You implement a prefix or postfix unary operator by writing the @prefix or @postfix attribute before the func keyword when declaring the operator function:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@prefix func - (vector: Vector2D) -&gt; Vector2D {
</span><span class='line'>    return Vector2D(x: -vector.x, y: -vector.y)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let positive = Vector2D(x: 3.0, y: 4.0)
</span><span class='line'>let negative = -positive
</span><span class='line'>// negative is a Vector2D instance with values of (-3.0, -4.0)
</span><span class='line'>let alsoPositive = -negative
</span><span class='line'>// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</span></code></pre></td></tr></table></div></figure>


<h5>Compound Assignment Operators</h5>

<p>You must  mark a compound assignment operator’s left input parameter as <code>inout</code>, because the parameter’s value will be modified directly from within the operator function.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@assignment func += (inout left: Vector2D, right: Vector2D) {
</span><span class='line'>    left = left + right
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var original = Vector2D(x: 1.0, y: 2.0)
</span><span class='line'>let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
</span><span class='line'>original += vectorToAdd
</span><span class='line'>// original now has values of (4.0, 6.0)</span></code></pre></td></tr></table></div></figure>


<p>You can combine the @assignment attribute with either the @prefix or @postfix attribute, as in this implementation of the prefix increment operator (++a) for Vector2D instances:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@prefix @assignment func ++ (inout vector: Vector2D) -&gt; Vector2D {
</span><span class='line'>    vector += Vector2D(x: 1.0, y: 1.0)
</span><span class='line'>    return vector
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var toIncrement = Vector2D(x: 3.0, y: 4.0)
</span><span class='line'>let afterIncrement = ++toIncrement
</span><span class='line'>// toIncrement now has values of (4.0, 5.0)
</span><span class='line'>// afterIncrement also has values of (4.0, 5.0)</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<pre><code>It is not possible to overload the default assignment operator (=). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator (a ? b : c) cannot be overloaded.
</code></pre>

<h5>Equivalence Operators</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@infix func == (left: Vector2D, right: Vector2D) -&gt; Bool {
</span><span class='line'>    return (left.x == right.x) && (left.y == right.y)
</span><span class='line'>}
</span><span class='line'>@infix func != (left: Vector2D, right: Vector2D) -&gt; Bool {
</span><span class='line'>    return !(left == right)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let twoThree = Vector2D(x: 2.0, y: 3.0)
</span><span class='line'>let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
</span><span class='line'>if twoThree == anotherTwoThree {
</span><span class='line'>    println("These two vectors are equivalent.")
</span><span class='line'>}
</span><span class='line'>// prints "These two vectors are equivalent.</span></code></pre></td></tr></table></div></figure>


<h5>Custom Operators</h5>

<p>New operators are declared at a global level using the operator keyword, and can
be declared as prefix, infix or postfix:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>operator prefix +++ {}
</span><span class='line'>
</span><span class='line'>@prefix @assignment func +++ (inout vector: Vector2D) -&gt; Vector2D {
</span><span class='line'>    vector += vector
</span><span class='line'>    return vector
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
</span><span class='line'>let afterDoubling = +++toBeDoubled
</span><span class='line'>// toBeDoubled now has values of (2.0, 8.0)
</span><span class='line'>// afterDoubling also has values of (2.0, 8.0)</span></code></pre></td></tr></table></div></figure>


<h5>Precedence and Associativity for Custom Infix Operators</h5>

<p>Custom infix operators can also specify a precedence and an associativity.
The possible values for associativity are left, right, and none.</p>

<p>The possible values for associativity are left, right, and none. Left-associative operators associate to the left if written next to other left-associative operators of the same precedence. Similarly, right-associative operators associate to the right if written next to other right-associative operators of the same precedence. Non-associative operators cannot be written next to other operators with the same precedence.</p>

<p>The associativity value defaults to none if it is not specified. The precedence value defaults to 100 if it is not specified.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>operator infix +- { associativity left precedence 140 }
</span><span class='line'>func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {
</span><span class='line'>    return Vector2D(x: left.x + right.x, y: left.y - right.y)
</span><span class='line'>}
</span><span class='line'>let firstVector = Vector2D(x: 1.0, y: 2.0)
</span><span class='line'>let secondVector = Vector2D(x: 3.0, y: 4.0)
</span><span class='line'>let plusMinusVector = firstVector +- secondVector
</span><span class='line'>// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</span></code></pre></td></tr></table></div></figure>


<h4>总结</h4>

<h5>Type Identifier</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someValue: ExampleModule.MyType</span></code></pre></td></tr></table></div></figure>


<h5>Tuple Type</h5>

<p>Void is a typealias for the the empty tuple type, ()</p>

<h5>Function Type</h5>

<p>You can apply the auto_closure attribute to a function type that has a parameter type of () and that returns the type of an expression (see Type Attributes). An autoclosure function captures an <code>implicit closure over the specified expression</code>, instead of the expression itself.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func simpleAssert(condition: @auto_closure () -&gt; Bool, message: String) {
</span><span class='line'>    if !condition() {
</span><span class='line'>        println(message)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let testNumber = 5
</span><span class='line'>simpleAssert(testNumber % 2 == 0, "testNumber isn't an even number.")
</span><span class='line'>// prints "testNumber isn't an even number.</span></code></pre></td></tr></table></div></figure>


<p>You can’t mark a variadic parameter or a return type with the inout keyword.</p>

<p>The type of a curried function is equivalent to a nested function type. For example, the type of the curried function addTwoNumbers()() below is Int &ndash;> Int &ndash;> Int:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func addTwoNumbers(a: Int)(b: Int) -&gt; Int {
</span><span class='line'>    return a + b
</span><span class='line'>}
</span><span class='line'>addTwoNumbers(4)(5) // Returns 9</span></code></pre></td></tr></table></div></figure>


<p>The function types of a curried function are grouped from right to left. For instance, the function type Int &ndash;> Int &ndash;> Int is understood as Int &ndash;> (Int &ndash;> Int)—that is, a function that takes an Int and returns another function that takes and return an Int</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func addTwoNumbers(a: Int) -&gt; (Int -&gt; Int) {
</span><span class='line'>    func addTheSecondNumber(b: Int) -&gt; Int {
</span><span class='line'>        return a + b
</span><span class='line'>    }
</span><span class='line'>    return addTheSecondNumber
</span><span class='line'>}
</span><span class='line'>addTwoNumbers(4)(5) // Returns 9</span></code></pre></td></tr></table></div></figure>


<h5>Array</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someArray: String[] = ["Alex", "Brian", "Dave"]
</span><span class='line'>let someArray: Array&lt;String&gt; = ["Alex", "Brian", "Dave"]
</span><span class='line'>
</span><span class='line'>var array3D: Int[][][] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]</span></code></pre></td></tr></table></div></figure>


<h5>Optional Type</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var optionalInteger: Int?
</span><span class='line'>var optionalInteger: Optional&lt;Int&gt;</span></code></pre></td></tr></table></div></figure>


<p>When declaring an optional type, be sure to use parentheses to properly scope the ? operator. As an example, to declare an optional array of integers, write the type annotation as (Int[])?; writing Int[]? produces an error.</p>

<h5>Implicitly Unwrapped Optional Type</h5>

<p>if you try to use an implicitly unwrapped optional that has a value of nil, you’ll get a runtime error.</p>

<h5>Metatype Type</h5>

<p>A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types.</p>

<p>The metatype of a class, structure, or enumeration type is the name of that type followed by .Type. The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by .Protocol. For example, the metatype of the class type SomeClass is SomeClass.Type and the metatype of the protocol SomeProtocol is SomeProtocol.Protocol.</p>

<p>You can use the postfix self expression to access a type as a value. For example, SomeClass.self returns SomeClass itself, not an instance of SomeClass. And SomeProtocol.self returns SomeProtocol itself, not an instance of a type that conforms to SomeProtocol at runtime. You can use a dynamicType expression with an instance of a type to access that instance’s runtime type as a value</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeBaseClass {
</span><span class='line'>    class func printClassName() {
</span><span class='line'>        println("SomeBaseClass")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>class SomeSubClass: SomeBaseClass {
</span><span class='line'>    override class func printClassName() {
</span><span class='line'>        println("SomeSubClass")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let someInstance: SomeBaseClass = SomeSubClass()
</span><span class='line'>// someInstance is of type SomeBaseClass at compile time, but
</span><span class='line'>// someInstance is of type SomeSubClass at runtime
</span><span class='line'>someInstance.dynamicType.printClassName()
</span><span class='line'>// prints "SomeSubClass"</span></code></pre></td></tr></table></div></figure>


<h5>Type Inheritance Clause</h5>

<p>When defining a class, the name of the superclass must appear first in the list of type identifiers, followed by any number of protocols the class must conform to.</p>

<h5>Assignment Operator</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(a, _, (b, c)) = ("test", 9.45, (12, 3))</span></code></pre></td></tr></table></div></figure>


<h5>Self Expression</h5>

<p>In a mutating method of value type, you can assign a new instance of that value type to self.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>        self = Point(x: x + deltaX, y: y + deltaY)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Closure Expression</h5>

<p>A closure expression can explicitly specify the values that it captures from the surrounding scope using a capture list. A capture list is written as a comma separated list surrounded by square brackets, before the list of parameters</p>

<p>Each entry in the capture list can be marked as weak or unowned to capture a weak or unowned reference to the value.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>myFunction { print(self.title) }                    // strong capture
</span><span class='line'>myFunction { [weak self] in print(self!.title) }    // weak capture
</span><span class='line'>myFunction { [unowned self] in print(self.title) }  // unowned capture</span></code></pre></td></tr></table></div></figure>


<p>You can also bind arbitrary expression to named values in the capture list. The expression is evaluated when the closure is formed, and captured with the specified strength</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Weak capture of "self.parent" as "parent"
</span><span class='line'>myFunction { [weak parent = self.parent] in print(parent!.title) }</span></code></pre></td></tr></table></div></figure>


<h5>Initializer Expression</h5>

<p>Unlike functions, an initializer can’t be used as a value. For example:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var x = SomeClass.someClassFunction // ok
</span><span class='line'>var y = SomeClass.init              // error</span></code></pre></td></tr></table></div></figure>


<p>You also use an initializer expression to delegate to the initializer of a superclass.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeSubClass: SomeSuperClass {
</span><span class='line'>    init() {
</span><span class='line'>        // subclass initialization goes here
</span><span class='line'>        super.init()
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Explicit Member Expression</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var t = (10, 20, 30)
</span><span class='line'>t.0 = t.1
</span><span class='line'>// Now t is (20, 20, 30)</span></code></pre></td></tr></table></div></figure>


<p>A <code>fallthrough</code> statement can appear anywhere inside a switch statement, not just as the last statement of a case block, but it can’t be used in the final case block.</p>

<h5>Parameter Names</h5>

<p>以下三种方式等价</p>

<ul>
<li>external parameter name local parameter name: parameter type</li>
<li><code>#parameter name: parameter type</code></li>
<li>_ local parameter name: parameter type</li>
</ul>


<p>An underscore (_) before a local parameter name gives that parameter no name to be used in function calls. The corresponding argument must have no name in function or method calls.</p>

<h5>Enumerations with Raw Cases Values</h5>

<p>Each case must have a unique name and be assigned a unique raw value. If the raw value type is specified as Int and you don’t assign a value to the cases explicitly, they are implicitly assigned the values 0, 1, 2, and so on. Each unassigned case of type Int is implicitly assigned a raw value that is automatically incremented from the raw value of the previous case.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum ExampleEnum: Int {
</span><span class='line'>    case A, B, C = 5, D
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Class Declaration</h5>

<p>When you declare either kind of initializer, you can require any subclass to override it by marking the initializer with the <code>required</code> attribute.</p>

<p>If the current class overrides all of the superclass’s designated initializers, it inherits the superclass’s convenience initializers.</p>

<h5>Protocol Declaration</h5>

<p>To restrict the adoption of a protocol to class types only, mark the entire protocol declaration with the <code>class_protocol</code> attribute</p>

<p><code>注意</code></p>

<p>If a protocol is already marked with the objc attribute, the class_protocol attribute is implicitly applied to that protocol; there’s no need to mark the protocol with the class_protocol attribute explicitly</p>

<h5>Protocol Property Declaration</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var property name: type { get set }</span></code></pre></td></tr></table></div></figure>


<p>That property declaration can’t be implemented as a constant property or a read-only computed property</p>

<p>Protocol method declarations have the same form as function declarations, with two exceptions: They don’t include a function body, and you can’t provide any default parameter values as part of the function declaration</p>

<p>If you’re implementing the method in an extension, use the class keyword if you’re extending a class and the static keyword if you’re extending a structure.</p>

<h5>Initializer Declaration</h5>

<p>Designated initializers can be declared in the context of a class declaration only and therefore can’t be added to a class using an extension declaration.</p>

<h5>Extension Declaration</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension type: adopted protocols {
</span><span class='line'>    declarations
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Extension declarations can’t contain destructor or protocol declarations, store properties, property observers, or other extension declarations.</p>

<p>Properties, methods, and initializers of an existing type can’t be overridden in an extension of that type.</p>

<h5>Subscript Declaration</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subscript (parameters) -&gt; return type {
</span><span class='line'>    get {
</span><span class='line'>        statements
</span><span class='line'>    }
</span><span class='line'>    set(setter name) {
</span><span class='line'>        statements
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Operator Declaration</h5>

<p>You can declare operators of three different fixities: infix, prefix, and postfix.
The fixity of an operator specifies the relative position of an operator to its operands.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>operator infix operatorName {
</span><span class='line'>    precedence precedence level
</span><span class='line'>    associativity associativity
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The precedence level can be any whole number (decimal integer) from 0 to 255; unlike decimal integer literals, it <code>can’t contain any underscore characters</code>.</p>

<p>Infix operators that are declared without specifying a precedence or associativity are initialized with a precedence level of 100 and an associativity of none.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>operator prefix operatorName {}</span></code></pre></td></tr></table></div></figure>


<h4>Attributes</h4>

<p>Attributes provide more information about a declaration or type. There are two kinds of attributes in Swift, those that apply to <code>declarations</code> and those that apply to <code>types</code>,For instance, the <code>required</code> attribute—when applied to a designated or convenience initializer declaration of a class—indicates that every subclass <code>must</code> implement that initializer.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@attributeName
</span><span class='line'>@attributeName(attribute arguments)</span></code></pre></td></tr></table></div></figure>


<h5>Declaration Attributes</h5>

<p>You can apply a declaration attribute to declarations only. However, you can also apply the <code>noreturn</code> attribute to a function or method type.</p>

<ul>
<li><p>class_protocol</p>

<pre><code>  Apply this attribute to a protocol to indicate that the protocol can be adopted by class types only.If you apply the objc attribute to a protocol, the class_protocol attribute is implicitly applied to that protocol; there’s no need to mark the protocol with the class_protocol attribute explicitly.
</code></pre></li>
<li><p>exported</p>

<pre><code>  Apply this attribute to an import declaration to export the imported module, submodule, or declaration from the current module. If another module imports the current module, that other module can access the items exported by the current module.
</code></pre></li>
<li><p>noreturn</p>

<p>  Apply this attribute to a function or method declaration to indicate that the corresponding type of that function or method, T, is @noreturn T. You can mark a function or method type with this attribute to indicate that the function or method <code>doesn’t return to its caller</code>.</p>

<p>  You can override a function or method that is not marked with the noreturn attribute with a function or method that is. That said, you can’t override a function or method that is marked with the noreturn attribute with a function or method that is not. Similar rules apply when you implement a protocol method in a conforming type.</p></li>
<li><p>NSManaged</p>

<p>  Apply this attribute to a stored variable property of a class that inherits from NSManagedObject to indicate that the storage and implementation of the property are provided dynamically by Core Data at runtime based on the associated entity description.</p></li>
<li>objc</li>
</ul>


<p>Apply this attribute to any declaration that can be represented in Objective-C—for example, non-nested classes, protocols, properties and methods (including getters and setters) of classes and protocols, initializers, deinitializers, and subscripts. <code>The objc attribute tells the compiler that a declaration is available to use in Objective-C code.</code></p>

<p>If you apply the objc attribute to a class or protocol, it’s implicitly applied to the members of that class or protocol. The compiler also implicitly adds the objc attribute to a class that inherits from another class marked with the objc attribute. <code>Protocols marked with the objc attribute can’t inherit from protocols that aren’t.</code></p>

<p>The objc attribute optionally accepts a single attribute argument, which consists of an identifier. Use this attribute when you want to expose a different name to Objective-C for the entity the objc attribute applies to.You can use this argument to name classes, protocols, methods, getters, setters, and initializers. The example below exposes the getter for the enabled property of the ExampleClass to Objective-C code as isEnabled rather than just as the name of the property itself.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@objc
</span><span class='line'>class ExampleClass {
</span><span class='line'>    var enabled: Bool {
</span><span class='line'>    @objc(isEnabled) get {
</span><span class='line'>        // Return the appropriate value
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>optional</p>

<p>  You can apply the <code>optional</code> attribute only to protocols that are marked with the objc attribute. As a result, only class types can adopt and conform to a protocol that contains optional member requirements.</p></li>
<li>required</li>
</ul>


<p>Apply this attribute to a designated or convenience initializer of a class to indicate that every subclass must implement that initializer.</p>

<p><code>Required designated initializers must be implemented explicitly</code>
<code>Required convenience initializers</code> can be either implemented explicitly or inherited when the subclass directly implements all of the superclass’s designated initializers (or when the subclass overrides the designated initializers with convenience initializers).</p>

<h5>Declaration Attributes Used by Interface Builder</h5>

<p>Interface Builder attributes are declaration attributes used by Interface Builder to synchronize with Xcode. Swift provides the following Interface Builder attributes: <code>IBAction, IBDesignable, IBInspectable, and IBOutlet</code>. These attributes are conceptually the same as their Objective-C counterparts.</p>

<p>You apply the <code>IBOutlet</code> and <code>IBInspectable</code> attributes to property declarations of a class,You apply the IBAction attribute to method declarations of a class and the IBDesignable attribute to class</p>

<h5>Type Attributes</h5>

<p>You can apply type attributes to types only.However, you can also apply the <code>noreturn</code> attribute to a function or method declaration.</p>

<ul>
<li><p>auto_closure</p>

<p>  This attribute is used to delay the evaluation of an expression by automatically wrapping that expression in a closure with no arguments. Apply this attribute to a function or method type that takes no arguments and that returns the type of the expression.</p></li>
<li>noreturn

<h4>Patterns</h4></li>
<li><p>Wildcard Pattern</p>

<p>  A wildcard pattern matches and ignores any value and consists of an underscore (_).</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for _ in 1...3 {
</span><span class='line'>    // Do something three times.
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>Identifier Pattern
An identifier pattern matches any value and binds the matched value to a variable or constant name.</p></li>
<li><p>Value-Binding Pattern</p>

<p>  A value-binding pattern binds matched values to variable or constant names. Value-binding patterns that bind a matched value to the name of a constant begin with the keyword let; those that bind to the name of variable begin with the keyword var.
  Identifiers patterns within a value-binding pattern bind new named variables or constants to their matching values</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let point = (3, 2)
</span><span class='line'>switch point {
</span><span class='line'>    // Bind x and y to the elements of point.
</span><span class='line'>case let (x, y):
</span><span class='line'>    println("The point is at (\(x), \(y)).")
</span><span class='line'>}
</span><span class='line'>// prints "The point is at (3, 2).</span></code></pre></td></tr></table></div></figure>


<p>You can constrain a tuple pattern to match certain kinds of tuple types by using type annotations</p>

<ul>
<li><p>Tuple Pattern</p>

<p>  When a tuple pattern is used as the pattern in a for-in statement or in a variable or constant declaration, it can contain only wildcard patterns, identifier patterns, or other tuple patterns that contain those. For example, the following code <code>isn’t valid</code> because the element 0 in the tuple pattern (x, 0) is an <code>expression pattern</code>:</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]
</span><span class='line'>// This code isn't valid.
</span><span class='line'>for (x, 0) in points {
</span><span class='line'>    /* ... */
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Type-Casting Patterns
There are two <code>type-casting</code> patterns, the is pattern and the as pattern. Both type-casting patterns appear only in switch statement case labels. The is and as patterns have the following form:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>is type
</span><span class='line'>pattern as type</span></code></pre></td></tr></table></div></figure>


<p>The is pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the is pattern—or a subclass of that type. <code>The is pattern behaves like the is operator</code> in that they both perform a type cast but discard the returned type.</p>

<ul>
<li><p>Expression Pattern</p>

<p>  An expression pattern represents the value of an expression. Expression patterns appear <code>only in switch</code> statement case labels.</p>

<p>  The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library ~= operator,By default, the ~= operator compares two values of the same type using the == operator. It can also match an integer value with a range of integers in an Range object, as the following example shows:</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let point = (1, 2)
</span><span class='line'>switch point {
</span><span class='line'>case (0, 0):
</span><span class='line'>    println("(0, 0) is at the origin.")
</span><span class='line'>case (-2...2, -2...2):
</span><span class='line'>    println("(\(point.0), \(point.1)) is near the origin.")
</span><span class='line'>default:
</span><span class='line'>    println("The point is at (\(point.0), \(point.1)).")
</span><span class='line'>}
</span><span class='line'>// prints "(1, 2) is near the origin.</span></code></pre></td></tr></table></div></figure>


<p>You can overload the ~= operator to provide custom expression matching behavior. For example, you can rewrite the above example to compare the point expression with a string representations of points.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Overload the ~= operator to match a string with an integer
</span><span class='line'>func ~=(pattern: String, value: Int) -&gt; Bool {
</span><span class='line'>    return pattern == "\(value)"
</span><span class='line'>}
</span><span class='line'>switch point {
</span><span class='line'>case ("0", "0"):
</span><span class='line'>    println("(0, 0) is at the origin.")
</span><span class='line'>case ("-2...2", "-2...2"):
</span><span class='line'>    println("(\(point.0), \(point.1)) is near the origin.")
</span><span class='line'>default:
</span><span class='line'>    println("The point is at (\(point.0), \(point.1)).")
</span><span class='line'>}
</span><span class='line'>// prints "(1, 2) is near the origin.</span></code></pre></td></tr></table></div></figure>


<h4>Generic Parameters and Arguments</h4>

<h5>Generic Parameter Clause</h5>

<ul>
<li><code>&lt;generic parameter list&gt;</code></li>
<li><code>&lt;generic parameter list where requirements&gt;</code></li>
</ul>


<p>The <code>generic parameter list</code> is a comma-separated list of generic parameters, each of which has the following form:</p>

<p><code>type parameter: constraint</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func simpleMin&lt;T: Comparable&gt;(x: T, y: T) -&gt; T {
</span><span class='line'>    if x &lt; y {
</span><span class='line'>        return y
</span><span class='line'>    }
</span><span class='line'>    return x
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>simpleMin(17, 42) // T is inferred to be Int
</span><span class='line'>simpleMin(3.14159, 2.71828) // T is inferred to be Double</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>Where Clauses</p>

<p>  You can specify additional requirements on type parameters and their associated types by including a where clause after the generic parameter list. A where clause consists of the keyword where, followed by a comma-separated list of one or more requirements.</p>

<p>  The requirements in a where clause specify that a type parameter inherits from a class or conforms to a protocol or protocol composition.</p>

<p>  you can express the constraints that a generic type T inherits from a class C and conforms to a protocol P as <T where T: C, T: P>.</p>

<p>  As mentioned above, you can constrain the associated types of type parameters to conform to protocols. For example, the generic parameter clause &lt;T: Generator where T.Element: Equatable> specifies that T conforms to the Generator protocol and the associated type of T, T.Element, conforms to the Equatable protocol (T has the associated type Element because Generator declares Element and T conforms to Generator).</p>

<p>  You can also specify the requirement that two types be identical, using the == operator. For example, the generic parameter clause &lt;T: Generator, U: Generator where T.Element == U.Element> expresses the constraints that T and U conform to the Generator protocol and that their associated types must be identical.</p>

<p>  You can subclass a generic class, but the subclass must also be a generic class.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Whats new in xcode6]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/08/03/whats-new-in-xcode6/"/>
    <updated>2014-08-03T15:35:28+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/08/03/whats-new-in-xcode6</id>
    <content type="html"><![CDATA[<p>Storyboard中能实时看到Custom Fonts</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/8/customfont.png"></p>

<p>swift如需使用不在某文件中定义的类，不需要import,会自动import，不过，你依然需要为你信赖的framework import modules,
创建.swift文件时，默认创建了.h头文件，所以如果在.m文件中引用swift文件中的类，可以用import .swift对应的头文件来引用
在ios8中，可以@import第三方的framework了!</p>

<h5>在IB中动态改变显示效果，如动态改变圆角</h5>

<p>注意以下几个方法的使用
<code>class</code>前写@IBDesignable,属性前写@IBInspectable,还有override以下方法</p>

<p>@override func prepareForInterfaceBuilder(){}</p>

<p><code>Size Classes</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fibers Threads Processes]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/30/fibers-threads-processes/"/>
    <updated>2014-07-30T15:42:25+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/30/fibers-threads-processes</id>
    <content type="html"><![CDATA[<p>Ruby gives you two basic ways to organize your program so that you can run different parts of it apparently “at the same time.” Fibers let you suspend execution of one part of your program and run some other part. For more decoupled execution, you can split up cooper- ating tasks within the program, using multiple threads, or you can split up tasks between different programs, using multiple processes. Let’s look at each in turn.####Fibers
Ruby 1.9引入了fibers的概念,尽管名字意味着某种轻量级的线程，实际上，fibers仅仅是一种非常简单的coroutine机制，它能让你写一些看起来用了线程的程序，实际上没有引发任何线程中内在的复杂机制
计算一个文件中单词的出现次数，不用fibers版本</p>

<pre><code>counts = Hash.new(0) 
File.foreach("testfile") do |line|
    line.scan(/\w+/) do |word| 
    word = word.downcase 
    counts[word] += 1
    end 
end
counts.keys.sort.each {|k| print "#{k}:#{counts[k]} "} 
produces:
and:1 is:3 line:3 on:1 one:1 so:1 this:3 three:1 two:1这段代码非常的ugly,它混合了查找word和计算word两种逻辑,来看看用Fiber的方法
words = Fiber.new do 
    File.foreach("testfile") do |line|          line.scan(/\w+/) do |word| 
        Fiber.yield word.downcase
        end 
    end     nil ￼end
counts = Hash.new(0)
while word = words.resume 
    counts[word] += 1
end
counts.keys.sort.each {|k| print "#{k}:#{counts[k]} "} 
produces:
and:1 is:3 line:3 on:1 one:1 so:1 this:3 three:1 two:1
</code></pre>

<p>再来看一个demo</p>

<pre><code>twos = Fiber.new do 
    num = 2     loop do         Fiber.yield(num) unless num % 3 == 0 
        num += 2
        end 
    end 10.times { print twos.resume, " " } 
produces:
2 4 8 10 14 16 20 22 26 28
</code></pre>

<p>以上也可以用之前提到的lazy Enumberators中实现由于fibers也是对象，你可以将它们存储在变量中，并且fibers只能在创建它们的线程中resume
fibers can yield control only back to the code that resumed them,不过Ruby提供了两种标准库来拓展这种行为fiber库和continuation库</p>

<h4>多线程</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Basic Input and Output]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/30/basic-input-and-output/"/>
    <updated>2014-07-30T14:27:07+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/30/basic-input-and-output</id>
    <content type="html"><![CDATA[<p>两个I/O routines
第一个是基本的交互界面</p>

<pre><code>print "Enter your name: " 

name = gets
</code></pre>

<p>一系列I/O相关的方法在Kernel module里实现gets, open, print, printf, putc, puts, readline, readlines, 和 test,这些方法通常都与标准输入，标准输出有关
第二个则是与IO对象交互
IO类，有两个子类File和BasicSocket</p>

<h5>开头文件</h5>

<pre><code>file = File.new("testfile", "r") 
# ... process the file 
file.close
</code></pre>

<p>File与Block</p>

<pre><code>File.open("testfile", "r") do |file| 
    # ... process the file
end # &lt;- file automatically closed here与exception结合
class File
    def File.open(*args)
        result = f = File.new(*args) 
            if block_given?
                begin
                    result = yield f
                ensure
                    f.close
                end 
            end
            result
            end 
end
</code></pre>

<h5>读写文件</h5>

<p>来看一段copy.rb代码</p>

<pre><code>while line = gets 

    puts line
end
</code></pre>

<p>如果运行程序木有命令行参数，则与console交互</p>

<pre><code>$ ruby copy.rb 

These are lines 

These are lines 

that I am typing 

that I am typing 

^D
</code></pre>

<p>如果带文件名，则与文件交互</p>

<pre><code>$ ruby copy.rb testfile 

This is line one
This is line two
This is line three
And so on...
</code></pre>

<p>我们可以用File类来读写文件</p>

<pre><code>File.open("testfile") do |file| 
    while line = file.gets          puts line       end 
end
    produces:
This is line one
This is line two
This is line three
And so on...
</code></pre>

<h5>Iterators for Reading</h5>

<p>你可以用各种iterators与IO流交互
O#each_byte invokes a block with the next 8-bit byte from the IO object,chr则将integer转化为ASCII字符</p>

<pre><code>File.open("testfile") do |file| 
    file.each_byte.with_index do |ch, index|
        print "#{ch.chr}:#{ch} "
        break if index &gt; 10 
    end
end
produces:
T:84 h:104 i:105 s:115  :32 i:105 s:115  :32 l:108 i:105 n:110 e:101
</code></pre>

<p>IO#each_line</p>

<pre><code>File.open("testfile") do |file|
    file.each_line {|line| puts "Got #{line.dump}" }
end
produces:
Got "This is line one\n"
Got "This is line two\n"
Got "This is line three\n"
Got "And so on...\n"
</code></pre>

<p>你也可以将一串字符传给each_line来作为一个line separator,默认是\n</p>

<pre><code>File.open("testfile") do |file|
    file.each_line("e") {|line| puts "Got #{ line.dump }" }
end
produces:
Got "This is line"
Got " one"
Got "\nThis is line"
Got " two\nThis is line"
Got " thre"
Got "e"
Got "\nAnd so on...\n"
</code></pre>

<p>combine iterator和autoclosing block,我们得到了IO.foreach,这个方法打开文件，调用iterator一次一行，然后自动关闭文件</p>

<pre><code>IO.foreach("testfile") {|line| puts line }将整个文件文件的内容保存在一个string或每行保存在一个数组里
//保存在string中
# read into string
str = IO.read("testfile")
str.length # =&gt; 66
str[0, 30] # =&gt; "This is line one\nThis is line "

//保存在array中

# read into an array    arr = IO.readlines("testfile") 
arr.length # =&gt; 4
arr[0] # =&gt; "This is line one\n"
</code></pre>

<h4>写入文件</h4>

<pre><code># Note the "w", which opens the file for writing
File.open("output.txt", "w") do |file| 
file.puts "Hello"
file.puts "1 + 2 = #{1+2}"
end
# Now read the file in and print its contents to STDOUT
puts File.read("output.txt")
produces:
Hello 1+2=3
</code></pre>

<p>如果将二进制数据转为string,有以下三种方法</p>

<pre><code>str1 = "\001\002\003" # =&gt; "\u0001\u0002\u0003" 

str2 = ""
str2 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 # =&gt; "\u0001\u0002\u0003" 
[ 1, 2, 3 ].pack("c*") # =&gt; "\x01\x02\x03"
</code></pre>

<p>你也可以用&lt;&lt;将对象添加到输出流中</p>

<pre><code>endl = "\n"
STDOUT &lt;&lt; 99 &lt;&lt; " red balloons" &lt;&lt; endl
produces:
99 red balloons 
</code></pre>

<p>&lt;&lt;方法在打印前将用to_s将它的参数转为string</p>

<h5>Doing I/O with StringsStringIO对象，它们操作起来就像I/O对象，但它们只是读写strings，而不是files</h5>

<pre><code>require 'stringio'
ip = StringIO.new("now is\nthe time\nto learn\nRuby!")
op = StringIO.new("", "w")
ip.each_line do |line| 
    op.puts line.reverse
end
op.string # =&gt; "\nsi won\n\nemit eht\n\nnrael ot\n!ybuR\n"
</code></pre>

<h4>Talking to Networkds</h4>

<p>socekt库封装了TCP,UDP,SOCKS和Unix domainsockes require &lsquo;socket&rsquo;    client = TCPSocket.open(&lsquo;127.0.0.1&rsquo;, &lsquo;www&rsquo;)</p>

<pre><code>client.send("OPTIONS /~dave/ HTTP/1.0\n\n", 0) 
puts client.readlines
client.close
produces:
# 0 means standard packet
HTTP/1.1 200 OK
Date: Mon, 27 May 2013 17:31:00 GMT
Server: Apache/2.2.22 (Unix) DAV/2 PHP/5.3.15 with Suhosin-Patch mod_ssl/2.2.22
OpenSSL/0.9.8r
Allow: GET,HEAD,POST,OPTIONS
Content-Length: 0
Connection: close
Content-Type: text/html
</code></pre>

<p>在高层,lib/net library modules提供了对通信协议的许多支持(FTP, HTTP, POP, SMTP, and telnet)</p>

<pre><code>//以下只是一部分代码
require 'net/http'
http = Net::HTTP.new('pragprog.com', 80)
response = http.get('/book/ruby3/programming-ruby-1-9')
if response.message == "OK"
puts response.body.scan(/&lt;img alt=".*?" src="(.*?)"/m).uniq[0,3]
end
produces:
       http://pragprog.com/assets/logo-c5c7f9c2f950df63a71871ba2f6bb115.gif
       http://pragprog.com/assets/drm-
       free80-9120ffac998173dc0ba7e5875d082f18.png
       http://imagery.pragprog.com/products/99/ruby3_xlargecover.jpg?
       1349967653open-url库中的Object#open方法能识别文件中的http://和ftp://URLs,也能自动处理重定向 
require 'open-uri'
open('http://pragprog.com') do |f|
puts f.read.scan(/&lt;img alt=".*?" src="(.*?)"/m).uniq[0,3]
end
produces:
       http://pragprog.com/assets/logo-c5c7f9c2f950df63a71871ba2f6bb115.gif
       http://pragprog.com/assets/drm-free80-9120ffac998173dc0ba7e5875d082f18.png
       http://imagery.pragprog.com/products/353/jvrails2_xlargebeta.jpg?1368826914
</code></pre>

<h4>Parsing HTML</h4>

<pre><code>require 'open-uri'
page = open('http://pragprog.com/titles/ruby3/programming-ruby-1-9').read 
if page =~ %r{&lt;title&gt;(.*?)&lt;/title&gt;}m
    puts "Title is #{$1.inspect}" 
end
produces:
       Title is "The Pragmatic Bookshelf | Programming Ruby 1.9"
</code></pre>

<p>但用此法不太妥当，可能title和尖括号间多个个空格如何是好，可以用第三方库Nokogiri</p>

<pre><code>require 'open-uri' 
require 'nokogiri'
doc = Nokogiri::HTML(open("http://pragprog.com/"))
puts "Page title is " + doc.xpath("//title").inner_html
# Output the first paragraph in the div with an id="copyright" 
# (nokogiri supports both xpath and css-like selectors)
puts doc.css('div#copyright p')
# Output the second hyperlink in the site-links div using xpath and css
puts "\nSecond hyperlink is"
puts doc.xpath('id("site-links")//a[2]') puts doc.css('#site-links a:nth-of-type(2)')
produces:
Page title is The Pragmatic Bookshelf
&lt;p&gt;
    The &lt;em&gt;Pragmatic BookshelfTM&lt;/em&gt; is an imprint of
        &lt;a href="http://pragprog.com/"&gt;The Pragmatic Programmers, LLC&lt;/a&gt;.
    &lt;br&gt;
    Copyright © 1999–2013 The Pragmatic Programmers, LLC.
    All Rights Reserved.
&lt;/p&gt;
Second hyperlink is
&lt;a href="http://pragprog.com/about"&gt;About Us&lt;/a&gt;
&lt;a href="http://pragprog.com/about"&gt;About Us&lt;/a&gt;
</code></pre>

<p>Nokogiri can also update and create HTML and XML.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exceptions-catch-throw]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/30/exceptions-catch-throw/"/>
    <updated>2014-07-30T11:52:27+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/30/exceptions-catch-throw</id>
    <content type="html"><![CDATA[<h4>The Exception Class</h4>

<p>异常的信息被封装进了Exception类的对象或者Exception类的子类对象里,Ruby预定义了exceptions的hierarchy,如下</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/exception_hierarchy.png"></p>

<p>如果你需要抛出异常,你可以用内置的Exception的类,或者可以自己创建一个，不过请确保你创建的Exception
子类继承自StandardError或者它的子类,否则默认情况下异常是不会被捕捉的
每一个Exception都有一个消息和stack backtrace与之关联，如果你定义了自己的异常，你可以添加额外的信息
这是有一个用open-url的库来下载一个网页的内容并将它写入一个文件中的demo</p>

<pre><code>require 'open-uri'
web_page = open("http://pragprog.com/podcasts") 
output = File.open("podcasts.html", "w")
while line = web_page.gets

output.puts line
end
output.close
</code></pre>

<p>如果中途出现错误怎么办，我们当然不想保存一张不完整的网页
我们看看如何处理异常的代码，我们将可能发生异常的代码放在begin/end的block中，然后用rescue语句来告诉Ruby我们想要捕获的异常类型</p>

<pre><code>require 'open-uri'
page = "podcasts"
file_name = "#{page}.html"
web_page = open("http://pragprog.com/#{page}") output = File.open(file_name, "w")
begin
    while line = web_page.gets output.puts line
end
output.close 
rescue Exception
    STDERR.puts "Failed to download #{page}: #{$!}" output.close
        File.delete(file_name)
        raise
end 
</code></pre>

<p>When an exception is raised and independent of any subsequent exception handling, Ruby places a reference to the associated exception object into the global variable $! (the exclamation point presumably mirroring our surprise that any of our code could cause errors). In the previous example, we used the $! variable to format our error message.
关掉并删除文件后，我们可以调用无参的raise，这样又在$!里重新抛出了异常，抛到更高层去了
还可以为捕获取的异常指定别名</p>

<pre><code>begin
    eval string
rescue SyntaxError, NameError =&gt; boom
    print "String doesn't compile: " + boom 
rescue StandardError =&gt; bang
    print "Error running script: " + bang 
end
</code></pre>

<h5>System ErrorsSystem errors are raised when a call to the operating system returns an error code,On POSIX systems, these errors have names such as EAGAIN and EPERM. (If you’re on a Unix box, you could type man errno to get a list of these errors.)</h5>

<p>Ruby将这些错误打包成一个具体的exception的对象,每一个是SymstemCallError的子类，并且都定义在Errno module中,这意味着你将看到Excetion的类另如Errno::EAGAIN, Errno::EIO, 和Errno::EPERM,如果你想要获取system error code,每个Error exception类都有一个叫做Errno类常量</p>

<pre><code>Errno::EAGAIN::Errno # =&gt; 35 

Errno::EPERM::Errno # =&gt; 1 

Errno::EWOULDBLOCK::Errno # =&gt; 35
</code></pre>

<p>注意EWOULDBLOCK 和 EAGAIN有同样的error code,所以在rescue中，Ruby把它们看作一样的，如果你想rescue一个，你再rescue两个，为此你可以重新定义 SystemCallError#===,这样，如果两个SystemCallError比较就会基于error number而不是它们在层次中的位置了</p>

<p>ensure相当于java中的finally</p>

<pre><code>f = File.open("testfile") 

begin
# .. process
rescue
  # .. handle error
ensure
f.close
end
</code></pre>

<p>注意File.open不能放在begin里面，因为open它自己也可能抛出异常，如果发生了，你应该不想在ensure里来执行相应的代码，因为没有文件要去close</p>

<p>else语句</p>

<pre><code>f = File.open("testfile") 

begin
# .. process
rescue
  # .. handle error
else
puts "Congratulations-- no errors!" 
ensure
f.close
end
</code></pre>

<p>注意else里的语句只有在无异发生时才会调用
有时你能改正抛出异常的cause,此时可以用retry语句来重新执行begin/end的block</p>

<pre><code>@esmtp = true
begin
    # First try an extended login. If it fails, fall back to a normal login
    if @esmtp then @command.ehlo(helodom) 
                    else @command.helo(helodom)
        end
rescue ProtocolError
    if @esmtp then
            @esmtp = false
            retry 
        else
            raise
        end 
end
</code></pre>

<h5>Raising Exceptions</h5>

<p>你可以用Object#raise方法来抛出异常</p>

<pre><code>raise   //抛出当前的exception,如果没有，则抛出RuntimeError
raise "bad mp3 encoding"    //创建一个新的RuntimeError,然后抛到调用栈上

//创建InterfaceException，与之相关的信息，然后抛到stack trace上 raise InterfaceException, "Keyboard failure", caller
</code></pre>

<p>stack trace通常用Object#caller
也可以将Exception抛给call stack一部分的子集
假设我们定义了一个RetryException类</p>

<pre><code>class RetryException &lt; RuntimeError
    attr :ok_to_retry
        def initialize(ok_to_retry)
                   @ok_to_retry = ok_to_retry
        end 
end
</code></pre>

<p>在代码的某个地方，一个错误发生了</p>

<pre><code>def read_data(socket) 

    data = socket.read(512) 

    if data.nil?
    raise RetryException.new(true), "transient read error" 
    end        # .. normal processing   endhigher up te call stack,我们处理异常
begin        stuff = read_data(socket)        # .. process stuff    rescue RetryException =&gt; detail 
    retry if detail.ok_to_retry 
    raise   end
</code></pre>

<h5>catch and throw</h5>

<pre><code>word_list = File.open("wordlist") 
word_in_error = catch(:done) do
        result = []
        while line = word_list.gets
    word = line.chomp
    throw(:done, word) unless word =~ /^\w+$/ 
        result &lt;&lt; word
    end
      puts result.reverse
end
if word_in_error
    puts "Failed: '#{word_in_error}' found, but a word was expected" 
end
</code></pre>

<p>throw不一定非要出现在catch语句里</p>

<pre><code>def prompt_and_get(prompt)
    print prompt
    res = readline.chomp
    throw :quit_requested if res == "!" 
    res
end
catch :quit_requested do
    name = prompt_and_get("Name: ") 
    age = prompt_and_get("Age: ") 
    sex = prompt_and_get("Sex: ") 
    # ..
    # process information
end 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Expressions]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/30/expressions/"/>
    <updated>2014-07-30T09:14:04+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/30/expressions</id>
    <content type="html"><![CDATA[<p>显而易见的是我们可以chain statements</p>

<pre><code>a = b = c = 0 # =&gt; 0
[ 3, 1, 7, 0 ].sort.reverse # =&gt; [7, 3, 1, 0]
</code></pre>

<p>比如不明显的是，在C或Java中的语句在Ruby中通常是expressions,比如if和case语句都返回了最后一个表达式</p>

<pre><code>song_type = if song.mp3_type == MP3::Jazz
                if song.written &lt; Date.new(1935, 1, 1)
                    Song::TradJazz
                else
                    Song::Jazz
                end 
            else
                Song::Other
            end
rating = case votes_cast
￼         when 0...10     then Rating::SkipThisOne
            when 10...50    then Rating::CouldDoBetter 
            else    Rating::Rave
         end
</code></pre>

<h5>Operator Expressions</h5>

<p>在Ruby中，许多operations是以方法调用的形式实现的，比如，当你写a*b+c时，实际上你是调用了a的方法<code>*</code>传入参数b,然后a<code>*</code>b的结果返回一个对象，我们再对其执行<code>+</code>的方法,然后将c作为参数传入,实际下相当于以下代码</p>

<pre><code>a, b, c = 1, 2, 3
a * b + c # =&gt; 5
 (a.*(b)).+(c) # =&gt; 5
</code></pre>

<p>我们问题可以定义最基本的运算符操作</p>

<pre><code>class Fixnum
alias old_plus + # We can reference the original '+' as 'old_plus'
def +(other) # Redefine addition of Fixnums. This is a BAD IDEA! 
old_plus(other).succ
end end
1 + 2 # =&gt; 4 a=3
a+=4 #=&gt;8 
a + a + a # =&gt; 26    
</code></pre>

<h6>&lt;&lt;操作符</h6>

<pre><code>a = [ 1, 2, 3 ]
    a&lt;&lt;4 #=&gt;[1,2,3,4]
</code></pre>

<p>我们也可以定义&lt;&lt;操作符方法</p>

<pre><code>class ScoreKeeper 
    def initialize
               @total_score = @count = 0
        end
        def &lt;&lt;(score)
                   @total_score += score
                   @count += 1
                   self
        end
        def average
            fail "No scores" if @count.zero?
            Float(@total_score) / @count
        end 
end      
scores = ScoreKeeper.new
scores &lt;&lt; 10 &lt;&lt; 20 &lt;&lt; 40
puts "Average = #{scores.average}"
produces:
       Average = 23.333333333333332
</code></pre>

<p>注意&lt;&lt;方法中返回了self，这样它就允许<code>scores &lt;&lt; 10 &lt;&lt; 20 &lt;&lt; 40</code>这样的形式
<code>[]</code>也能被定义为一个方法调用，你可以这么写</p>

<pre><code>some_obj[1,2,3]
</code></pre>

<p>我们可以这样定义</p>

<pre><code>class SomeClass
    def [](p1, p2, p3)
        # ...
        end
end
</code></pre>

<p>同样地，也可以定义<code>[]=</code>方法  class SomeClass</p>

<pre><code>    def []=(*params)
        value = params.pop
        puts "Indexed with #{params.join(', ')}" 
        puts "value = #{value.inspect}"
    end
end
s = SomeClass.new
s[1] = 2
s['cat', 'dog'] = 'enemies'
produces:
       Indexed with 1
       value = 2
       Indexed with cat, dog
       value = "enemies"
</code></pre>

<p>从上面我们可以看到<code>[]</code>里的参数作为params的前n个数，而=右边的值为params的最后一个参数</p>

<h5>各种各样的表达式</h5>

<ul>
<li>Command Expression
以&#8220;括起来的字符串或以%x开头的字符串被OS解析为一条bash命令,注意换行符还在
      <code>date</code> # => &ldquo;Mon May 27 12:30:56 CDT 2013\n&rdquo;
      <code>ls</code>.split[34] # => &ldquo;newfile&rdquo;
          %x{echo &ldquo;hello there&rdquo;} # => &ldquo;hello there\n&rdquo;
              for i in 0..3
          status = <code>dbmanager status id=#{i}</code> # &hellip;
      end
我们可以通过全局变量$?来查看命令的exit status

<h4>重定义`</h4>

以上我们得知&#8220;里的字符串默认被当作命令来执行，实际上，string是被当作参数传给了方法Object#`,如果你想，可以重写它，
  alias old_backquote <code>
      def</code>(cmd)
          result = old_backquote(cmd)
          if $? != 0
              puts &ldquo;<strong><em> Command #{cmd} failed: status = #{$?.exitstatus}&rdquo;
          end     result  end
  print <code>ls -l /etc/passwd</code>
  print <code>ls -l /etc/wibble</code>
  produces:
     -rw-r&mdash;r&mdash;  1 root  wheel  5086 Jul 20  2011 /etc/passwd
     ls: /etc/wibble: No such file or directory
     </em></strong> Command ls -l /etc/wibble failed: status = 1

<h4>赋值</h4>

<p>Ruby有两种形式的赋值，第一种是将对象的引用赋予一个变量或常量
      instrument = &ldquo;piano&rdquo;
  MIDDLE_A = 440
第二种形式涉及到<code>having an object attribute or element reference on the left side.</code>这种形式是很特别的，因为它们通过在左值中调用方法来实现，也就是说你可以重写这些方法
   class ProjectList
       def initialize
          @projects = []
      end
      def projects=(list)
          @projects = list.map(&amp;:upcase) # store list of names in uppercase
      end
      def <a href="offset"></a>
          @projects[offset]
      end
  end
  list = ProjectList.new
  list.projects = %w{ strip sand prime sand paint sand paint rub paint }
  list[3] # => &ldquo;SAND&rdquo;
  list[4] # => &ldquo;PAINT&rdquo;
来看一段有意思的代码</p>

<p>  class Test
      def val=(val)
          @val = val
          return 99
      end
  end</p>

<p>  t = Test.new
      result = (t.val = 2)
  result
以上的result会是什么值?
在Ruby的过去版本中，赋值方法的返回值<code>总量</code>return的值，而从Ruby1.8开始,返回值总是传入的参数值
所以以上的result值如果在过去的版本中为99，但在1.8版本后则为2</p></li>
</ul>


<h6>Parallel Assignment</h6>

<pre><code>a,b=1,2 #a=1,b=2 

a,b=b,a #b=2,a=1
a=1,2,3,4 # a=[1,2,3,4] 
    b=[1,2,3,4] # b=[1,2,3,4]   
a,b=1,2,3,4 # a=1, b=2 
c,=1,2,3,4 # c=1
</code></pre>

<h5>Splats and Assignment</h5>

<pre><code>a, b, c, d, e = *(1..2), 3, *[4, 5] # a=1, b=2, c=3, d=4, e=5       a,*b=1,2,3 # a=1, b=[2,3] a,*b=1 # a=1, b=[]
*a,b=1,2,3,4        # a=[1,2,3], b=4
c,*d,e=1,2,3,4      # c=1, d=[2,3], e=4
f,*g,h,i,j=1,2,3,4  # f=1, g=[], h=2, i=3, j=4      first, *, last = 1,2,3,4,5,6 # first=1, last=6#####嵌套赋值
a, (b, c), d = 1,2,3,4          # a=1, b=2, c=nil, d=3
a, (b, c), d = [1,2,3,4]        # a=1, b=2, c=nil, d=3
a, (b, c), d = 1,[2,3],4        # a=1, b=2, c=3, d=4
a, (b, c), d = 1,[2,3,4],5      # a=1, b=2, c=3, d=5
a, (b,*c), d = 1,[2,3,4],5      # a=1, b=2, c=[3, 4], d=5Ruby中木有++和--运算符
</code></pre>

<h4>Conditional Execution</h4>

<pre><code>var ||= "default value"
</code></pre>

<p>相当于</p>

<pre><code>var = "default value" unless var 
</code></pre>

<h5>defined?</h5>

<pre><code>defined? 1          # =&gt; "expression"
defined? dummy      # =&gt; nil
defined? printf     # =&gt; "method"
defined? String     # =&gt; "contant"
defined? $_         # =&gt; "global-variable"
defined? Math::PI # =&gt; "constant"
defined? a = 1      # =&gt; "assignment"
defined? 42.abs     # =&gt; "method"
defined? nil        # =&gt; "nil"
</code></pre>

<h5>Comparing Objects</h5>

<p>除了boolean运算符，Ruby对象支持用方法==，===，&lt;=>, =~,eql?和equal?来比较,&lt;=>定义在Object类中,但通常被重写来实现类希望的语义,比如Array类重定义了==所以两个array对象只有在它们的元素个数一样，并且相应的元素也相等的情况下才真正的相等
==和=~都有相应地否定形式,!=和!~,如果调用!=或!~,Ruby首先寻找此类的!=或!~,如果发现就调用它们，如果不发现，就调用==或=~,然后再对结果取反</p>

<pre><code>class T
    def ==(other)
            puts "Comparing self == #{other}"
        other == "value" 
        end
end
t = T.new
p (t == "value") 
p (t != "value")
produces:
Comparing self == value
true
Comparing self == value
false
</code></pre>

<p>以上调用<code>t != "value"</code>时,首先调用t = &ldquo;value&rdquo;,然后再对结果取反
各操作符的意义如下</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/operator.png"></p>

<h5>if and unless Expressions</h5>

<p>if then语句</p>

<pre><code>if artist == "Gillespie" then handle = "Dizzy"
elsif artist == "Parker" then handle = "Bird"
else
handle = "unknown" 
end
</code></pre>

<p>关键字<code>then</code>是optional的，如果你想将语句多行排列的话</p>

<pre><code>if artist == "Gillespie" 
    handle = "Dizzy"
elsif artist == "Parker" 
    handle = "Bird"
else
handle = "unknown" 
end
</code></pre>

<p>不过如果你想将then后对应的语句与if语句放在同一行，then是必不可少的!</p>

<pre><code>if artist == "Gillespie" then handle = "Dizzy" 
elsif artist == "Parker" then handle = "Bird" 
else handle = "unknown"
end
</code></pre>

<p>与if对应的是unless</p>

<pre><code>unless duration &gt; 180 
    listen_intently
end
</code></pre>

<h5>if and unless Modifiers</h5>

<pre><code>mon, day, year = $1, $2, $3 if date =~ /(\d\d)-(\d\d)-(\d\d)/ 
puts "a = #{a}" if $DEBUG
print total unless total.zero?
File.foreach("/etc/passwd") do |line|
next if line =~ /^#/ # Skip comments 
parse(line) unless line =~ /^$/ # Don't parse empty lines
end
</code></pre>

<h5>case Expressions</h5>

<ul>
<li>第一种形式
      case
          when song.name == &ldquo;Misty&rdquo;
          puts &ldquo;Not again!&rdquo;
          when song.duration > 120
          puts &ldquo;Too long!&rdquo;
          when Time.now.hour > 21
          puts &ldquo;It&rsquo;s too late&rdquo;
          else
          song.play
          end

<ul>
<li>第二种形式           case command
  when &ldquo;debug&rdquo;
    dump_debug_info
    dump_symbols
  when /p\s+(\w+)/
  dump_variable($1)
  when &ldquo;quit&rdquo;, &ldquo;exit&rdquo;
  exit
  else
  print &ldquo;Illegal command: #{command}&rdquo;
  end</li>
</ul>
</li>
<li><p>第三种形式
与then语句结合使用</p>

<pre><code>  kind = case year
  when 1850..1889 then "Blues"
  when 1890..1909 then "Ragtime"
  when 1910..1929 then "New Orleans Jazz" when 1930..1939 then "Swing"
  else "Jazz"
  end
</code></pre>

case的比较是用 <code>===</code>来比较的,所以，只要类为<code>===</code>定义了有意义的语义,此类的对象就能用在case语句中
需要<code>注意</code>的是,ruby的类是<code>Class</code>类的对象，===已经在Class类中定义了，可以用来测试相应的argument是否是receiver的instance或它的superclasses之一，所以你可以测试对象的类
  case shape
  when Square, Rectangle
  # &hellip;
  when Circle
  # &hellip;
  when Triangle
  # &hellip;
  else
  # &hellip;
  end

<h4>Loops</h4>

<p>while与until表达的意义相反
  while line = gets # &hellip;
  end   <br/>
  until play_list.duration > 60</p>

<p>  play_list.add(song_list.pop)
  end
  a=1
  a*=2 whilea<100 a # => 128
  a &ndash;= 10 until a &lt; 100 a # => 98</p></li>
</ul>


<p>range用作条件语句</p>

<pre><code>file = File.open("ordinal") 
while line = file.gets
    puts(line) if line =~ /third/ .. line =~ /fifth/ 
end
produces:
third
fourth
fifth
</code></pre>

<p>range中的起始位置也可以是表达式</p>

<pre><code>File.foreach("ordinal") do |line|       if (($. == 1) || line =~ /eig/) .. (($. == 3) || line =~ /nin/)     print line      end 
end
produces:
first
second
third
eighth
ninth如果你用`begin.....end`block，则不论while的条件语句是什么，都会`至少`执行一次
print "Hello\n" while false 
begin
    print "Goodbye\n" 
end while false
produces:
Goodbye
</code></pre>

<h4>Iterators</h4>

<pre><code>3.times do

print "Ho! "
end
produces:
Ho! Ho! Ho!
</code></pre>

<p>upto有使用</p>

<pre><code>0.upto(9) do |x|
print x, " "
end
produces:
0123456789step
0.step(12, 3) {|x| print x, " " } 
produces:
0 3 6 9 12
</code></pre>

<p>array的遍历</p>

<pre><code>[ 1, 1, 2, 3, 5 ].each {|val| print val, " " } 
produces:
11235
</code></pre>

<p>each</p>

<pre><code>File.open("ordinal").grep(/d$/) do |line| 

    puts line
end
produces:
second
third
</code></pre>

<p>loop的使用</p>

<pre><code>loop do     # block ... end
</code></pre>

<p>for&hellip;in</p>

<pre><code>for song in playlist

song.play
end
</code></pre>

<p>如果按以上这么写，则Ruby会将它翻译成</p>

<pre><code>playlist.each do |song|

    song.play
end你可以将for....in用在任何定义了each的方法的类上
for i in File.open("ordinal").find_all {|line| line =~ /d$/} 
    print i.chomp, " "
end

class Periods 
    def each
    yield "Classical" 
    yield "Jazz" 
    yield "Rock"
    end 
end
periods = Periods.new 
for genre in periods
print genre, " " end
produces:
Classical 
Jazz 
Rock
</code></pre>

<h5>break,redo,next</h5>

<p>break和next后面可以跟一个value</p>

<pre><code>result = while line = gets
            break(line) if line =~ /answer/
         end process_answer(result) if result
</code></pre>

<h4>作用域</h4>

<p>注意以下代码中,a的赋值语句虽然没有执行，但在之后的语句中a仍然可用</p>

<pre><code>a = "never used" if false 
[99].each do |i|
    a = i # this sets the variable in the outer scope 
end
a # =&gt; 99
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More About Methods]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/29/more-about-methods/"/>
    <updated>2014-07-29T22:17:21+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/29/more-about-methods</id>
    <content type="html"><![CDATA[<h5>定义一个方法</h5>

<p>一个方法用关键字def来定义，方法名应该以一个小写字母或一个下划线开头，紧跟着字母，数字和下划线,方法名也许以一个?,!或=号结尾，一个返回bool值的方法通常以一个?结果</p>

<pre><code>1.even? # =&gt; false 

2.even? # =&gt; true 

1.instance_of?(Fixnum) # =&gt; true
</code></pre>

<p>危险的方法，或是修改调用者的方法，可以用一个!来结尾,有时这些方法叫做<code>bang methods</code>,比如，类String提供了chop和chop！两种方法，前者返回了一个修改的string，后者则修改了调用此方法的字符串
能出现在赋值运算符<code>=</code>左边的方法以一个<code>=</code>结尾,如</p>

<pre><code>class BookInStock
        attr_reader :isbn, :price
    def initialize(isbn, price) 
    @isbn = isbn
    @price = Float(price)
    end
    def price=(new_price) 
    @price = new_price
    end     # ...   end
book = BookInStock.new("isbn1", 33.80) 
book.price = book.price * 0.75
</code></pre>

<p>有参和无参方法定义如下</p>

<pre><code>def my_new_method(arg1, arg2, arg3) # 3 arguments 

    # Code for the method would go here end
def my_other_new_method # No arguments 
    # Code for the method would go here     end
</code></pre>

<p>可以为参数指定默认值</p>

<pre><code>    def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach") 
    "#{arg1}, #{arg2}, #{arg3}."
end

cool_dude                           # =&gt; "Miles, Coltrane, Roach."
            cool_dude("Bart")                   # =&gt; "Bart, Coltrane, Roach."
cool_dude("Bart", "Elwood")         # =&gt; "Bart, Elwood, Roach."
cool_dude("Bart", "Elwood", "Linus") # =&gt; "Bart, Coltrane, Linus."
</code></pre>

<p>后一个参数的默认值也可以指定为与前一个参数相关的表达式</p>

<pre><code>def surround(word, pad_width=word.length/2) 
    "[" * pad_width + word + "]" * pad_width
end
surround("elephant") # =&gt; "[[[[elephant]]]]" 
surround("fox") # =&gt; "[fox]"
surround("fox", 10) # =&gt; "[[[[[[[[[[fox]]]]]]]]]]"#####可变参数
def varargs(arg1, *rest)
    "arg1=#{arg1}. rest=#{rest.inspect}"
end
varargs("one")                  # =&gt; arg1=one.  rest=[]
varargs("one", "two")           # =&gt; arg1=one.  rest=["two"]
varargs "one", "two", "three"   # =&gt; arg1=one.  rest=["two", "three"]   
</code></pre>

<p>有时我们用*来指定不被此类方法但被superclass中的此同名方法调用的参数,注意这种情况下我们直接调用super(无任何参数)，这种特殊的情况下意味着&#8221;在superclass中调用此方法，此所有的参数传到此类super的同名方法&#8221;</p>

<pre><code>class Child &lt; Parent
def do_something(*not_used)
    # our processing
super end
end
</code></pre>

<p>你也可以只写一个*</p>

<pre><code>class Child &lt; Parent 

    def do_something(*)
            # our processing
            super 
        end
end
</code></pre>

<p>你可以将带*的参数放在方法参数列表的任意位置</p>

<pre><code>def split_apart(first, *splat, last)
        puts "First: #{first.inspect}, splat: #{splat.inspect}, " +     "last: #{last.inspect}" 
end
split_apart(1,2)
split_apart(1,2,3)
split_apart(1,2,3,4)
produces:
First: 1, splat: [], last: 2
First: 1, splat: [2], last: 3
First: 1, splat: [2, 3], last: 4
你也可以只关心起始的参数，这样，你可以像以下这样定义方法
def split_apart(first, *, last)
</code></pre>

<h5>Methods and Blocks</h5>

<p>方法可以用yield来调用与它相关联的block</p>

<pre><code>def double(p1) yield(p1*2)
end
double(3) {|val| "I got #{val}" } # =&gt; "I got 6" 
double("tom") {|val| "Then I got #{val}" } # =&gt; "Then I got tomtom"如果一个方法的最后一个参数以&amp;开头，任何相关的block都能当作参数传入方法并被转化为一个Proc对象
class TaxCalculator
    def initialize(name, &amp;block)
            @name, @block = name, block
        end
        def get_tax(amount)
            "#@name on #{amount} = #{ @block.call(amount) }" 
        end
end
tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 } 
tc.get_tax(100) # =&gt; "Sales tax on 100 = 7.5"
tc.get_tax(250) # =&gt; "Sales tax on 250 = 18.75"
</code></pre>

<h5>调用方法</h5>

<pre><code>connection.download_mp3("jitterbug") {|p| show_progress(p) } //对象

File.size("testfile") # =&gt; 66           //类

Math.sin(Math::PI/4) # =&gt; 0.7071067811865475    //Module
</code></pre>

<p>如果省略了receiver,默认是self</p>

<pre><code>class InvoiceWriter
        def initialize(order)

        @order = order
                end
    def write_on(output)
        write_header_on(output)
        write_body_on(output)
        write_totals_on(output)
    end

private     def write_header_on(output)
    # ...
    end
    def write_body_on(output)
    # ...
    end
    def write_totals_on(output)
    # ...
    end 
end#####将参数传给方法
</code></pre>

<p>在不引起歧义的情况下，你可以省略括号，不过通常不推荐这么做</p>

<pre><code># for some suitable value in 
obj: a = obj.hash # Same as
a = obj.hash() # this.
obj.some_method "Arg1", arg2, arg3 # Same thing as //1.8之前
obj.some_method("Arg1", arg2, arg3) # with parentheses. 如果你将多个参数传给return语句，方法将会以数组的形式返回这些参数
def meth_three 100.times do |num|
   square = num*num
return num, square if square &gt; 1000 end
end
meth_three # =&gt; [32, 1024]
</code></pre>

<p>你可以按以下方式来获取返回的值</p>

<pre><code>num, square = meth_three 
num # =&gt; 32
square # =&gt; 1024    
</code></pre>

<h5>*!在方法调用中展开Collections</h5>

<pre><code>def five(a, b, c, d, e)
    "I was passed #{a} #{b} #{c} #{d} #{e}"
end
five(1,2,3,4,5) #=&gt;"Iwaspassed12345" 
five(1, 2, 3, *['a', 'b']) # =&gt; "I was passed 1 2 3 a b" 
five(*['a', 'b'], 1, 2, 3) # =&gt; "I was passed a b 1 2 3" five(*(10..14)) 
#=&gt;"Iwaspassed1011121314" 
five(*[1,2], 3, *(4..5)) #=&gt;"Iwaspassed12345"
</code></pre>

<p>Ruby 1.9中， 带*参数可以出现参数列表中的任意位置</p>

<h5>Block的妙用</h5>

<p>先来看一段代码</p>

<pre><code>print "(t)imes or (p)lus: " operator = gets
print "number: "
number = Integer(gets)
if operator =~ /^t/
puts((1..10).collect {|n| n*number }.join(", "))
else
puts((1..10).collect {|n| n+number }.join(", ")) 
end
produces:
(t)imes or (p)lus: t
number: 2
2, 4, 6, 8, 10, 12, 14, 16, 18, 20
</code></pre>

<p>以上的代码能工作，但是很丑陋，我们注意到if和else的语句几乎一样，可以用block来改进如下</p>

<pre><code>print "(t)imes or (p)lus: " 
operator = gets
print "number: "
number = Integer(gets)
if operator =~ /^t/
calc = lambda {|n| n*number }
else
  calc = lambda {|n| n+number }
end
puts((1..10).collect(&amp;calc).join(", "))
produces:
(t)imes or (p)lus: t
number: 2
2, 4, 6, 8, 10, 12, 14, 16, 18, 20
</code></pre>

<p>如果方法的最后一个参数是以&amp;开头的，则Ruby认为它是一个Proc对象，方法将它移除出参数列表，然后将Proc对象转为block，再与方法关联</p>

<h5>Hash and Keyword Arguments</h5>

<p>先来看一段代码</p>

<pre><code>class SongList
    def search(field, params)
        # ...
        end 
end
list = SongList.new
list.search(:titles, { genre: "jazz", duration_less_than: 270 })
</code></pre>

<p>实际上这种方式不值得推荐，{}很容易让人误认为是一个block，所以Ruby提供了一个捷径，在参数列表中你可以传入key => value这种形式,只要它们跟在正常的参数之后，在任何的*和block参数之前，所有的这些键值对都将被组装成一个hash参数传入方法中,可以略去{}</p>

<pre><code>list.search(:titles, genre: "jazz", duration_less_than: 270)
</code></pre>

<h5>Keyword Argument Lists</h5>

<p>我们仔细研究一下search方法，它接受一个field的名字和一个options hash,也许我们想要默认的duration为120s，并且加入验证方法-非法的验证不让它通过</p>

<p>Ruby 2.0之前，代码是这么写的</p>

<pre><code>def search(field, options)
    options = { duration: 120 }.merge(options) 
    if options.has_key?(:duration)
        duration = options[:duration]
        options.delete(:duration)
    end
    if options.has_key?(:genre)
        genre = options[:genre]
        options.delete(:genre)
    end
    fail "Invalid options: #{options.keys.join(', ')}" unless options.empty? 
    # rest of method
end 如果是Ruby 2.0，可以简化为以下
def search(field, genre: nil, duration: 120) 
    p [field, genre, duration ]
end search(:title)
search(:title, duration: 432)
search(:title, duration: 432, genre: "jazz")
produces:
[:title, nil, 120]
[:title, nil, 432]
[:title, "jazz", 432]
</code></pre>

<p>如果传入的是一个非法选项，Ruby将会报错</p>

<pre><code>search(:title, duraton: 432)
produces:
//是duration，不是duraton!  prog.rb:5:in `&lt;main&gt;': unknown keyword: duraton (ArgumentError)
</code></pre>

<p>你也可以将多个hash参数整合为一个hash参数，只要在方法的参数列表里在某参数的前面加<code>两个</code>星号</p>

<pre><code>def search(field, genre: nil, duration: 120, **rest) 
    p [field, genre, duration, rest ]
end
search(:title, duration: 432, stars: 3, genre: "jazz", tempo: "slow") 
produces:
[:title, "jazz", 432, {:stars=&gt;3, :tempo=&gt;"slow"}]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Regular Expression]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/29/regular-expression/"/>
    <updated>2014-07-29T12:59:58+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/29/regular-expression</id>
    <content type="html"><![CDATA[<p>正则表达式如下</p>

<pre><code>/cat/

/123/
</code></pre>

<p>正则表达式<code>/.../</code>里的常量和双引号的字符串类似,实际上，你可以在正则里，你也可以用<code>#{...}</code>表达式的替换形式</p>

<h5>Matching Strings with Patterns</h5>

<pre><code>/cat/ =~ "dog and cat" # =&gt; 8 

/cat/ =~ "catch" # =&gt; 0 

/cat/ =~ "Cat" # =&gt; nil
</code></pre>

<p>如果你喜欢也可以把字符串放在前面</p>

<pre><code>"dog and cat" =~ /cat/ # =&gt; 8 

"catch" =~ /cat/ # =&gt; 0 

"Cat" =~ /cat/ # =&gt; nil
</code></pre>

<p>模式匹配如果失败，会返回nil、，而nil在条件表达式中相当于false，所以可以把正则表达式的匹配结果作为if和while的条件语句</p>

<pre><code>str = "cat and dog"
    if str =~ /cat/
puts "There's a cat here somewhere"
end
produces:
There's a cat here somewhere
</code></pre>

<p>以下的代码打印&#8221;testfile&#8221;文件中有&#8221;on&#8221;字符串的行</p>

<pre><code>File.foreach("testfile").with_index do |line, index| 

puts "#{index}: #{line}" if line =~ /on/
    end
produces:
0: This is line one
3: And so on...你可以用!~来查找`不匹配`的字符串

File.foreach("testfile").with_index do |line, index| 

    puts "#{index}: #{line}" if line !~ /on/
        end
produces:
1: This is line two
2: This is line three
</code></pre>

<h5>Changing Strings with Patterns</h5>

<p>sub方法用来查找并替换匹配的字符串</p>

<pre><code>str = "Dog and Cat"
    new_str = str.sub(/Cat/, "Gerbil")
puts "Let's go to the #{new_str} for a pint."
produces:
Let's go to the Dog and Gerbil for a pint.
</code></pre>

<p>sub只是替换第一个匹配的，要替换全局匹配的，就用gsub</p>

<pre><code>str = "Dog and Cat"
    new_str1 = str.sub(/a/, "*") 
new_str2 = str.gsub(/a/, "*") 
puts "Using sub: #{new_str1}" 
puts "Using gsub: #{new_str2}"
produces:
Using sub: Dog *nd Cat
Using gsub: Dog *nd C*t 
</code></pre>

<p>需要注意的是，sub和gsub都返回一个全新的string,不论是否替换！如果替换，也返回原string的一个copy
如果你想要修改原始的string，你可以用sub!和gsub!的形式</p>

<pre><code>str = "now is the time" 

str.sub!(/i/, "*") 

str.gsub!(/t/, "T") 

puts str
    produces:
now *s The Time
</code></pre>

<p>不过不像sub和gsub，sub!和gsub!只有在匹配正则表达式时才返回string，如果不匹配，则返回nil，这意味着你可以将它放在条件语句中</p>

<h5>Digging Deeper</h5>

<p>未完待续&hellip;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Standard Types]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/28/standard-types/"/>
    <updated>2014-07-28T08:10:44+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/28/standard-types</id>
    <content type="html"><![CDATA[<p> 这一章主要介绍Ruby中的几个标准类型:numbers,strings,ranges,regular expressions</p>

<h4>Numbers</h4>

<p>Integers可以是任何长度(内存有多大，长度就有多大),在一定范围内(通常是pow(-2,30)&hellip;pow(2,30)-1或是pow(-2,62)&hellip;pow(2,62)-1)的Integers是类Fixnum的对象,超出此范围的则是类Bignum的对象,这个转化过程由Ruby自动来处理</p>

<pre><code>num = 10001 4.times do
    puts "#{num.class}: #{num}" num *= num
end
    produces:
       Fixnum: 10001
       Fixnum: 100020001
       Fixnum: 10004000600040001
       Bignum: 100080028005600700056002800080001
</code></pre>

<p>我们可以在数字前添加0x,0b等前缀,或是下划线</p>

<pre><code>123456 =&gt; 123456    # Fixnum
0d123456 =&gt; 123456      # Fixnum
123_456 =&gt; 123456       # Fixnum - underscore ignored
-543 =&gt; -543            # Fixnum - negative number
0xaabb =&gt; 43707         # Fixnum - hexadecimal
0377 =&gt; 255             # Fixnum - octal
-0b10_1010 =&gt; -42       # Fixnum - binary (negated)
123_456_789_123_456_789 =&gt; 123456789123456789 # Bignum
</code></pre>

<p>Ruby支持rational和complex number,Rational numbers是两个整数的比</p>

<pre><code>Rational(3, 4) * Rational(2, 3) # =&gt; (1/2) Rational("3/4") * Rational("2/3") # =&gt; (1/2)
Complex(1, 2) * Complex(3, 4) # =&gt; (-5+10i) Complex("1+2i") * Complex("3+4i") # =&gt; (-5+10i)
</code></pre>

<p>需要注意的是,不像Perl，在表达式计算时，Strings中的数字并不会自动转为数字
假设有一个文字如下，我们需要计算每行两个数字的和</p>

<pre><code>3   4 

5   6 

7   8
</code></pre>

<p>以下的代码并不工作</p>

<pre><code>some_file.each do |line| 

v1, v2 = line.split         # split line on spaces

print v1 + v2, " "
    end
produces:
34 56 78
</code></pre>

<p>应该先把strings转为integers</p>

<pre><code>some_file.each do |line|
    v1, v2 = line.split
print Integer(v1) + Integer(v2), " "
end
produces:
7 11 15
</code></pre>

<h5>How Number interact</h5>

<pre><code>1 + 2                   # =&gt; 3
1 + 2.0                 # =&gt; 3.0
1.0+2                   # =&gt; 3.0

1.0 + Complex(1,2)      # =&gt; (2.0+2i)
1 + Rational(2,3)       # =&gt; (5/3)
1.0 + Rational(2,3)     # =&gt; 1.6666666666666665
</code></pre>

<p>如果你需要除法能返回 一个Rational number,则需引入mathn库,这个库能帮我们以最<code>自然</code>的方式展示两数运算的结果</p>

<pre><code>22 / 7 # =&gt; 3

Complex::I * Complex::I # =&gt; (-1+0i)
require 'mathn' 22 / 7 # =&gt; (22/7) 
Complex::I * Complex::I # =&gt; -1
</code></pre>

<h5>Looping Using Numbers</h5>

<pre><code>3.times { print "X " } 

1.upto(5) {|i| print i, " " } 

99.downto(95) {|i| print i, " " } 

50.step(80, 5) {|i| print i, " " }

produces:
    X X X 1 2 3 4 5 99 98 97 96 95 50 55 60 65 70 75 80
</code></pre>

<p>同其他迭代器一样，如果其后没有block，则会返回一个Enumerator对象</p>

<pre><code>10.downto(7).with_index {|num, index| puts "#{index}: #{num}"}
produces:
   0: 10
   1: 9
   2: 8
   3: 7
</code></pre>

<h4>Strings</h4>

<p>String有两种组成方式，单引号和双引号组成的string
单引号</p>

<pre><code> 'escape using "\\"'   # =&gt; escape using "\"
      'That\'s right'       # =&gt; That's right
</code></pre>

<p>如果是双引号,你可以用#{expr}来替换strings里的值,如果expr是个全局变量，类变量，或是一个类的实例,花括号可以省略</p>

<pre><code>"Seconds/day: #{24*60*60}" 

"#{'Ho! '*3}Merry Christmas!" "Safe level is #$SAFE"
    # =&gt; Seconds/day: 86400
# =&gt; Ho! Ho! Ho! Merry Christmas!
    # =&gt; Safe level is 0
</code></pre>

<p>{}里的代码不一定只是一个表达式，也可以由多条语句构成</p>

<pre><code>puts "now is #{ def the(a)
                 'the ' + a
                end
                the('time')
                } for all bad coders..."
produces:
now is the time for all bad coders...
</code></pre>

<p>你还可以用另外三种方式来构建一个string常量:%q,%Q以及here documents
你可以把%q看成是单引号,%Q看成是双引号</p>

<pre><code>%q/general single-quoted string/        # =&gt; general single-quoted string

%Q!general double-quoted string!        # =&gt; general double-quoted string

%Q{Seconds/day: #{24*60*60}}            # =&gt; Seconds/day: 86400
</code></pre>

<p>实际上Q是可有可无的</p>

<pre><code>%!general double-quoted string! # =&gt; general double-quoted string 

%{Seconds/day: #{24*60*60}} # =&gt; Seconds/day: 86400
</code></pre>

<p>实际上紧跟在q或Q后的是分隔符,分隔符可以由任何<code>nonalphanumeric</code> 或 <code>nonmultibyte</code>字符组成
最后,我们来看看如何用<code>here document</code>来创建string</p>

<pre><code>string = &lt;&lt;END_OF_STRING
    The body of the string is the input lines up to     one starting with the same text that followed the '&lt;&lt;'  END_OF_STRING
</code></pre>

<p>通常terminator从第一行开始，不过，如果你把一个负号放在&lt;&lt;后，你可以对terminator进行缩进，创建的string也会进行缩进</p>

<pre><code>string = &lt;&lt;-END_OF_STRING
    The body of the string is the input lines up to     one starting with the same text that followed the '&lt;&lt;'  END_OF_STRING
</code></pre>

<p>你也可以将多个here documents放在同一行上，每一个代表一个单独的string,here document的bodies从source lines中依次获取</p>

<pre><code>print &lt;&lt;-STRING1, &lt;&lt;-STRING2 
Concat
STRING1
      enate
      STRING2
produces:
Concat 
    enate
</code></pre>

<p> 注意在此情况下Ruby并不会将enate前的空格给去掉</p>

<h4>Strings and Encodings</h4>

<p>每一个string都有一个对应的encoding,一个string的默认的encoding取决于包含它的源文件的encoding,如果没有指明显式的encoding,一个源文件(和它的string)在Ruby 1.9用的是US-ASCII编码，Ruby 2则是UTF-8</p>

<pre><code>plain_string = "dog"
    puts RUBY_VERSION
puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}"

produces:
2.0.0
Encoding of "dog" is UTF-8
</code></pre>

<p>如果你在文件的开头指明用了哪个encoding,文件中所有的string都 会用此encoding</p>

<pre><code>#encoding: utf-8
plain_string = "dog"
puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}" utf_string = "δog"
puts "Encoding of #{utf_string.inspect} is #{utf_string.encoding}"
produces:
Encoding of "dog" is UTF-8
Encoding of "δog" is UTF-8
</code></pre>

<h6>Working with Strings</h6>

<p>假设一个文件有以下格式</p>

<pre><code>/jazz/j00132.mp3  | 3:45 | Fats     Waller     | Ain't Misbehavin'
/jazz/j00319.mp3  | 2:58 | Louis    Armstrong  | Wonderful World
/bgrass/bg0732.mp3| 4:09 | Strength in Numbers | Texas Red
</code></pre>

<p>现在我们要做以下三件事情</p>

<ol>
<li>将每一行分解成fields</li>
<li>将时间从mm:ss转为秒</li>
<li><p>移除artist中名字中的空格
先来看看第一步</p>

<pre><code>  Song = Struct.new(:title, :name, :length)
  File.open("songdata") do |song_file| songs = []
  song_file.each do |line|
  file, length, name, title = line.chomp.split(/\s*\|\s*/) 

  name.squeeze!(" ")      songs &lt;&lt; Song.new(title, name, length)
  end
    puts songs[1]
  end
  produces:
  #&lt;struct Song title="Wonderful World", name="Louis Armstrong", length="2:58"&gt;
</code></pre>

<p>注意上面的line.chomp,因为每一行都有一个换行符，所以必须把它去掉
来看下如何处理时间,用split也可以，但我们用更好的方式scan</p>

<pre><code>  Song = Struct.new(:title, :name, :length) 

  File.open("songdata") do |song_file|
  songs = []
  song_file.each do |line|
  file, length, name, title = line.chomp.split(/\s*\|\s*/) 
  name.squeeze!(" ")
  mins, secs = length.scan(/\d+/)
  songs &lt;&lt; Song.new(title, name, mins.to_i*60 + secs.to_i)
  end
  puts songs[1]
  end
  produces:
  #&lt;struct Song title="Wonderful World", name="Louis Armstrong", length=178&gt;####Ranges
</code></pre>

<p>ranges主要用在以下三个方面:sequences, conditions和intervals</p></li>
</ol>


<p>1.Ranges as Sequences</p>

<pre><code>1..10
'a'..'z' 0..."cat".length
</code></pre>

<p>你可以用to_a将一个range转为一个数组,用to_enum将它转为一个Enumberator</p>

<pre><code>(1..10).to_a # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 


('bar'..'bat').to_a # =&gt; ["bar", "bas", "bat"]
enum = ('bar'..'bat').to_enum
enum.next # =&gt; "bar"
enum.next # =&gt; "bas"
</code></pre>

<p>Ranges有很多方法能让你遍历它们并且用很多方法测试它们</p>

<pre><code>digits = 0..9
digits.include?(5) # =&gt; true
digits.max # =&gt; 9
digits.reject {|i| i &lt; 5 } # =&gt; [5, 6, 7, 8, 9] 
</code></pre>

<p>digits.inject(:+) # => 45
目前我们已经看到了numbers和strings的ranges，实际上，ranges也可以基于你定义的对象来创建,惟一的要求是对象必须定义succ方法，这个方法返回了序列中的下一个对象，这个对象还必须实现<code>&lt;=&gt;</code>(有时称为<code>spaceship operator</code>),允许对象之间的比较,返回-1,0, 1</p>

<pre><code>class PowerOfTwo 
    attr_reader :value 
    def initialize(value)
        @value = value
    end
    def &lt;=&gt;(other)
        @value &lt;=&gt; other.value
    end
    def succ
        PowerOfTwo.new(@value + @value)
    end
    def to_s
    @value.to_s
    end 

end
p1 = PowerOfTwo.new(4)
p2 = PowerOfTwo.new(32)
puts (p1..p2).to_a
produces:
4 
8 
16 
32
</code></pre>

<h5>Ranges as Conditions</h5>

<pre><code>while line = gets
    puts line if line =~ /start/ .. line =~ /end/
end
</code></pre>

<h5>Ranges as Intervals</h5>

<p>可以借此来查看某些值是否在range间,注意必须用<code>===</code></p>

<pre><code>(1..10) === 5 # =&gt; true

(1..10) === 15 # =&gt; false 

(1..10) === 3.14159 # =&gt; true 

('a'..'j') === 'c' # =&gt; true 

('a'..'j') === 'z' # =&gt; false还可用在case中
car_age = gets.to_f # let's assume it's 9.5 
case car_age
when 0...1
    puts "Mmm.. new car smell" 
when 1...3
puts "Nice and new" 
when 3...10
    puts "Reliable but slightly dinged" 
when 10...30
    puts "Clunker" 
else
    puts "Vintage gem" 

end
produces:
Reliable but slightly dinged
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sharing Functionality: Inheritance]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/27/sharing-functionality-inheritance/"/>
    <updated>2014-07-27T15:03:31+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/27/sharing-functionality-inheritance</id>
    <content type="html"><![CDATA[<h4>继承和消息</h4>

<pre><code>class Parent 

    def say_hello   
    puts "Hello from #{self}" 
    end
end
p = Parent.new
p.say_hello
    class Child &lt; Parent # Subclass the parent...

end 
c = Child.new
c.say_hello
produces:
Hello from #&lt;Parent:0x007fb87110fd98&gt;
Hello from #&lt;Child:0x007fb87110fac8&gt;
</code></pre>

<p>superclass的方法返回了一个类的父类</p>

<pre><code>class Parent
end
class Child &lt; Parent
end
Child.superclass # =&gt; Parent
</code></pre>

<p>那么，Parent的superclass是什么</p>

<pre><code>class Parent
end
Parent.superclass # =&gt; Object
</code></pre>

<p>继续探究</p>

<pre><code>Object.superclass # =&gt; BasicObject
BasicObject.superclass.inspect # =&gt; "nil"
</code></pre>

<p>我们可以看到在继承体系中BasicObject是root class</p>

<h4>Modules</h4>

<p>Modules提供了一种将方法，类和常量聚合在同一空间名下的方式,Modules提供了两大优势</p>

<ol>
<li>Modules提供了一个命名空间，并且防止了命名冲突</li>
<li><p>Modules支持mixin的功能</p>

<pre><code> //trig.rb
 module Trig
     PI = 3.141592654 

     def Trig.sin(x)
     # ..
     end
     def Trig.cos(x) 

         # ..
     end 
 end
 //moral.rb
 module Moral
     VERY_BAD = 0
     BAD =1
     def Moral.sin(badness)
     # ...
     end 
 end
</code></pre>

<p>来看看如何使用它们</p>

<pre><code>  require_relative 'trig' 
  require_relative 'moral'
  y = Trig.sin(Trig::PI/4)
  wrongdoing = Moral.sin(Moral::VERY_BAD)
</code></pre>

<h4>Mixins</h4>

<p>Modules还有另外一个很好用的功能，它们可以在很大程序上避免继承的使用,这种方式叫mixin.
从以上的module的demo中我们可以看到，如果我们定义modules的方法，这些方法前面加了module的名字,如果你想到了类方法，那么你可能会想&#8221;我是否能在module里定义instance方法&#8221;!好问题，一个module不能有instances，因为modules不是类，不过你可以将一个module添加到一个类的定义中，这样，所有的modules的instance方法就同类中的instance方法一样可用了，它们mixed in了，实际上 mixed-in 模块有效地充当了superclass的角色
来看下demo</p>

<pre><code>  module Debug 

      def who_am_i?
          "#{self.class.name} (id: #{self.object_id}): #{self.name}"          end
  end
  class Phonograph 
      include Debug 
      attr_reader :name 
      def initialize(name)

      @name = name
  end
  # ...       end
  class EightTrack 
  include Debug 
      attr_reader :name 
      def initialize(name)
      @name = name
  end
  # ...
  end
  ph = Phonograph.new("West End Blues")
  et = EightTrack.new("Surrealistic Pillow")
  ph.who_am_i? # =&gt; "Phonograph (id: 70266478767560): West End Blues" 
  et.who_am_i? # =&gt; "EightTrack (id: 70266478767520): Surrealistic Pillow"
</code></pre></li>
</ol>


<p>mixin的真正威力在mixin的代码开始与使用它的类的代码进行交互时才得以体现出现,我们用Ruby的Mixin Comparable来作一个例子,Comparable mixin为类添加了比较方法(&lt;, &lt;=, ==, >=, 和 >)和between?方法，为了让Comparable工作,Comparable假设所有使用它的类定义了操作符<code>&lt;=&gt;</code></p>

<pre><code>class Person
    include Comparable 
    attr_reader :name
        def initialize(name) 
            @name = name
        end
        def to_s
            "#{@name}" 
        end
        def &lt;=&gt;(other)
            self.name &lt;=&gt; other.name
        end 
    end
p1 = Person.new("Matz") 
p2 = Person.new("Guido")
    p3 = Person.new("Larry") # Compare a couple of names
if p1 &gt; p2
puts "#{p1.name}'s name &gt; #{p2.name}'s name"
end
# Sort an array of Person objects
puts "Sorted list:" 

puts [ p1, p2, p3].sort
</code></pre>

<p>produces:</p>

<pre><code>Matz's name &gt; Guido's name
Sorted list:
Guido
Larry
Matz
</code></pre>

<h4>Iterators and the Enumerable Module</h4>

<p>Ruby的collections类(Array, Hash等)支持许多针对collections的操作:遍历，排序等，你可能会想:&ldquo;如果我的类也支持这些操作该多好&rdquo;</p>

<p>好消息是，由于mixins和module Enumberable的存在,你的类能支持所有的这些特性，你需要做的只是写一个each的迭代器，依次返回你的collection里的元素，然后include Enumerable,这样你的类就支持map,include?,find_all?这些方法了，如果在你的collection里的对象用<code>&lt;=&gt;</code>来实现了一些有意义的排序相关的方法，你也能使用如min,max,sort等的方法</p>

<h4>Composing Modules</h4>

<p>Enumerable是一个标准的mixin,实现了针对host class中的each相关的许多方法,其中一个是我们之前提到的inject方法，由于要用inject就得include Enumerable，我们能将它用在任何include Enumerable并且实现了each方法的类里
来看看许多内置类对它的使用</p>

<pre><code>[ 1, 2, 3, 4, 5 ].inject(:+) # =&gt; 15
( 'a'..'m').inject(:+) # =&gt; "abcdefghijklm"
</code></pre>

<p>来看看如何定义我们自己的类来使用Enumerable中的inject</p>

<pre><code>//vowel_finder.rb
class VowelFinder 
    include Enumerable
    def initialize(string)
     @string = string
    end
    def each
        @string.scan(/[aeiou]/) do |vowel| 
        yield vowel
        end 

    end
end vf = VowelFinder.new("the quick brown fox jumped")  vf.inject(:+) # =&gt; "euiooue"
</code></pre>

<p>我们还能将inject的方法封装在module的方法中，如下</p>

<pre><code>module Summable 
    def sum         inject(:+)      end end class Array         include Summable    end class Range         include Summable    end
    require_relative "vowel_finder" 
class VowelFinder
  include Summable
end
[1,2,3,4,5].sum #=&gt;15 

('a'..'m').sum # =&gt; "abcdefghijklm"
vf = VowelFinder.new("the quick brown fox jumped") 

vf.sum # =&gt; "euiooue"#### Instance Variables in Mixins
</code></pre>

<p>从C++转过来的程序员通常会问&#8221;在mixin里的instance variable是如何处理的&#8221;
在Ruby中instace variables是这么工作的
以@开头的变量在当前的对象(self)里创建instace variable
对一个mixin而言,如果你在一个类中include了module,你的类对象将创建module里的instance variable并且可以用attr_reader和friends来定义accessors,比如,以下例子中的Observable module为每一个include它的类都添加了@observer_list的instance variable</p>

<pre><code>//observer_impl.rb

module Observable 

    def observers

        @observer_list ||= []
    end
    def add_observer(obj)
        observers &lt;&lt; obj
    end
    def notify_observers
        observers.each {|o| o.update }
    end 

end
</code></pre>

<p>然而这种方式可能会导致一些不可预知的错误,一个mixin的instance variables可能会与inclde它的host class定义的instance variables相冲突,以下的例子显示了一个使用我们的Observer module的类的例子，很不幸的是，它也定义了一个叫做@observer_list的instance variable,在运行时，这个程序可能会导致某些难以调试的错误</p>

<pre><code>require_relative 'observer_impl' 
class TelescopeScheduler
    # other classes can register to get notifications # when the schedule changes
    include Observable
    def initialize
    @observer_list = [] # folks with telescope time
    end
    def add_viewer(viewer)
        @observer_list &lt;&lt; viewer
    end
    # ...
end
</code></pre>

<p>所以，大部分情况下,mixin modules并不直接使用instance variables,它们用accessors来从client对象获取信息,不过如果你需要创建一个有它自己状态的mixin,你需要确保这些instance variables<code>必须</code>要有惟一的名字，或者也可以创建一个module-level的hash，(key用当前对象的ID表示)来存储instance-specific的data</p>

<pre><code>module Test
    State = {}
    def state=(value)
        State[object_id] = value
    ￼￼end

    def state State[object_id]
    end 
end
class Client 
    include Test
end
c1 = Client.new
c2 = Client.new 
c1.state = 'cat' 
c2.state = 'dog' 
c1.state # =&gt; "cat" 
c2.state # =&gt; "dog"
</code></pre>

<p>使用这种方法的坏处就是，和某个特别的对象关联的数据在此对象被删后并不会马上释放，通常来说，一个需要维护它自己状态的mixin不应该是个mixin，它应该被写成一个类</p>

<h4>Resolving Ambiguous Method Names</h4>

<p>如果多个被include的mixins，此类，此类的父类中有相同的方法该如何处理
Ruby会首选查看一个对象的类中的方法，然后是被include到mixins,然后是superclass以及其中的mixins,如果一个为类include了多个mixins,最后被include的mixin首先被搜索到</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[容器-块-迭代器]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/26/rong-qi-kuai-die-dai-qi/"/>
    <updated>2014-07-26T08:51:21+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/26/rong-qi-kuai-die-dai-qi</id>
    <content type="html"><![CDATA[<h4>数组</h4>

<p>来看看数组是怎么用的</p>

<pre><code>a = [ 3.14159, "pie", 99 ] 
a.class # =&gt; Array 
a.length # =&gt; 3
a[0] # =&gt; 3.14159
a[1] # =&gt; "pie"
a[2] #=&gt;99
a[3] #=&gt;nil
b = Array.new 
b.class # =&gt; Array 

b.length # =&gt; 0 
b[0] = "second"
b[1] = "array"
￼b
a = [ 1, 3, 5, 7, 9 ]
a[-1] # =&gt; 9
a[-2] # =&gt; 7
a[-99] # =&gt; nil
a = [ 1, 3, 5, 7, 9 ] 
a[1,3] #=&gt;[3,5,7] 
a[3, 1] # =&gt; [7] 
a[-3,2] #=&gt;[5,7]
a = [ 1, 3, 5, 7, 9 ] 
a[1..3] #=&gt;[3,5,7] 
a[1...3] # =&gt; [3, 5] 
a[3..3] #=&gt;[7] 

a[-3..-1] # =&gt; [5, 7, 9]

a=[1,3,5,7,9]       #=&gt;[1,3,5,7,9]
a[1] = 'bat'        #=&gt; [1, "bat", 5, 7, 9]
a[-3] = 'cat'       #=&gt; [1, "bat", "cat", 7, 9]
a[3] =[9,8]         #=&gt; [1, "bat", "cat", [9, 8], 9]
a[6] = 99           #=&gt; [1, "bat", "cat", [9, 8], 9, nil, 99]

a = [ 1, 3, 5, 7, 9 ]       #=&gt;[1,3,5,7,9]
a[2, 2] = 'cat'             #=&gt; [1, 3, "cat", 9]
a[2, 0] = 'dog'             #=&gt; [1, 3, "dog", "cat", 9] 
a[1,1]=[9,8, 7]             #=&gt;[1,9,8,7,"dog","cat",9]
a[0..3] = []                #=&gt; ["dog", "cat", 9]
a[5..6] = 99, 98            #=&gt; ["dog", "cat", 9, nil, nil, 99, 98]
</code></pre>

<p>数组有许多有用的方法，使用它们，你能将数组作为栈(stacks),集和(sets),队列(queues),<a href="http://en.wikipedia.org/wiki/Double-ended_queue">dequeues</a>,先进先出的queues
比如,push和pop方法从数组的末端添加和删除元素，所以你能将数组作为栈来使用</p>

<pre><code>stack = []
stack.push "red"
stack.push "green"
stack.push "blue"
stack # =&gt; ["red", "green", "blue"]

stack.pop # =&gt; "blue" 
stack.pop # =&gt; "green" 
stack.pop # =&gt; "red" 
stack #=&gt;[]
</code></pre>

<p>同样地,unshift和shift从数组的起始位置添加和删除元素,结合shift和push，你能构建一个FIFO的队列</p>

<pre><code>queue = []
queue.push "red" 
queue.push "green" 
queue.shift # =&gt; "red" 
queue.shift # =&gt; "green"
</code></pre>

<p>first和last方法返回一个数组的头部和尾部的n个元素</p>

<pre><code>array = [ 1, 2, 3, 4, 5, 6, 7 ] 
array.first(4) # =&gt; [1, 2, 3, 4] 
array.last(4) # =&gt; [4, 5, 6, 7]
</code></pre>

<h4>哈希(字典)同数组一样,哈希也是针对数组引用的以索引查询的集合,不过与数组不同的是，数组的下标只能为整形，而哈希的key则可为symbols,strings,regular expression等</h4>

<pre><code>h = { 'dog' =&gt; 'canine', 'cat' =&gt; 'feline', 'donkey' =&gt; 'asinine' }
h.length # =&gt; 3
h['dog'] # =&gt; "canine"
h['cow'] = 'bovine'
h[12] = 'dodecine'
h['cat'] = 99
h           # =&gt; {"dog"=&gt;"canine", "cat"=&gt;99, "donkey"=&gt;"asinine", "cow"=&gt;"bovine",             # .. 12=&gt;"dodecine"}
</code></pre>

<p>从Ruby 1.9开始,如果key是symbols,你可以用以下方式创建hash</p>

<pre><code>h = { :dog =&gt; 'canine', :cat =&gt; 'feline', :donkey =&gt; 'asinine' }
</code></pre>

<p>也可以这么写</p>

<pre><code>h = { dog: 'canine', cat: 'feline', donkey: 'asinine' }####用哈希和数组来完成单词的计数
</code></pre>

<p>现在我们要完成一个demo,给定一段文字，从中计算出每个单词出现的频率
我们将问题分成两步</p>

<ol>
<li><p>将这一段文字作为一个字符串，然后返回此字符串里的单词(保存在数组中)</p>

<pre><code> def words_from_string(string) 
     string.downcase.scan(/[\w']+/)
 end
 p words_from_string("But I didn't inhale, he said (emphatically)")
 结果:
 ["but", "i", "didn't", "inhale", "he", "said", "emphatically"]
</code></pre></li>
<li><p>为每一个不同的单词都弄一个计数，这个就用hash来实现</p>

<pre><code>     def count_frequency(word_list) 
     counts = Hash.new(0)
     for word in word_list
         counts[word] += 1
     end
     counts
 end
 p count_frequency(["sparky", "the", "cat", "sat", "on", "the", "mat"]) 
 produces:
 {"sparky"=&gt;1, "the"=&gt;2, "cat"=&gt;1, "sat"=&gt;1, "on"=&gt;1, "mat"=&gt;1}
</code></pre>

<p>最后，计算好了hash后，我们要打印出来，这里我们打算按字数出现频率的升序顺序来打印</p>

<pre><code>  sorted = counts.sort_by {|word, count| count}
</code></pre>

<p>综上，我们的程序如下</p>

<pre><code>  require_relative "words_from_string.rb" 
  require_relative "count_frequency.rb"
  raw_text = %{The problem breaks down into two parts. First, given some text as a string, return a list of words. That sounds like an array. Then, build a count for each distinct word. That sounds like a use for a hash---we can index it with the word and use the corresponding entry to keep a count.}
  word_list = words_from_string(raw_text)
  counts    = count_frequency(word_list)
  sorted    = counts.sort_by {|word, count| count}
  top_five  = sorted.last(5)
</code></pre></li>
</ol>


<p><code>top_five  = sorted.last(5)</code>是一个数组,每一个元素对应着一个key/value的pair,来看看如何遍历它</p>

<pre><code>for i in 0...5 # (this is ugly code--read on 
    word = top_five[i][0] # for a better version) 
    count = top_five[i][1]
puts "#{word}: #{count}"
end
produces:
that:  2
sounds:  2
like:  2
the:  3
a: 6####单元测试
</code></pre>

<p>表面上我们对以上的方法进行单元测试
首先是对<code>words_from_string</code></p>

<pre><code>    require_relative 'words_from_string'
    require 'test/unit'
    class TestWordsFromString &lt; Test::Unit::TestCase
        def test_empty_string
            assert_equal([], words_from_string("")) assert_equal([], words_from_string(" "))
        end
        def test_single_word
            assert_equal(["cat"], words_from_string("cat")) 
            assert_equal(["cat"], words_from_string(" cat "))
        end
        def test_many_words
            assert_equal(["the", "cat", "sat", "on", "the", "mat"],
            words_from_string("the cat sat on the mat")) 
        end

        def test_ignores_punctuation 
            assert_equal(["the", "cat's", "mat"],
            words_from_string("&lt;the!&gt; cat's, -mat-")) 

        end
    end
    produces:
    Run options:
    # Running tests:
    ....
    Finished tests in 0.006458s, 619.3868 tests/s, 929.0802 assertions/s.       4 tests, 6 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>在测试框架中，所有以test开头的方法都会自动运行我们也能测试计算单词出现次数的方法</p>

<pre><code>    require_relative 'count_frequency' 
    require 'test/unit'
    class TestCountFrequency &lt; Test::Unit::TestCase 
        def test_empty_list
            assert_equal({}, count_frequency([]))
        end

            def test_single_word
            assert_equal({"cat" =&gt; 1}, count_frequency(["cat"])) 
        end
        def test_two_different_words
            assert_equal({"cat" =&gt; 1, "sat" =&gt; 1}, count_frequency(["cat", "sat"]))
        end
        def test_two_words_with_adjacent_repeat
            assert_equal({"cat" =&gt; 2, "sat" =&gt; 1}, count_frequency(["cat", "cat", "sat"])) 
        end
        def test_two_words_with_non_adjacent_repeat
            assert_equal({"cat" =&gt; 2, "sat" =&gt; 1}, count_frequency(["cat", "sat", "cat"]))
        end 
    end
    produces:
    Run options:
    # Running tests:
    .....
    Finished tests in 0.006327s, 790.2639 tests/s, 790.2639 assertions/s.       5 tests, 5 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<h4>块和迭代器</h4>

<p>还记得之前遍历top_five的语句吗,实际上，我们可以按如下方式来遍历数组</p>

<pre><code>top_five.each do |word, count| 
    puts "#{word}: #{count}"
end
</code></pre>

<p>each方法就是一个迭代器-一个不断调用块的方法,实际上相较于以上的方法，很多程序员更愿意写成如下形式</p>

<pre><code>puts top_five.map { |word, count| "#{word}: #{count}" }
</code></pre>

<p>假设有以下程序</p>

<pre><code>square = Shape.new(sides: 4) # 假设 Shape 类在其他地方定义了 # .. lots of code
sum = 0
[1, 2, 3, 4].each do |value| 
    square = value * value
    sum += square
end
puts sum现在我们调用
square.draw     //报错
</code></pre>

<p>因为在block里square的值被改变了</p>

<p>我们可以通过将仅作用域仅在块内部的变量放在块的参数列表后面(通过;来分隔)来避免此类现象的发生,如下</p>

<pre><code>[1, 2, 3, 4].each do |value; square| 
    square = value * value
    sum += square
end
</code></pre>

<h5>yield的使用</h5>

<pre><code>def fib_up_to(max) 

    i1, i2 = 1, 1 

    while i1 &lt;= max
    yield i1
        i1, i2 = i2, i1+i2
    end 
end # parallel assignment (i1 = 1 and i2 = 1)

fib_up_to(1000) {|f| print f, " " }
puts
produces:
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</code></pre>

<p>注意以下这行的使用</p>

<pre><code>print f, " "
</code></pre>

<p>一个块也能返回一个值，块最后一个表达式的值为yield执行后的值
这就是Array中的find方法工作的原理</p>

<pre><code>class Array 

    def find
        each do |value|
            return value if yield(value)
        end
    nil
    end 
end [1, 3, 5, 7, 9].find {|v| v*v &gt; 30 } # =&gt; 7
</code></pre>

<p>迭代器collect的使用</p>

<pre><code>["H", "A", "L"].collect {|x| x.succ } # =&gt; ["I", "B", "M"]
</code></pre>

<p>迭代器并不限于访问array和hash中已存在的元素，如我们之前在Fibonacci中看到的,一个迭代器能返回推导后的值,</p>

<pre><code>    yield i1
        i1, i2 = i2, i1+i2
    end 
</code></pre>

<p> 同样的，这种特性也被Ruby用在输入输出类中,这些类返回了一个迭代器接口，这些接口在I/O流中返回了连续的行(或bytes),如下</p>

<pre><code>f = File.open("testfile") 

f.each do |line|
    puts "The line is: #{line}" end
f.close

produces:
The line is: This is line one
The line is: This is line two
The line is: This is line three
The line is: And so on...
</code></pre>

<p>有时你想跟踪block被调用了多少次，这时你可以试试with_index方法,此方法一般是跟在一个迭代器(如each之后)</p>

<pre><code>f = File.open("testfile") 

f.each.with_index do |line, index|
    puts "Line #{index} is: #{line}" 

end
f.close
produces:
Line 0 is: This is line one
Line 1 is: This is line two
</code></pre>

<p>再看一个有用的迭代器</p>

<pre><code>[1,3,5,7].inject(0) {|sum, element| sum+element} # =&gt; 16 
[1,3,5,7].inject(1) {|product, element| product*element} # =&gt; 105
</code></pre>

<p>等价于</p>

<pre><code>[1,3,5,7].inject {|sum, element| sum+element} # =&gt; 16 
[1,3,5,7].inject {|product, element| product*element} # =&gt; 105
</code></pre>

<p>等价于</p>

<pre><code>[1,3,5,7].inject(:+) # =&gt; 16 
[1,3,5,7].inject(:*) # =&gt; 105####Enumberators-外在迭代器
</code></pre>

<p>尽管以上的迭代器有许多好处,不过如果遇到以下情况，你会发现内部迭代器帮不上什么忙</p>

<ol>
<li>如果你要将迭代器当作一个对象时(比如代要将迭代器传给一个方法，这个方法需要访问这个迭代器里的每个元素)</li>
<li><p>同时访问两个Collections的元素
幸运的是，Ruby中有一个内置的Enumerator类，实现了外在的迭代器，可以处理以上说的两种情况
你可以对array或hash来调用to_enum方法来创建一个Enumberator对象</p>

<pre><code>  a = [ 1, 3, "cat" ]
  h = { dog: "canine", fox: "vulpine" }

  # Create Enumerators
  enum_a = a.to_enum
  enum_h = h.to_enum
  enum_a.next # =&gt; 1
  enum_h.next # =&gt; [:dog, "canine"] 

  enum_a.next # =&gt; 3
  enum_h.next # =&gt; [:fox, "vulpine"]
</code></pre></li>
</ol>


<p>许多内在迭代器方法(产生连接的值传给block，如each) 如果不结合block使用的话将返回一个Enumerator对象</p>

<pre><code>    a = [ 1, 3, "cat" ]
    enum_a = a.each # create an Enumerator using an internal iterator
    enum_a.next # =&gt; 1 enum_a.next # =&gt; 3
</code></pre>

<p>Ruby有一个叫做loop的方法，不做任何事情,主要工作就是不断地调用block,通常来说，如果某些条件发生了，block中的代码将跳出循环,但是当你用Enumerator时，loop可以足够聪明地分辨出一个enumerator对象是否遍历了所有的值，如果遍历完了，loop将终止</p>

<pre><code>short_enum = [1, 2, 3].to_enum 
long_enum = ('a'..'z').to_enum
loop do
    puts "#{short_enum.next} - #{long_enum.next}"
end
produces:
1-a 2-b 3-c
</code></pre>

<h4>Enumerators是对象</h4>

<p>Enumberators将某些可执行的代码(迭代的行为)转化成一个对象，这意味着你可以用enumerator来做一些普通的循环无法轻易做到的事情,比如Enumerable模块定义了一个each_with_index方法，这个方法触发了原先的each方法，同时也返回了一个index</p>

<pre><code>result = []
[ 'a', 'b', 'c' ].each_with_index {|item, index| result &lt;&lt; [item, index] }  result # =&gt; [["a", 0], ["b", 1], ["c", 2]]
</code></pre>

<p>如果你想迭代并获取index但又不想用each而想用其他方法来控制迭代又该怎么做呢？比如你想循环string里的每个character,Enumerator派上用场了,如果你不给string的each_char方法一个block,它会返回一个enumerator,然后再调用enumetor的each_with_index方法</p>

<pre><code>result = []
"cat".each_char.each_with_index {|item, index| result &lt;&lt; [item, index] } 

result # =&gt; [["c", 0], ["a", 1], ["t", 2]]
</code></pre>

<p>实际上这是一个很普遍的方法，所以Mats给我们提供了一个方法with_index</p>

<pre><code>result = []
"cat".each_char.with_index {|item, index| result &lt;&lt; [item, index] } 

result # =&gt; [["c", 0], ["a", 1], ["t", 2]]
</code></pre>

<p>我们也可以显式地创建Enumerator对象，这里我们通过调用string的each_char方法来创建，然后我们对enumerator来调用to_s遍历它</p>

<pre><code>enum = "cat".enum_for(:each_char) enum.to_a # =&gt; ["c", "a", "t"]
</code></pre>

<p>如果我们用来构建enumerator的方法中有参数，我们可以将它们传入enum_for</p>

<pre><code>enum_in_threes = (1..10).enum_for(:each_slice, 3) 
enum_in_threes.to_a # =&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
</code></pre>

<p>Enumerator对象也是可enumerable的(也就是说，适应于可enumerable对象的方法也是适用于enumerator的),比如我们可以用Enumerable的first方法</p>

<pre><code>    triangular_numbers = Enumerator.new do |yielder| 


        number = 0
        count = 1
        loop do
            number += count
            count  += 1
            yielder.yield number
        end 
    end
    p triangular_numbers.first(5)
    produces:
    [1, 3, 6, 10, 15]####Enumberators Are Generators and Filters
</code></pre>

<p>Generators</p>

<pre><code>triangular_numbers = Enumerator.new do |yielder| number = 0
    count = 1
            loop do
                number += count
                count += 1
                yielder.yield number
            end

end
5.times { print triangular_numbers.next, " " } 

puts
produces:
1 3 6 10 15
</code></pre>

<p>Filters</p>

<pre><code>triangular_numbers = Enumerator.new do |yielder| # ...
# as before...
# ...
end
def infinite_select(enum, &amp;block) 

Enumerator.new do |yielder|
enum.each do |value|
yielder.yield(value) if block.call(value)
end

end
end
p infinite_select(triangular_numbers) {|val| val % 10 == 0}.first(5)
produces:
[10, 120, 190, 210, 300]
</code></pre>

<p>等价于</p>

<pre><code>triangular_numbers = Enumerator.new do |yielder|
     # ... as before
end
class Enumerator
    def infinite_select(&amp;block)
        Enumerator.new do |yielder| 

            self.each do |value|
                    yielder.yield(value) if block.call(value) 
            end
        end 

    end
end
p triangular_numbers
   .infinite_select {|val| val % 10 == 0}
   .infinite_select {|val| val.to_s =~ /3/ }
   .first(5)
produces:   [300, 630, 1830, 3160, 3240]####Blocks可以是对象
</code></pre>

<p>block被转化成了Proc类的对象并将它存储在类的属性中</p>

<pre><code>class ProcExample
def pass_in_block(&amp;action)
    @stored_proc = action
end
def use_proc(parameter)
    @stored_proc.call(parameter)
end 

end

eg = ProcExample.new    eg.pass_in_block { |param| puts "The parameter is #{param}" } 
eg.use_proc(99)
</code></pre>

<p>如果一个方法返回了一个block对象又如何调用?</p>

<pre><code>def create_block_object(&amp;block) 

block
end

bo = create_block_object { |param| puts "You called me with #{param}" } 
bo.call 99  bo.call "cat"   produces:   You called me with 99   You called me with cat
</code></pre>

<p>实际上这种方式是很有用的，所以Ruby提供了两个方法将一个block转化为一个对象,lambda和Proc.new都接受了一个block来创建一个Proc类的对象</p>

<pre><code>bo = lambda { |param| puts "You called me with #{param}" } 

bo.call 99  bo.call "cat"
produces:
You called me with 99
You called me with cat
</code></pre>

<h4>Blocks Can Be Closures</h4>

<pre><code>def n_times(thing) 

    lambda {|n| thing * n }

end
p1 = n_times(23)
p1.call(3) # =&gt; 69
p1.call(4) # =&gt; 92
p2 = n_times("Hello ")
p2.call(3) # =&gt; "Hello Hello Hello "
Blocks and Iterators • 65
</code></pre>

<p>n_times方法返回了一个Proc对象并且引用了方法的参数，thing,尽管到block被调用时，参数已经超出范围了，参数仍然能被block访问，这叫做closure(上下文的参数在block或Proc的生命周期中仍能被访问)，两看另外一个例子</p>

<pre><code>def power_proc_generator 
    value = 1       lambda { value += value }   end power_proc = power_proc_generator   puts power_proc.call    puts power_proc.call    puts power_proc.call    produces:   2 4 8
</code></pre>

<p>我们可以看到vaue值是一直变化的</p>

<h4>另一种创建Proc对象的方式</h4>

<p>之前我们用以下方式来创建Proc</p>

<pre><code>lambda { |params| ... }
</code></pre>

<p>你也可以用以下方式来创建</p>

<pre><code>-&gt; params { ... }


proc1 = -&gt; arg { puts "In proc1 with #{arg}" }
proc2 = -&gt; arg1, arg2 { puts "In proc2 with #{arg1} and #{arg2}" } 

proc3 = -&gt;(arg1, arg2) { puts "In proc3 with #{arg1} and #{arg2}" }
proc1.call "ant" 

proc2.call "bee", "cat" 

proc3.call "dog", "elk"
    produces:
In proc1 with ant
In proc2 with bee and cat
In proc3 with dog and elk
</code></pre>

<p>比起lambda,&ndash;>的形式看紧凑，特别是当你要传多个Proc对象给一个方法的时候</p>

<pre><code>def my_if(condition, then_clause, else_clause) 

    if condition
        then_clause.call
    else
        else_clause.call
    end 
end
5.times do |val| 
    my_if val &lt; 2,

          -&gt; { puts "#{val} is small" }, 

          -&gt; { puts "#{val} is big" }
end
produces:
0 is small
1 is small
2 is big
3 is big
4 is big
</code></pre>

<h4>Block Parameter Lists</h4>

<pre><code>proc1 = lambda do |a, *b, &amp;block| 
    puts "a = #{a.inspect}"     
    puts "b = #{b.inspect}" 
    block.call  end proc1.call(1, 2, 3, 4) { puts "in block1" } produces:   a=1 b = [2, 3, 4] 

in block1
</code></pre>

<p>另一种形式</p>

<pre><code>proc2 = -&gt; a, *b, &amp;block do 

    puts "a = #{a.inspect}" 

    puts "b = #{b.inspect}" 

    block.call
end
proc2.call(1, 2, 3, 4) { puts "in block2" }
produces:
a=1
b = [2, 3, 4] in block2
￼
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类-对象-变量]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/23/lei-dui-xiang-bian-liang/"/>
    <updated>2014-07-23T21:41:14+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/23/lei-dui-xiang-bian-liang</id>
    <content type="html"><![CDATA[<p>假设有以下文件</p>

<pre><code>        //data.csv

        "Date","ISBN","Price"
        "2013-04-12","978-1-9343561-0-4",39.45
        "2013-04-13","978-1-9343561-6-6",45.67
        "2013-04-14","978-1-9343560-7-4",36.95
</code></pre>

<p>现在我们的任务就是从这个CSV文件中计算出有相同title的书各有多少本，以及书的总价
我们设计了一个BookInStock的类</p>

<pre><code>class BookInStock

end
</code></pre>

<p>用new来创建对象</p>

<pre><code>a_book = BookInStock.new
</code></pre>

<p>以此创建的类无任何信息，我们可以为此类提供一个initialize的方法，此方法能让我们在每个对象都创建好后就设置对象的状态，我们将此状态存储在实例变量中(以@开头),现在我们更新如下</p>

<pre><code>class BookInStock
    def initialize(isbn, price)
        @isbn = isbn
        @price = Float(price)
    end 
end
</code></pre>

<p>initialize是一个特别的方法，当你调用BookInStore.new去创建一个对象的时候,Ruby分配了一些内存给此未初始化的对象，然后调用了initialize的方法，传递了任何传递给new方法的参数，这样就给了你一次设置对象状态的机会</p>

<pre><code>    b1 = BookInStock.new("isbn1", 3) 
p b1

produces:
    #&lt;BookInStock:0x007fac4910f3e0 @isbn="isbn1", @price=3.0&gt;
</code></pre>

<p>p方法能打印出一个对象的内部表示形式(如@isbn, @price)而puts方法只是简单地将字符串输出到标准输出上，当你将一个对象传给puts时，由于puts不知道如何处理，所以它作了一个简单地处理:对象类的名字+:+对象的内存地址,我们可以改变puts的这种输出形式，只要重写to_s即可</p>

<pre><code>class BookInStock
    def initialize(isbn, price)
            @isbn = isbn
            @price = Float(price)
    end
        def to_s
    "ISBN: #{@isbn}, price: #{@price}" 
    end
end
        b1 = BookInStock.new("isbn1", 3)
puts b1
</code></pre>

<p>结果  ISBN: isbn1, price: 3.0</p>

<h5>对象和属性</h5>

<p>以上的@isbn, @price不能访问，无任何意义，可以为它添加get方法</p>

<pre><code>class BookInStock
    def initialize(isbn, price)
        @isbn = isbn
        @price = Float(price)
    end
    def isbn
        @isbn
    end

    def price 
        @price
    end
# ..
end
book = BookInStock.new("isbn1", 12.34) 

puts "ISBN = #{book.isbn}"
puts "Price = #{book.price}"
</code></pre>

<p>结果</p>

<pre><code>    ISBN   = isbn1
Price  = 12.34
</code></pre>

<p>由于get方法的使用是如此频繁,Ruby提供了一个简便的方法，attr_reader能为你创建这些属性的get方法</p>

<pre><code>class BookInStock   
  attr_reader :isbn, :price
    def initialize(isbn, price) 
        @isbn = isbn
        @price = Float(price)
    end     # ..    end book = BookInStock.new("isbn1", 12.34) 

puts "ISBN = #{book.isbn}"
    puts "Price = #{book.price}"
</code></pre>

<p>结果: ISBN   = isbn1  Price  = 12.34对应,attr_reader后面跟的是symbols
这里通常有一个误解，特别是那些学过Java和C#的人,他们认为attr_reader在某种程序上声明了实例变量，实际上是没有的，它只是生成了访问方法，但无声明任何变量，这些变量只有在你使用它们的时候才出现，Ruby是完全让实例变量与访问方法解藕的</p>

<h4>可写属性</h4>

<p>以上我们只是设置了只读方法,现在我看看如何设置可写方法</p>

<pre><code>class BookInStock
    attr_writer :isbn, :price
    def initialize(isbn, price) 

        @isbn = isbn
        @price = Float(price)
    end
    def price=(new_price) 
        @price = new_price
    end
# ...
end

book = BookInStock.new("isbn1", 33.80) 
puts "ISBN = #{book.isbn}"
puts "Price = #{book.price}" 
book.price = book.price * 0.75
puts "New price = #{book.price}"
</code></pre>

<p>结果:</p>

<pre><code>ISBN      = isbn1
Price     = 33.8
New price = 25.349999999999998
</code></pre>

<p>同样的,Ruby也提供了一个创建属性设置方法的捷径，如果你想有一个只写不可读的方法，可以使用attr_writer,不过这种情况极其罕见，如果你想为某个属性设置可读可写的方法，你可以用attr_accessor</p>

<pre><code>    class BookInStock 
    attr_reader :isbn 
    attr_accessor :price
    def initialize(isbn, price) 
        @isbn = isbn
        @price = Float(price)
    end
# ...   end
book = BookInStock.new("isbn1", 33.80) 
puts "ISBN = #{book.isbn}"
puts "Price = #{book.price}" 
book.price = book.price * 0.75
puts "New price = #{book.price}"
结果: ISBN      = isbn1
Price     = 33.8
New price = 25.349999999999998
</code></pre>

<h4>虚属性</h4>

<pre><code>class BookInStock 

    attr_reader :isbn
    attr_accessor :price
    def initialize(isbn, price) 

        @isbn = isbn
        @price = Float(price)
    end
    def price_in_cents 
        Integer(price*100 + 0.5)
    end
# ...
end
</code></pre>

<p>我们看看以下会输出什么</p>

<pre><code>puts "Price in cents = #{book.price_in_cents}"
</code></pre>

<p>结果</p>

<pre><code>rice in cents = 3380
</code></pre>

<p><code>book.price_in_cents</code>表示的就是虚属性，由于<code>price_in_cents</code>不对应任何对象的属性，但我们却提供了访问方法，依然可以通过.的形式访问它,同样的，我们也可以提供一个它的写方法</p>

<pre><code>def price_in_cents=(cents) 

    @price = cents / 100.0  end

book = BookInStock.new("isbn1", 33.80)
puts "Price = #{book.price}"
puts "Price in cents = #{book.price_in_cents}" 


book.price_in_cents = 1234
puts "Price = #{book.price}"
puts "Price in cents = #{book.price_in_cents}"
produces:
Price          = 33.8
Price in cents = 3380
Price          = 12.34
Price in cents = 1234
</code></pre>

<h4>类与其他类的协同工作</h4>

<p>已知BookInStock定义如上,现在不少csv文件，我们需要将csv文件的每一行转为一个BookInStock,并将每一个BookInStock保存到一个数组中，然后计算所有书的总价,所计算的几个csv文件我们通过命令行传入,现在我们将这个程序分成三个rb文件来操作(假设这三个文件在同一目录下)</p>

<ol>
<li><p>book_in_stock.rb</p>

<pre><code> class BookInStock 

     attr_reader :isbn, :price
     def initialize(isbn, price) 
         @isbn = isbn
         @price = Float(price)
     end 
 end
</code></pre></li>
</ol>


<p>2.csv_reader.rb
此文件有两个外部信赖，它需要标准的CSV的库，也需要存储在book_in_stock.rb中的BookInStock的类,我们用require来加载Ruby的CSV库，用require_relative来加载book_in_stock文件</p>

<pre><code>require 'csv'
require_relative 'book_in_stock'

class CsvReader 

    def initialize
        @books_in_stock = []
    end
    def read_in_csv_data(csv_file_name) 
        CSV.foreach(csv_file_name, headers: true) do |row|
            @books_in_stock &lt;&lt; BookInStock.new(row["ISBN"], row["Price"]) 
        end
    end 
end
</code></pre>

<p>3.stock_stats.rb
这是我们的主程序</p>

<pre><code>require_relative 'csv_reader'   reader = CsvReader.new
ARGV.each do |csv_file_name|        STDERR.puts "Processing #{csv_file_name}" 
    reader.read_in_csv_data(csv_file_name)  end
￼￼￼puts "Total value = #{reader.total_value_in_stock}"
</code></pre>

<p>运行程序如下</p>

<pre><code>$ ruby stock_stats.rb data.csv
Processing data.csv
Total value = 122.07000000000001
</code></pre>

<h5>访问控制</h5>

<p>Ruby给你三种访问控制权限</p>

<ul>
<li>Public</li>
<li>Protected</li>
<li>Private
三种访问控制权限与其他语言的一样，不过有一点与其他面向对象的语言很不一样，那就是，Ruby中的访问控制是程序运行后才被确定的，是动态的，而不是静态的，只有当代码执行了访问受限的代码才能知道是否有访问不合法的错误发生

<h6>如何指定访问控制</h6>

<p>有以下两种方法</p>

<pre><code>  class MyClass

      def method1     # 默认是 'public'

      #...

      end

  protected

      def method2

      #....

      end

  private 

      def method3

      #...

      end

  end
</code></pre></li>
</ul>


<p>或</p>

<pre><code>    class MyClass 

        def method1 

        end         def method2             end
# ... and so on       public    :method1, :method4        protected :method2          private   :method3    end
</code></pre>

<h4>变量</h4>

<pre><code>    person = "Tim"
    puts "The object in 'person' is a #{person.class}" 
    puts "The object has an id of #{person.object_id}" 
    puts "and a value of '#{person}'"
    produces:
       The object in 'person' is a String
       The object has an id of 70230663692980
       and a value of 'Tim'
</code></pre>

<p>那么，变量是否是一个对象呢，答案是否定的，一个变量只是一个对象的引用,来看以下例子，一目了然</p>

<pre><code>    person1 = "Tim"

    person2 = person1 

    person1[0] = 'J'
    puts "person1 is #{person1}" 
    puts "person2 is #{person2}"        produces:                      person1 is Jim              person2 is Jim
</code></pre>

<p>你可以用String的
dup方法来创建一个全新的对象</p>

<pre><code>    person1 = "Tim"     person2 = person1.dup person1[0] = "J"      puts "person1 is #{person1}" puts "person2 is #{person2}"       produces:       person1 is Jim      person2 is Tim我们也可以冻结一个对象来避免对它作出修改
    person1 = "Tim"
    person2 = person1
    person1.freeze # prevent modifications to the object person2[0] = "J"
    produces:
            from prog.rb:4:in `&lt;main&gt;'
    prog.rb:4:in `[]=': can't modify frozen String (RuntimeError)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby-new]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/23/ruby-new/"/>
    <updated>2014-07-23T20:11:08+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/23/ruby-new</id>
    <content type="html"><![CDATA[<h4>Ruby中一切皆对象</h4>

<p>创建对象，假设有一个Song的类，按如下方式创建实例</p>

<pre><code>song1 = Song.new("Ruby Tuesday")
song2 = Song.new("Enveloped in Python")
</code></pre>

<p>如何理解一切皆对象，看以下demo</p>

<pre><code>puts "gin joint".length 
puts "Rick".index("c") 
puts 42.even?           //42是否是偶数
puts sam.play(song)
</code></pre>

<p>在java中，如果要算一个值的绝对值，可按如下方式</p>

<pre><code>num = Math.abs(num)
</code></pre>

<p>但在Ruby中，由于一切皆对象，可按如下方式</p>

<pre><code>um = -1234          # =&gt; -1234 
positive = num.abs  # =&gt; 1234
</code></pre>

<p>同样的规则适用于所有的Ruby对象，在C中，你可以写strlen(name)，但在ruby中，你可以写name.length,无比轻松</p>

<h5>Ruby中的方法</h5>

<p>形式如下</p>

<pre><code>def say_goodnight(name)
    result = "Good night, " + name
    return result
end

    # Time for bed...
puts say_goodnight("John-Boy") 
puts say_goodnight("Mary-Ellen")
</code></pre>

<p>无需分号表示每个语句的结尾，只要你把每一条语句都放在一单独的行上    puts say_goodnight(&ldquo;Mary-Ellen&rdquo;)
相当于</p>

<pre><code>puts(say_goodnight("Mary-Ellen"))
</code></pre>

<h5>字符串</h5>

<p>创建字符串有两种方法，一种是单引号括起来的，一种是双引号括起来的,双引号括起来的字符串，ruby需要做更多的工作，首先，ruby会寻找以反斜杠开头的序列，并将它替换为一个二进制的值,如&#8221;\n&#8221;,另外，双引号形式的字符串还需要做的将#{expression}序列替换成expression的值,我们能用它来替换之前我们写的程序</p>

<pre><code>def say_goodnight(name)
    result = "Good night, #{name}" 
    return result
end
puts say_goodnight('Pa') 
produces:   Good night, Pa
</code></pre>

<p>任意的复杂的表达式都能放在#{&hellip;}里，如下</p>

<pre><code>def say_goodnight(name)
    result = "Good night, #{name.capitalize}" 
    return result
end
puts say_goodnight('uncle') 
produces:
Good night, Uncle
</code></pre>

<p>我们还能对以上方法进行简化，ruby方法返回的值是最一个表达式对应的值，所以我们可以不必写临时变量和return语句</p>

<pre><code>    def say_goodnight(name)
    "Good night, #{name.capitalize}"
end
puts say_goodnight('ma') 
produces:
Good night, Ma
</code></pre>

<h4>Ruby的名字</h4>

<p>ruby的命名遵循以下惯例,第一个名字的首字符表示这个名字的使用场合</p>

<ul>
<li>局部变量，方法参数，方法名都 以一个小写字母或下划线开头</li>
<li>全局变量以一个$符开头，对象实例变量以@开头</li>
<li>类变量以两个@@开头</li>
<li><p>类名，模块名，常量必须以大写字母开头
使用的demo如下</p>

<pre><code>  Local Variable:     name fish_and_chips x_axis thx1138 _x _26
  Instance Variable:  @name @point_1 @X @_ @plan9
  Class Variable:     @@total @@symtab @@N @@x_pos @@SINGLE
  Global Variable:   $debug $CUSTOMER $_ $plan9 $Global
  Class Name:         String ActiveRecord MyClass     Constant Name:      FEET_PER_MILE DEBUG
</code></pre>

<h4>数组和哈希字典</h4>

<p>数组</p>

<pre><code>  a = [ 1, 'cat', 3.14 ] # array with three elements 
  puts "The first element is #{a[0]}"
  # set the third element
  a[2] = nil
  puts "The array is now #{a.inspect}"
  produces:
  The first element is 1
  The array is now [1, "cat", nil]
</code></pre>

<p>简便地创建数组的方法</p>

<pre><code>  a = %w{ ant bee cat dog elk } 
  a[0] # =&gt; "ant"
  a[3] # =&gt; "dog"
</code></pre>

<p>哈希字典</p>

<pre><code>  inst_section = {
  'cello' =&gt; 'string', 
  'clarinet' =&gt; 'woodwind', 
  'drum' =&gt; 'percussion', 
  'oboe' =&gt; 'woodwind', 
  'trumpet' =&gt; 'brass', 
  'violin' =&gt; 'string'    }
</code></pre>

<p><code>=&gt;</code>符号的左为key，右为value
在控制台上我们用p而不是puts，因为p可以更显式地打印nil值</p>

<pre><code>  p inst_section['oboe']
  p inst_section['cello']
  p inst_section['bassoon']
</code></pre></li>
</ul>


<p>produces:</p>

<pre><code>    "woodwind"
    "string"
    nil
</code></pre>

<p>默认情况下hash的key如果对应的value不存在，则value的值为nil，我们可以改变这个默认傎</p>

<pre><code>histogram = Hash.new(0)
histogram['ruby'] # =&gt; 0
histogram['ruby'] = histogram['ruby'] + 1 
histogram['ruby'] # =&gt; 1
</code></pre>

<h4>符号(Symbols)</h4>

<p>通常在编程的时候，你需要为某些重要的东西指定一个名字，比如，你也许想要用名字来指示指南针的方向，所以，你可以像以下这么写</p>

<pre><code>NORTH = 1 
EAST =2 
SOUTH = 3 
WEST =4
</code></pre>

<p>定义好之后，你就可以用这些名字而不是数字了</p>

<pre><code>walk(NORTH)
look(EAST)
</code></pre>

<p>然而，很多时候，这些名字对应的数值是不相关的(只要它们是唯一的)你所要做的只是区分这四个方向而已
Ruby提供了一个很简单的替代方案:符号(Symbols).Symbols只是常量名字，不过你无需定义它，并且它们也保证是唯一的，一个符号常量以:开头，紧跟着字符串
walk(:north)
look(:east)
无须为一个symbol赋任何值,Ruby已经为你考虑好了.Ruby保证不管符号出现在你，一个特定和符号总量有相同的值，因此，你可以按如下方式使用symbol</p>

<pre><code>def walk(direction)
    if direction == :north
    # ...
    end
 end
</code></pre>

<p>symbols通常被用来当作hash的key，我们可以将我们之前写的hash写为以下形式</p>

<pre><code>    inst_section = {
    :cello =&gt; 'string', 
    :clarinet =&gt; 'woodwind', 
    :drum =&gt; 'percussion', 
    :oboe =&gt; 'woodwind', 
    :trumpet =&gt; 'brass', 
    :violin =&gt; 'string'
}
</code></pre>

<p>事实上，symbols是如此频繁地被当作hash的键，ruby提供了一个更简洁的语法，你可以用name:value的形式来创建hash，如果key是symbols的话</p>

<pre><code>inst_section = {
    cello: 'string', 
    clarinet: 'woodwind', 
    drum: 'percussion', 
    oboe: 'woodwind', 
    trumpet: 'brass', 
    violin: 'string'
}
puts "An oboe is a #{inst_section[:oboe]} instrument"
produces:
An oboe is a woodwind instrument
</code></pre>

<h4>条件语句</h4>

<p>if语句</p>

<pre><code>today = Time.now
if today.saturday?
    puts "Do chores around the house"
elsif today.sunday?
     puts "Relax"
else
     puts "Go to work" 
end
</code></pre>

<p>produces:</p>

<pre><code>Go to work
</code></pre>

<p>较短的if语句也可以这么写</p>

<pre><code>puts "Danger, Will Robinson" if radiation &gt; 3000
</code></pre>

<p>while语句</p>

<pre><code>while weight &lt; 100 and num_pallets &lt;= 5
         pallet  = next_pallet()
         weight += pallet.weight
         num_pallets += 1
end
</code></pre>

<p>较短的while语句也可以这么写</p>

<pre><code>    square = 4
    square = square*square while square &lt; 1000
</code></pre>

<p>ruby中的许多语句返回一个值，这意味着你可以用它们作为条件判断，比如,内核方法gets从标准输入流中返回下一行或者当到达文件的末尾时会返回nil，由于Ruby有条件语句中将nil视为假的，你可以用以下代码来处理文件对应的行</p>

<pre><code>while line = gets 
    puts line.downcase
end
</code></pre>

<h4>正则表达式</h4>

<pre><code>/\d\d:\d\d:\d\d/    # a time such as 12:34:56
/Perl.*Python/      # Perl, zero or more other chars, then Python
/Perl Python/       # Perl, a space, and Python
/Perl *Python/     # Perl, zero or more spaces, and Python
/Perl +Python/     # Perl, one or more spaces, and Python
/Perl\s+Python/   # Perl, whitespace characters, then Python
/Ruby (Perl|Python)/ # Ruby, a space, and either Perl or Python
</code></pre>

<p>结果if语句使用</p>

<pre><code>line = gets
if line =~ /Perl|Python/
    puts "Scripting language mentioned: #{line}" 
end
</code></pre>

<p>正则表达式的替代方法</p>

<pre><code>line = gets
newline = line.sub(/Perl/, 'Ruby') # replace first 'Perl' with 'Ruby'   newerline =     newline.gsub(/Python/, 'Ruby') # replace every 'Python' with 'Ruby'
</code></pre>

<h4>Blocks和迭代器</h4>

<p>我们首先看看代码块(code blocks),code blocks是一串代码，你能将它与方法调用结合起来,就当它们是参数一样,这是难以置信的强大特性
你用代码块来实现回调(但比java中的匿名内部类简单),把它们像C中的函数指针那样来传递(比C函数指针更简单)，或者实现迭代器的功能
代码块的形式如下</p>

<pre><code>{ puts "Hello" }
</code></pre>

<p>或</p>

<pre><code>do
  club.enroll(person)
  person.socialize
end
</code></pre>

<p>&ldquo;{}&#8221;block主要用在单行中,&#8221;do&hellip;.end&#8221;主要用在多行中
你可以将block放在一个调用方法的尾部</p>

<pre><code>greet { puts "Hi" } //greet是方法
</code></pre>

<p>如果方法有参数，则将block放在这些参数的最后</p>

<pre><code>verbose_greet("Dave", "loyal customer") { puts "Hi" }
</code></pre>

<p>方法可以用Ruby提供的yield来调用block多次</p>

<pre><code>def call_block

    puts "Start of method" 
    yield
    yield
    puts "End of method"
end

    call_block { puts "In the block" }
</code></pre>

<p>打印结果</p>

<pre><code>    Start of method
    In the block
    In the block
    End of method
</code></pre>

<p>调用yield的时候可以带参数,这些参数将被传到block中去，在block中，你将这些被接收的参数用|params&hellip;|的形式列出来,如下</p>

<pre><code>def who_says_what yield("Dave", "hello") 
    yield("Andy", "goodbye")

end
who_says_what {|person, phrase| puts "#{person} says #{phrase}"}
</code></pre>

<p>打印结果</p>

<pre><code>Dave says hello Andy says goodbye
</code></pre>

<p>Code blocks广泛用在ruby的库中用来实现迭代器</p>

<pre><code>    animals = %w( ant bee cat dog ) # create an array
animals.each {|animal| puts animal }    # iterate over the contents
</code></pre>

<p>produces:</p>

<pre><code>ant
bee
cat
dog
</code></pre>

<p>再来看几个例子</p>

<pre><code>    [ 'cat', 'dog', 'horse' ].each {|name| print name, " " } 
5.times { print "*" }
3.upto(6) {|i| print i }
('a'..'e').each {|char| print char }
puts
</code></pre>

<p>produces:</p>

<pre><code>cat dog horse *****3456abcde####读写

printf("Number: %5.2f,\nString: %s\n", 1.23, "hello")
</code></pre>

<p>produces:    Number:  1.23,    String: hello有很多方法可以将输入读入程序中，最常见的gets方法，它返回标准输入流的下一行</p>

<pre><code>line = gets print line
</code></pre>

<h4>命令行参数</h4>

<p>当你从命令行运行一个Ruby程序时，你能传送一些参数给它，你能用两种不同的参数来访问这些参数
首先，ARGV就是这些参数组成的数组，假设有一个叫cmd_line.rb的程序如下</p>

<pre><code>puts "You gave #{ARGV.size} arguments" 
p ARGV
</code></pre>

<p>当我们向此程序传入这些参数时，我们参看到输出结果</p>

<pre><code>$ ruby cmd_line.rb ant bee cat dog 
You gave 4 arguments
["ant", "bee", "cat", "dog"]
</code></pre>

<p>通常，传入的参数是你要处理的文件的名字，这种情况下，你应该用第二种技巧,<code>ARGF</code>,它是一种特别的I/O对象，代表了通过命令行传入的文件名的所有内容, 我们之后再学习它</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Ruby]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/21/chu-shi-ruby/"/>
    <updated>2014-07-21T22:23:15+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/21/chu-shi-ruby</id>
    <content type="html"><![CDATA[<p>在终端中输入irb与ruby交互</p>

<pre><code>    2.1.2 :002 &gt; def sum(n1, n2)
    2.1.2 :003?&gt;   n1+n2
    2.1.2 :004?&gt;   end
     =&gt; :sum
    2.1.2 :005 &gt; sum(3, 4)
     =&gt; 7
</code></pre>

<p>通常我们将ruby程序写在文件里，假设现在有一个myprog.rb的程序如下</p>

<pre><code>    gettingstarted/myprog.rb        puts "Hello, Ruby Programmer"       puts "It is now #{Time.now}"
</code></pre>

<p>现在我们可以敲入以下命令来运行程序</p>

<pre><code>    $ ruby myprog.rb        Hello, Ruby Programmer)     It is noew 2014-07-21 22:27:47 +0800
</code></pre>

<p>在Unix中，我们可以在程序的第一行添加&#8221;shebang&#8221;的符号，如下</p>

<pre><code>    #! /usr/bin/ruby
    puts "Hello, Ruby Programmer" 
    puts "It is now #{Time.now}"
</code></pre>

<p>如果你用<code>chmod+x myprog.rb</code>命令让此文件成为可执行程序，Unix能让你将此文件作为一个程序来运行</p>

<pre><code>    $ ./myprog.rb       Hello, Ruby Programmer      It is now 2013-05-27 12:30:36 -0500####Ruby文档:RDoc和ri
</code></pre>

<p>Ruby库越来越大，已经不可能将有关它们的文档写进一本书中了，ruby的标准库有9000多个！幸运的是，一种为这些方法(类，模块)提供文档的方法是存在的，许多在它们内部写文档的方法是采用一个RDoc的工具
如果一个源文件用RDoc来文档注释，那么它的文档是可以被提取出来并被转化成HTML和ri的形式的
ri是一个浏览本地RDoc的，命令行浏览器，许多ruby的发行版现在用ri程序来安装文档资源
要发现针对某个类的文档，我们可以在命令行敲入<code>ri ClassName</code>的形式来查看,如以下</p>

<pre><code>$ ri GC
----------------------------------------------------------------------------------- 
The GC module provides an interface to Ruby's garbage collection mechanism. Some of the underlying  methods are also available via the ObjectSpace module.           You may obtain information about the operation of the GC through GC::Profiler.    -----------------------------------------------------------------------------------    Class methods:      count, disable, enable, malloc_allocated_size, malloc_allocations,      start, stat, stress, stress=    Instance methods:      garbage_collect
</code></pre>

<p>查看某个指定类的方法</p>

<pre><code>ri GC::enable
--------------------------------------------------------------- GC::enable GC.enable =&gt; true or false   --------------------------------------------------------------------------- Enables garbage collection, returning true if garbage collection was    disabled.   GC.disable  GC.enable   GC.enable   #=&gt; false   #=&gt; true    #=&gt; false   
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第八章-静态库和动态库]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/16/head-first-cdi-ba-zhang-jing-tai-ku-he-dong-tai-ku/"/>
    <updated>2014-07-16T21:54:55+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/16/head-first-cdi-ba-zhang-jing-tai-ku-he-dong-tai-ku</id>
    <content type="html"><![CDATA[<p>这一章中，我们将学习如何创建自己的动态库，并在多个程序中用到同样的代码
来看下以下代码
加密代码</p>

<pre><code>//encyrpt.h
void encrypt(char *message)

//encrypt.c
#include "encrypt.h"    void encrypt(char *message) {       while (*message) {          *message = *message ^ 31; message++;        }    }
</code></pre>

<p>校验代码</p>

<pre><code>//checksum.h
int checksum(char *message);

//checksum.c
#include "checksum.h"   int checksum(char *message) {       int c = 0;      while (*message) {      c += c ^ (int)(*message);       message++; }        return c; 
}
</code></pre>

<p>加密和校验两段代码构成了我们接下来将要进行的密码库的基础
假设我们已经将以上的代码编译成了目标代码</p>

<pre><code>gcc -c encrypt.c -o encrypt.o
gcc -c checksum.c -o checksum.o
</code></pre>

<p>现在我们写一段测试程序</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;encrypt.h&gt; 
#include &lt;checksum.h&gt;   int main() {        char s[] = "Speak friend and enter"; encrypt(s);        printf("Encrypted to '%s'\n", s); printf("Checksum is %i\n", checksum(s)); encrypt(s);      printf("Decrypted back to '%s'\n", s); printf("Checksum is %i\n", checksum(s));     return 0;   }
</code></pre>

<p>当我们编译时，会出现以下错误</p>

<pre><code>gcc test_code.c encrypt.o checksum.o -o test_code 
test_code.c:2:21: error: encrypt.h: No such file or directory 
test_code.c:3:22: error: checksum.h: No such file or directory
</code></pre>

<p>错误在以下两行</p>

<pre><code>#include &lt;encrypt.h&gt; 
#include &lt;checksum.h&gt;
</code></pre>

<p>尖括号将在标准头文件目录中寻找，在Mac或Linux系统中，编译器在以下目录中寻找这些文件</p>

<pre><code>/user/local/include     //此目录下通常存放一些第三方库
/user/include           //此目录通常存放一些操作系统相关的头文件
</code></pre>

<h4>该如何共享代码</h4>

<p>有时你想写一些代码用在很多程序中，无论它们是在不同的文件夹下，还是在整个电脑中，你该如何做呢?
一般来说我们想在多个程序中共享两种文件,头文件(.h)和目标文件(.o),让我们看看如何操作</p>

<h5>共享.h头文件,有以下几种文件</h5>

<ol>
<li><p>将它们存储在标准目录中
如果你将你的头文件拷贝到标准目标如/usr/local/include中，你可以用尖括号来引用它们</p>

<pre><code>  #include&lt;encrypt.h&gt;
</code></pre></li>
<li><p>在include中写下此文件所在的完整路径
假设你的文件存储在/my_header_files目录下,你可以按以下方式来引用代码</p>

<pre><code>  #include "/my_header_files/encrypt.h"
</code></pre></li>
<li><p>你可以告诉编译器去哪来搜寻它们
用gcc编译时加上-I选项</p>

<pre><code>  gcc -I /my_header_files test_code.c ... -o test_code
</code></pre>

-I选项告诉gcc编译器在/my_header_files这个目录下你能找到所需要的头文件，<code>注意</code>，gcc仍将在标准目录中寻找头文件，但是<code>首先</code>它将在-I选项对应的目录中寻找此文件

<h5>通过写完整路径的方式来共享.o目标文件</h5>

<pre><code>  gcc -I/my_header_files test_code.c /my_object_files/encrypt.o /my_object_files/checksum.o -o test_code
</code></pre>

/my_object_files目录就像是存储目标文件的中枢,用目标文件的完整路径意味着你不需要为每一个程序拷贝一份单独的目标文件
如果只有一两个需要共享的目标文件还好，如果有许多目标文件呢，不是要在所有的目标文件前都加上它们的完整路径了?
<code>解决方法</code>:你可以将许多目标文件打包成一个.a文件,这样你一次就能告诉编译器所有目标文件的所在了(都在.a文件里)

<h6>让我们看下如何打包</h6>

<p>我们用过.zip和.tar文件，这些文件包含了多个文件,.a文件与此类似，一个文件包含了多个.o文件
打开命令行，切换到库目录下，比如/usr/lib里。在此目录上，你将看到许多.a文件,有一个nm的命令可以用来查看.a文件里有哪些.o文件
<img src="http://xiekunRonaldo.github.io/images/2014/7/libl.png">
<img src="http://xiekunRonaldo.github.io/images/2014/7/nm.png">
在我们用.a文件编译程序之前,先看看如何将encrypt.o和checksum.o文件存储到一个.a文件里吧
用ar命令来创建一个.a文件</p>

<pre><code>  ar -rcs libhfsecurity.a encrypt.o checksum.o
</code></pre>

<p>rcs三个选项的解释如下
-r表示如果(.a)文件已经存在,文件将被更新
-c表示.a创建成功与否都无任何反馈信息
-s告诉ar在文件的开头创建一个索引
注意到了吗，所有的.a文件都有lib<something>.a形式的命名,名字以lib开头，因为它们是静态库，我们将很快学习到什么是静态库</p></li>
</ol>


<p>创建好了标准库文件后，该如何使用呢</p>

<ul>
<li><p>将它放到一个标准目录如/user/local/lib里
一些码农在确认.a文件能工作后喜欢将.a文件放在一标准库里，在Linux和Mac里/usr/local/lib目录是一个很好的选择，因为这个目录就是专门用来放置你自己的库文件的</p></li>
<li><p>将.a文件放到你自己喜欢放置的库文件目录下,如/my_lib中
既然库创建好了，那我们来看看怎么利用这些库来编译用到这些库的程序</p></li>
<li>如果你将.a文件放到标准库目录中,你可以按以下方式来编译代码
<img src="http://xiekunRonaldo.github.io/images/2014/7/nm.png"></li>
<li><p>如果你是将.a文件放在你自己的库文件目录下，可按以下方式来编译代码</p>

<pre><code> gcc test_code.c -L/my_lib -lhfsecurity -o test_code
</code></pre>

<p>-L选项告诉编译器去哪个目录寻找库文件</p></li>
</ul>


<p>现在有一个搞安全的哥们在用最新的加密库编译一个银行相关的程序时遇到了一点麻烦，他把源码和 ecnrypt，checksum 的源码放在了同一个目录下，他想要在同一个目录下创建一个libhfsecurity.a库并用它去编译程序，你能帮助它修改它的makefile文件吗
这个程序叫band_vault，它用了以下的include语句</p>

<pre><code>#include&lt;encrypt.h&gt;
#include&lt;checksum.h&gt;
</code></pre>

<p>由于用到了尖括号，编译器需要使用用-I选项告知头文件在哪
makefile文件如下
<img src="http://xiekunRonaldo.github.io/images/2014/7/bank_vault_makefile.png"><br/>
-L选项必须出现在源文件后面才行
从.a文件中提取中某个目标文件</p>

<pre><code>ar -x libhfsecurity.a encrypt.o
</code></pre>

<p>再来看一个例子</p>

<pre><code>//hfcal.c
#include &lt;stdio.h&gt; 
#include &lt;hfcal.h&gt;

void display_calories(float weight, float distance, float coeff) {      printf("Weight: %3.2f lbs\n", weight);      printf("Distance: %3.2f miles\n", distance);        printf("Calories burned: %4.2f cal\n", coeff * weight * distance);  }

//elliptical.c
#include &lt;stdio.h&gt;
#include &lt;hfcal.h&gt;  int main() {        display_calories(115.2, 11.3, 0.79);        return 0;   }
</code></pre>

<p>下面我们来看看如何编译代码</p>

<ol>
<li><p>首先，创建hfcal.o文件,hfcal.h头文件存储在./includes</p>

<pre><code> gcc -I./includes -c hfcal.c -o hfcal.o
</code></pre>

<p>-c选项表示只是创建目标文件，不链接</p></li>
<li><p>创建elliptical.o文件</p>

<pre><code> gcc -I./includes -c elliptical.c -o elliptical.o
</code></pre>

<p>同样的，你需要告诉编译器头文件在./includes下的</p></li>
<li><p>你需要从hfcal.o中创建一个.a文件，并将它存储在./libs中</p>

<pre><code> ar -rcs ./libs/libhfcal.a hfcal.o
</code></pre></li>
</ol>


<p>被打包的libhfcal.a文件将被放在./libs目录下</p>

<ol>
<li><p>最后，用elliptical.o和libhfcal.a创建elliptical可执行文件</p>

<pre><code> gcc elliptical.o -L./libs -lhfcal -o elliptical
</code></pre></li>
</ol>


<p>现在你能执行elliptical可执行文件了</p>

<pre><code>&gt; ./elliptical  Weight: 115.20 lbs  Distance: 11.30 miles   Calories burned: 1028.39 cal    &gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第七章笔记-高级函数]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/15/head-first-cdi-qi-zhang-bi-ji-gao-ji-han-shu/"/>
    <updated>2014-07-15T22:11:00+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/15/head-first-cdi-qi-zhang-bi-ji-gao-ji-han-shu</id>
    <content type="html"><![CDATA[<p>导读:这一章我们将学习函数的一些高级特性,如</p>

<ol>
<li>将函数作为一个参数进行传递</li>
<li>用比较函数进行排序</li>
<li>用可变参数的函数让你的代码变得更加灵活</li>
</ol>


<h5>函数指针</h5>

<pre><code>int (*warp_fn)(int);
</code></pre>

<p>将函数指针当作参数传递给函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void find(int (*mactch)(char *)){
</span><span class='line'>  if (match(ADS[i])){
</span><span class='line'>      //char *ADS[] = {"one", "two"};
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>用函数指针来排序</h5>

<p>C标准库里有一个排序指针如下</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/qsort.png"></p>

<p>假设你有以下整形数组，你想按升序排序，该如何写排序函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int scores[] = {543,323,32,554,11,3,112};
</span><span class='line'>int compare_scores(const void* score_a, const void* score_b)
</span><span class='line'>{
</span><span class='line'>  int a = *(int*)score_a; 
</span><span class='line'>  int b = *(int*)score_b;
</span><span class='line'>  return a-b;
</span><span class='line'>}
</span><span class='line'>qsort(scores, 7, sizeof(int), compare_scores);</span></code></pre></td></tr></table></div></figure>


<p>如果是一个char *p[]数组呢，该如何写compare函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int compare_names(const void* a, const void* b){
</span><span class='line'>  char** sa = (char**)a;
</span><span class='line'>  char** sb = (char**)b; 
</span><span class='line'>  return strcmp(*sa, *sb);￼￼￼￼￼￼￼￼
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>函数指针数组</h5>

<pre><code>//dump,second_change, marriage都是函数
void (*replies[])(response) = {dump, second_chance, marriage};
</code></pre>

<p>判断调用的是否是某个函数</p>

<pre><code>enum response_type {DUMP, SECOND_CHANCE, MARRIAGE};
replies[SECOND_CHANCE] == second_chance完整的demo
typedef struct {    char *name; enum response_type type; } response;    enum response_type {DUMP, SECOND_CHANCE, MARRIAGE};
void (*replies[])(response) = {dump, second_chance, marriage};

int main()
{
    response r[] = {            {"Mike", DUMP}, {"Luis", SECOND_CHANCE},            {"Matt", SECOND_CHANCE}, {"William", MARRIAGE}      };
    int i;
    for (i = 0; i &lt; 4; i++){
        (replies[r[i].type])(r[i]);
    }
}
</code></pre>

<h5>可变参函数</h5>

<p>demo1</p>

<pre><code>#include &lt;stdarg.h&gt;
void print_ints(int args, ....){
    va_list ap; 
    va_start(ap, args);
    int i;
    for (i = 0; i &lt; args; i++) {            printf("argument: %i\n", va_arg(ap, int));      }
    va_end(ap);
}
</code></pre>

<p>注:va_end,va_start是宏</p>

<p>demo2</p>

<pre><code>enum drink {    MUDSLIDE, FUZZY_NAVEL, MONKEY_GLAND, ZOMBIE };
printf("Price is %.2f\n", total(3, MONKEY_GLAND, MUDSLIDE, FUZZY_NAVEL));
double total(int args, ...)
{
    double total = 0;       va_list ap;
    va_start(ap, args);             int i;
    for(i = 0; i &lt; args; i++) {         enum drink d = va_arg(ap, enum drink);          total = total + price(d);       }       va_end(ap);     return total;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第六章-数据结构和动态内存]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/13/head-first-cdi-liu-zhang-shu-ju-jie-gou-he-dong-tai-nei-cun/"/>
    <updated>2014-07-13T11:19:10+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/13/head-first-cdi-liu-zhang-shu-ju-jie-gou-he-dong-tai-nei-cun</id>
    <content type="html"><![CDATA[<p>这一章中我们将学习到如何用结构体指针来将自定义的数据类型连接成一个更大更复杂的数据结构，我们通过创建链表来了解结构体指针的用处，也将学习到如何在堆上分配内存，并在你用完之后释放它，我们也将学习到valgrind的使用</p>

<h4>在堆上分配内存以及释放内存</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct island{ 
</span><span class='line'>  char *name;
</span><span class='line'>  char *opens;
</span><span class='line'>  char *closes;
</span><span class='line'>  island *next;   } island;
</span><span class='line'>
</span><span class='line'>#include&lt;stdlib.h&gt;
</span><span class='line'>island *p = malloc(sizeof(island))
</span><span class='line'>free(p);</span></code></pre></td></tr></table></div></figure>


<p>以下函数有何问题</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>island* create(char *name) {
</span><span class='line'>      island *i = malloc(sizeof(island)); 
</span><span class='line'>      i-&gt;name = name;
</span><span class='line'>      i-&gt;opens = "09:00";
</span><span class='line'>      i-&gt;closes = "17:00";
</span><span class='line'>      i-&gt;next = NULL;
</span><span class='line'>      return i; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当在程序里调用如下代码时</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char name[80];fgets(name, 80, stdin);island *p_island0 = create(name); 
</span><span class='line'>fgets(name, 80, stdin);island *p_island1 = create(name);</span></code></pre></td></tr></table></div></figure>


<p>p_island0和p_island1的name是一样的！！！原来是create函数传入的只是name的地址，两者的地址是一样的，你必须用strdup函数copy字符串,故以上create函数的代码中的</p>

<pre><code>i-&gt;name = name;
</code></pre>

<p>可改为</p>

<pre><code>i-&gt;name = strdup(name);
</code></pre>

<p>不过要记得用strdup()拷贝字符串，最后需要用free()将此拷贝字符串release掉</p>

<h3>valgrind可用来检测内存泄漏</h3>

<p>valgrind能模拟在堆上分配的数据，它通过创建模拟的malloc()版本来工作，当你的程序想要分配一些堆上的内存时，valgrind将截获你对malloc()和free()的调用并运行它自己的模拟版本的malloc()和free(),valgrind版本的malloc()将记录调用它的那些代码以及它所分配的那部分内存,当你的程序终止时,valgrind将会报告任何堆上还存在的数据并且告诉你这些数据由哪些代码调用产生的</p>

<h4>准备:添加debug信息</h4>

<p>用valgrind运行之前你不需要对你的代码作任何操作，你甚至不需要重新编译代码，但是为了更好地利用valgrind，代需要确保你的可执行代码包含debug信息，debug信息是在编译代码后嵌入到可执行文件里的额外数据，比如代码对应的行数，如果debug信息存在了，valgrind将能给你许多内存泄漏的具体信息
测试所用程序<a href="https://gist.github.com/xiekunRonaldo/cdde073cac5636270322">spies</a>
用valgrind结合&mdash;leak-check=full选项进行以下测试</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/valgrind1.png"></p>

<p>从上图可以看出，当SPIES退出后，堆上已无对象，再运行一遍试试看，然后告诉程序有一个Hayden Fantucci的嫌疑人会怎样</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/valgrind2.png"></p>

<p>这次,valgrind发现了内存泄漏,从上图可看出，在程序结束时，堆上有19个字节的空间未释放,valgrind告诉你以下信息</p>

<ol>
<li>19个字节的内存分配了但未释放</li>
<li>分配了11次的内存空间，但只释放了10次</li>
<li>这几行给了我们什么线索</li>
<li>为什么是19个字节？说明了什么?
从以个信息可得,&ldquo;Loretta Barnsworth&#8221;占了19个字节,strdup导致了内存泄漏！</li>
<li>valgrind是如何截获对malloc()和free()的调用的
答:malloc()和free() 实际上是标准库函数，不过valgrind包含一个它自己的malloc()和free()版本的标准库函数，当你用valgrind来运行程序时，你的程序将用valgrind的malloc()和free()函数，而非C的标准库函数</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第五章学习笔记]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/13/head-first-cdi-wu-zhang-xue-xi-bi-ji/"/>
    <updated>2014-07-13T09:22:09+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/13/head-first-cdi-wu-zhang-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h4>Union的初始化</h4>

<ol>
<li><p>用.来初始化</p>

<pre><code> typedef union { 
     short count;
     float weight;
     float volume;       } quantity;
 //By name       quantity q = {.weight=1.5};
 //By dot notation
 quantity q;
 q.volume = 3.7;
</code></pre></li>
<li><p>struct也可以按名字(Designated initializer)来进行初始化
         typedef struct {            const char *color;          int gears;          int height;     } bike;     bike b = {.height=17, .gears=21};</p></li>
</ol>


<p>union可以用在struct中</p>

<pre><code>typedef struct {        const char *name;       const char *country;        quantity amount;    } fruit_order;
</code></pre>

<p>你可以通过.或->来访问成员值</p>

<pre><code>fruit_order apples = {"apples", "England", .amount.weight=4.2};
</code></pre>

<p>假设有一下定义</p>

<pre><code>typedef union { 
    float lemon;
    int lime_pieces;    } lemon_lime;
typedef struct {        float tequila;      float cointreau;        lemon_lime citrus;  } margarita;
</code></pre>

<p>则以下定义是错误的</p>

<pre><code>margarita m;    m = {2.0, 1.0, {0.5}};  //编译器会认为是数组
</code></pre>

<p>以下定义才是对的</p>

<pre><code>margarita m = {2.0, 1.0, {0.5}};
</code></pre>

<p>在一个union里，可能会有很多可能的值，但一旦被赋值，你没法知道它存储的值的类型
我们可能为某些字段设定了值却访问了另一个字段，这可能出现大问题,假设有以下程序</p>

<pre><code>#include &lt;stdio.h&gt; 
typedef union { 
  float weight;   int count;    } cupcake;
    int main() {        cupcake order = {2};        printf("Cupcakes quantity: %i\n", order.count);     return 0;   }
</code></pre>

<p>运行程序将会出现以下结果</p>

<pre><code>gcc badunion.c -o badunion &amp;&amp; ./badunion 
Cupcakes quantity: 1073741824可以用enum来避免此类问题
</code></pre>

<h4>Bitfiled</h4>

<p>bitfield能让你指定struct里的field能有几位，你可以按如下方式定义struct</p>

<pre><code>typedef struct {
    unsigned int low_pass_vcf:1;
    unsigned int filter_coupler:1;  } synth;
</code></pre>

<p>用bitfield，你能让每个field都只占一位
如果你有一连串的bitfields,计算机能将它们排列压缩以节省空间，所以如果你有8个1位的bitfields，电脑将会把它们存储到一个字节里
bitfield的不仅可以节省空间，也可以读写某些二进制文件</p>

<ul>
<li>bitfield应该被声明为unsigned int</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C第四章学习笔记]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/01/head-first-cdi-si-zhang-xue-xi-bi-ji/"/>
    <updated>2014-07-01T19:23:15+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/01/head-first-cdi-si-zhang-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p><code>#include &lt;limits.h&gt;</code>此头文件包含一些整型如int和char的值,可打印整型的最大最小值,如</p>

<pre><code>printf("The value of INT_MAX is %i\n", INT_MAX); 
printf("The value of INT_MIN is %i\n", INT_MIN);
</code></pre>

<p><code>#include &lt;float.h&gt;</code>此头文件包含一些浮点型如float和double的值,可打印浮点的最大最小值,如</p>

<pre><code>printf("The value of FLT_MAX is %f\n", FLT_MAX);
printf("The value of FLT_MIN is %.50f\n", FLT_MIN);
</code></pre>

<p>如果你想知道char,short,double或long的具体细节呢,没问题，只要将INT和FLT替换成CHAR,DBL,SHRT,LNG即可
不过你会发现在不同的机器上，这些值都是不一样的，因为C在不同的OS和处理器上用了不同的数据类型，这么做允许它最大限度地利用了硬件的特性,那么C是如何做的呢
当C被发明时，许多机器是8位的，现在，许多机器是32位或64位的，由于C并不指定数据类型的确切大小，这样，它有很好的移植性，随着越来越多的机器被发明出来，C将能够有限地利用它们</p>

<p><code>这里我们说的8位和64位是什么意思</code>
一台计算机的位大小实际上表示多种情况，比如它的CPU指令的大小或者CPU一次能从内存中读取的数据大小，位大小是一台计算机能处理地最优大小
<code>那么这和ints或doubles的大小有何关系呢</code>
如果一台计算机能最优地处理32位的数，那么基本的数据类型，如int也会被设置成32位
<code>floats和doubles是如何存储的</code>
<a href="http://tinyurl.com/6defkv6">http://tinyurl.com/6defkv6</a>
一段代码引发的思考
<img src="http://xiekunRonaldo.github.io/images/2014/7/errorcode.png"></p>

<p>运行以上代码</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/errorcommandline.png"></p>

<p><code>error: conflicting types for 'add_with_tax'</code>此话何解</p>

<p><code>当编译器看到以下的代码时会发生什么</code></p>

<pre><code>printf("Total so far: %.2f\n", add_with_tax(val));
</code></pre>

<p>编译器将看到一个对不认识的函数的调用，它并不抱怨，编译器会猜想它会在源文件的随后部分发现更多此函数的信息，不幸的是，这就是问题所在,编译器会想，这个函数我从来没见过，但我要先记录它以便在源文件的后半部分对它进行处理
<code>问题是编译需要知道此函数的返回类型</code>当然，编译器此时并不知道函数的返回类型，所以它就作 了一个假设，编译器假设此函数返回int值
<code>但当编译器到达此函数的定义时，它将返回一个“conflicting types for ‘add_with_tax’”错误</code>
这是因为编译器认为它看到了两个同名函数，一个是实际存在文件中的函数，一个则是编译器假设的，返回int型的函数
<code>那么如何解决此问题呢，你可能会认为，把函数放在调用代码的前面按正确地顺序书写不就ok了吗</code>
这么做确实可以解决问题，但<code>修改函数的顺序是件很痛苦的事</code>,假设有以下情况，你添加了一个很棒的新函数</p>

<pre><code>int do_whatever(){...}  float do_something_fantastic(int awesome_level) {...} int do_stuff() {  do_something_fantastic(11); }
</code></pre>

<p>此时你改变注意想在do_whatever调用do_something_fantastic函数呢，那你不得不将do_something_fantastic函数移do_whatever前面,很麻烦，更麻烦的是，有些递归函数将在它被定义前调用自己,如</p>

<pre><code>float ping(){
    pong();
}
float pong(){
    ping();
}
</code></pre>

<p>如果你有两个相互调用的函数，其中一个必然会在它定义之前被调用，这样必然性错误，解决方法是
<code>将声明和定义分隔开来</code>,将声明放在头文件(.h)将定义放在实现文件(.c)
<code>要点</code>
* 从以上可得知实际上你无须为返回值为int函数声明
将多个源文件编译成一个可执行程序</p>

<pre><code>gcc message_hider.c encrypt.c -o message_hider
</code></pre>

<p><code>编译</code>   gcc -c *.c</p>

<p><code>链接</code>   gcc *.o -o launch</p>

<p>问题是如果有非常多的源文件，当你修改一个，你需要把所有的这些源文件全都编译一遍，要浪费很多时间!那如何解决呢</p>

<h4>make工具</h4>

<p>make是一种能自动编译你的源文件的一种工具
<img src="http://xiekunRonaldo.github.io/images/2014/7/theater.png">
如上所未，你如何断定thruster.o文件需要重新编译呢，看时间戳，如果thruster.o文件早于thruster.c,thruster.o就需要重新创建了，相当简单的规则，不是吗，既然明白了规则，我们就可以用make工具自动进行此过程，make将会比较源文件和目标文件的时间戳，如果某些目标文件的时间戳早于源文件，则它将对这些源文件重新编译，但在此之前，你需要告诉make这个工具一些信息，包括文件的信赖关系等，你需要确切地告诉它你想要如何编译代码</p>

<h4>make需要知道哪些东西</h4>

<p>如果你想将thruster.c编辑成一个叫thruster.o的目标文件,依赖文件和配方分别是什么,thruster.o是目标文件,因为这是你想要生成的文件，thruster.c就是信赖文件，因为它是编译所需的转化为thruster.o的源文件，那么配方是什么呢，是将thruster.c转化为thruster.o的编译器命令</p>

<pre><code>gcc -c thruster.c
</code></pre>

<p>明白了吗？如果你告诉make工具相应的信赖文件和配方,你就能让make工具知道何时它需要重新编译成thruster.o了
但你可以更进一步，一旦你编译了thruster.o的目标文件，你就将用它创建launch程序了，也就是说，launch文件也可以被设置成一个目标，因为它是你要产生的文件，launch的依赖文件是所有的.o的目标文件，配方是以下命令</p>

<pre><code>gcc *.o -o launch
</code></pre>

<p>一旦make知道了所有的依赖文件和规则，你所要做的就是告诉它去创建launch文件了
<img src="http://xiekunRonaldo.github.io/images/2014/7/make.png"></p>

<p>以下是make文件的内容
<img src="http://xiekunRonaldo.github.io/images/2014/7/makefile.png"></p>

<p>最后输入以下命令
<img src="http://xiekunRonaldo.github.io/images/2014/7/makelaunch.png">
你能看到make能够执行创建launch程序所需的命令，那么我们看看如果你改变了thruster.c文件然后重新执行make命令会发生什么
<img src="http://xiekunRonaldo.github.io/images/2014/7/remake.png">
我们可以看到，它只编译thruster.o了，然后重新链接</p>

<pre><code>注:由于make文件调用OS底层的操作系统，有时同一个make文件并不适用在不同的OS上
</code></pre>

<p>除了编译代码，make也可用作command-line installer,或源码管理工具，实际上，有命令行上你几乎可以把make用在任何你想执行的任务上</p>

<p>如果你觉得make还不够自动化，你可以试试<a href="http://www.gnu.org/software/autoconf/">autoconf</a>用来产生make文件</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First C 第三章学习笔记-创建小工具]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/06/29/head-first-c-di-san-zhang-xue-xi-bi-ji-chuang-jian-%5B%3F%5D-xie-xiao-gong-ju/"/>
    <updated>2014-06-29T18:44:13+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/06/29/head-first-c-di-san-zhang-xue-xi-bi-ji-chuang-jian-[?]-xie-xiao-gong-ju</id>
    <content type="html"><![CDATA[<h3>要点</h3>

<p>Linux/Unix系统有很多小工具,这些小工具执行一些特定的任务，比如读写文件，过滤数据等，这些工具都只负责处理自己的事情，各司其职，无需顾虑其他的工具所做的事，这样做的好处可以如果你需要处理一个比较复杂的任务，你可以将它分割成各个小任务，每个小任务由相应的工具完成，就有效地做到了解耦,同时这么做也使得每个小程序更容易调试</p>

<p>此章介绍我们将学习如何了解命令行参数，处理流信息，重定向，并快速地将各个工具组合起来</p>

<p>本章我们主要以将以下数据格式</p>

<pre><code>42.363327,-71.097588,Speed = 23 
42.363255,-71.096710,Speed = 17
</code></pre>

<p>转换成以下的JSON形式进行讨论分析</p>

<pre><code>[{latitude: 42.363400, longitude: -71.098465, info: 'Speed = 21'},
 {latitude: 42.363327, longitude: -71.097588, info: 'Speed = 23'}, 
 {latitude: 42.363255, longitude: -71.096710, info: 'Speed = 17'},  ...]
</code></pre>

<p>以下程序(geo2json)能从命令行中读取以逗号分隔的行，并将它以JSON的形式展示出来</p>

<pre><code>//geo2json
#include &lt;stdio.h&gt;  int main() {        float latitude;     float longitude;        char info[80]; intstarted= 0 ￼ ￼ ;      puts("data=[");         while (scanf("%f,%f,%79[^\n]", &amp;latitude, &amp;longitude, info) == 3) {         if (started)                printf(",\n");          else                started= 1 ;
        if ((latitude &lt; -90.0) || (latitude &gt; 90.0)) {              printf(“Invalid latitude: %f\n”, latitude);             return 2;
        }           if ((longitude &lt; -180.0) || (longitude &gt; 180.0)) {              printf(“Invalid longitude: %f\n”, longitude);               return 2;           }           printf("{latitude: %f, longitude: %f, info: '%s'}", latitude , longitude , info );      }       puts("\n]");        return 0;   }
</code></pre>

<p>scanf()会返回输入的参数个数</p>

<pre><code>while (scanf("%f,%f,%79[^\n]", , , ) == 3)
</code></pre>

<ul>
<li>注意以上的[^\n]表示第三个输入参数的内容为除换行以外的字符串</li>
</ul>


<p>以上程序让你在键盘上输入GPS数据，将将它们在JSON的形式输出到屏幕上,问题是输入和输出混起来了，如果有许多的数据，你肯定不想在键盘上手动输入，你肯定希望能用一个小工具(geo2json)将大量的数据通过读取文件来获取.</p>

<p>在以上的程序中，你用scanf()和printf()来从键盘中读取数据并将它显示到显示器上，但实际上它们并不直接和键盘和显示器交互，它们用了标准输入(Standard Input)和标准输出(Standard Output)来和相应的输入输出设备交互,输入输出在程序运行的时候由操作系统创建</p>

<p>操作系统决定了数据如何进出标准输入输出的，如果你从终端运行一个程序，操作系统将把所有的按键信息发送给标准输入，如果操作系统从标准输出中获取数据，默认情况下它将把数据输入出显示器上
scanf()和printf()两个函数并不关心数据来自哪里，去向何方，它们从标准输入和标准输出中读写数据
可能你会问，为何这两个函数不直接和键盘，屏幕交互，难道不是更简单吗</p>

<p>程序系统用标准输入和标准输出的形式与程序进行交互有一个很好的理由:
你可以重定向标准输入和标准输出到其他地方，比如文件</p>

<p>你可以用&#8221;&lt;&ldquo;来重定向标准输入:</p>

<pre><code>./geo2json &lt; gpsdata.csv
</code></pre>

<p>&ldquo;&lt;&#8221;告诉操作系统程序的标准输入应与gpsdata.csv文件连接，而非键盘，所以你可以通过文件向程序传送数据</p>

<p>你也可以用&#8221;>&ldquo;来重定向标准输出</p>

<pre><code>./geo2json &lt; gpsdata.csv &gt; output.json
</code></pre>

<p>将你执行以上命令，你将发现在屏幕上没有任何数据，因为结果已经输出到output.json这个文件去了</p>

<p>以上的程序(geo2json)虽然加了错误判断，但如果有非法数据，在最后的输出文件中，一样会有非法数据
如果发生错误，如何发现错误码(以上为2)</p>

<pre><code>echo $?
</code></pre>

<p>如果数据错误了，能有专门针对这些错误的输出该多好!
标准错误(Stand Error)应运而生!它就是专门针对错误信息的输出，默认情况下，标准错误与屏幕相连,以下是默认状态下的三种标准对应设备的图</p>

<p> <img src="http://xiekunRonaldo.github.io/images/2014/6/standardIOE.png"></p>

<p> 也就是说如果重定向了标准出入和标准输出，标准错误仍将发送数据到屏幕上</p>

<p> <img src="http://xiekunRonaldo.github.io/images/2014/6/standardIOE2.png"></p>

<h3>fprintf()输出到一个数据流中(标准输出或标准错误)</h3>

<p>我们已经知道print()将数据输出到标准输出中，实际上print()只是fprintf()的一个特例而已
当你调用</p>

<pre><code>printf("I like Turtles!");
</code></pre>

<p>时，实际上它调用的是</p>

<pre><code>fprintf(stdout, "I like Turtles!");
</code></pre>

<p>以上清楚地显示了字符串&#8221;I like Turtles&#8221;输出到stdout,你可以告诉fprintf()发送数据到stdout或stderr
既然知道了fprintf()的用法，我们就可以修改geo2json了
 <img src="http://xiekunRonaldo.github.io/images/2014/7/updategeo2json.png">
这样错误信息就与标准错误而不是标准输出关联了,重新运行代码，你将看到尽管标准输出重定向到了output.json文件，错误信息仍然打印到屏幕上，这是因为标准错误信息默认就是打印到屏幕上</p>

<p> <img src="http://xiekunRonaldo.github.io/images/2014/7/stderroutput.png"></p>

<p>标准错误的创建其实就是为了将错误信息和正常的输出区分开来，不过要记得，标准错误和标准输出都是输出流，你可以随心所欲地用按自己的想法利用它们</p>

<h4>要点</h4>

<ul>
<li>printf()默认发送数据到标准输出</li>
<li>标准输出默认输出数据到屏幕上</li>
<li>在命令行中你可以用&#8217;>&lsquo;来重定向标准输出,用&#8217;2>&#8217;来重定向标准错</li>
</ul>


<p>在以上处理经纬度数据的程序中，如果你想得到一定范围内的数据，如下图
<img src="http://xiekunRonaldo.github.io/images/2014/7/range.png"></p>

<p>为了不改变geo2json这个工具，你可以另外创建一个工具(称它为bermude吧)来过滤不在以上范围的数据</p>

<pre><code>//bermude
#include &lt;stdio.h&gt;  int main()
{
    float latitude;     float longitude;        char info[80];      while (scanf("%f,%f,%79[^\n]", &amp;latitude, &amp;longitude , info ￼) == 3)
    if (( ￼ ￼ latitude ￼ &gt; ￼ ￼ 26 ￼ ) ￼ ￼ &amp;&amp; ￼ ( ￼ ￼ latitude ￼ &lt; ￼ ￼ 34 ￼ ))     ￼￼￼￼￼￼￼if (( longitude &gt; -76 ) &amp;&amp; ( longitude &lt; -64 )) 
        printf("%f,%f,%s\n", latitude , longitude , info );     ￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼return 0;
}   
</code></pre>

<p>这样，你可以通过管道&#8217;|&lsquo;将&#8221;bermude&#8221;的输出连接到geo2json的标准输入上，进而得到相应的结果</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/pipe.png"></p>

<p>操作系统将处理管道工作的细节，你需要做的只是运行一下以下的命令</p>

<pre><code>bermuda | geo2json
</code></pre>

<p>操作系统将同时运行两个程序，完整的命令操作如下</p>

<pre><code>(./bermuda | ./geo2json) &lt; spooky.csv &gt; output.json
</code></pre>

<p>通过管道将两个程序联合起来一起运行，你可以把两个程序当作一个进行看待，这样，你就能像之前那样重定向标准输出和标准输出了，注意括号是必要的！，这样保证了文件的内容将传到bermuda程序的标准输入中
思考：如果多个程序通过管道连接起来，此时我用&#8221;>&ldquo;和&rdquo;&lt;&ldquo;来重定向标准输入和标准输出，哪一个程序将让它们的输入输出重定向
答:&rdquo;&lt;&ldquo;将把文件的内容传到管道中的第一个程序中,&rdquo;>&ldquo;将从管道中的最后一个程序中获取标准输出</p>

<h4>如果你想将输出传到多个文件中去呢?</h4>

<p>我们已经知道如何用重定向从一个文件中读取数据和写入数据到一个文件中去了，那如果程序想做一些更复杂的，比如发送数据到多个文件中去该如何操作呢？
假设你需要另外一个工具，这个工具将从一个文件中读取一系列的数据，并将数据分割到多个文件中去
<img src="http://xiekunRonaldo.github.io/images/2014/7/threefiles.png">
问题是什么？你最多只能重定向到两个文件中，分别从标准输出和标准错误中重定向，那第三个文件该怎么办呢?</p>

<h4>用FILE</h4>

<p>每一个数据流由一个指向文件的指针表示，你可以用fopen()来创建一个数据流</p>

<pre><code>FILE *in_file = fopen("input.txt", "r");
</code></pre>

<p>以上创建了一个数据流，从一个文件中读取数据</p>

<pre><code>ILE *out_file = fopen("output.txt", "w");以上创建的一个数据流，将写入数据到文件中
</code></pre>

<p>一旦你创建了一个数据流，你可以用fprintf()将输出的数据指向此文件中</p>

<pre><code>fprintf(out_file, "Don't wear %s with %s", "red", "green");
</code></pre>

<p>那如果想从文件中读取数据呢，用fscanf()</p>

<pre><code>fscanf(in_file, "%79[^\n]\n", sentence);
</code></pre>

<p>最后，当你处理完了以上针对文件的数据流操作，你需要关闭它，实际上当程序结束的时候所有的数据流都会自动关闭，不过在不需要它们时手动关闭数据流总量一个好习惯
回到以上的问题，现在我们能把数据输出到3个文件中去了，示例如下</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main() {        char line[80];      FILE *in = fopen("spooky.csv","r");     FILE *file1 = fopen("ufos.csv", “w”);
    FILE *file2 = fopen("disappearances.csv","w");
    FILE *file3 = fopen("others.csv","w");  
    while(fscanf(in,"%79[^\n]\n", line) == 1){
        if (strstr(line, "UFO"))                fprintf (file1, "%s\n", line);          else if (strstr(line, "Disappearance")) 
            fprintf (file2, "%s\n", line);          else fprintf (file3, "%s\n", line);     }
    fclose (file1);         fclose (file2);     fclose (file3);     return 0;
}   
</code></pre>

<p> 程序正常运行了，当你编译并执行以下命令
<img src="http://xiekunRonaldo.github.io/images/2014/7/threefilesok.png"></p>

<p>程序正常运行，并将结果输出到3个文件中
问题是如果你想数据输出到不同的文件(而不是指定的文件)，又该如何操作呢，每次用户都需要重新编译程序吗</p>

<h4>main()函数的参数</h4>

<p>实际上，任何你写的程序都需要给用户改变程序工作方式的灵活性，如果是一个GUI程序，你需要提供它的偏好设置，如果是一个命令行程序，就像我们的categorize工具，它需要提供给用户传送命令行参数的能力
<img src="http://xiekunRonaldo.github.io/images/2014/7/commandlineparam.png">
那么，如何从程序中读取命令行参数呢，目前为止，你用的是main()函数，没有包含任何参数，实际上，你还可以用上main()函数的第二个版本</p>

<pre><code>int main(int argc, char *argv[])
{
    ......Do stuff
}
</code></pre>

<p>以上的main()函数把命令行的参数当作一个字符串数组，实际上，由于C没有内置的字符串类型，它将用一个指针数组来指向这些命令行参数
<img src="http://xiekunRonaldo.github.io/images/2014/7/argv.png"></p>

<p>像C数组一样,你也需要知道一个数组的长度，argc就表示此长度
命令行参数给了你程序很大的灵活性，确实需要仔细考虑下在程序运行时该让用户传哪些参数，它将让你的程序更有价值
以下是使用命令行参数的完整示例</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; int main(int argc, char *argv[]) {      char line[80];
    if (argc != 6) {
        fprintf(stderr, "You need to give 6 arguments\n");
        return 1;
    }

    FILE *in = fopen("spooky.csv", "r");

    FILE *file1 = fopen(argv[2], "w");

    FILE *file2 = fopen(argv[4], "w");

    FILE *file3 = fopen(argv[5], "w");

    while (fscanf(in, "%79[^\n]\n", line) == 1) {
        if (strstr(line, argv[1]))
            fprintf(file1, "%s\n", line);
        else if (strstr(line, argv[3]))
            fprintf(file2, "%s\n", line);
        else 
            fprintf(file3, "%s\n", line);
    }

    fclose(file1);
    fclose(file2);
    fclose(file3); 
    return 0;
}
</code></pre>

<p>运行以上程序，你首选需要以下格式的<code>spooky.csv</code>文件</p>

<pre><code>30.685163,-68.137207,Type=Yeti 28.304380,-74.575195,Type=UFO    29.132971,-71.136475,Type=Ship 28.343065,-62.753906,Type=Elvis  27.868217,-68.005371,Type=Goatsucker 30.496017,-73.333740,Type=Disappearance    26.224447,-71.477051,Type=UFO 29.401320,-66.027832,Type=Ship    37.879536,-69.477539,Type=Elvis
</code></pre>

<p>这样，在命令行中输出以下格式运行程序</p>

<pre><code>categorize UFO aliens.csv Elvis elvises.csv the_rest.csv
</code></pre>

<p>当程序运行后，产生了以下三个文件
<img src="http://xiekunRonaldo.github.io/images/2014/7/3outputfiles.png">
尽管在以上的程序中我们打开关闭程序没有出现错误，在实际操作中是很可能犯错的，幸运的是，如果在打开数据流发生了错误,fopen()将返回0，因此，以上的程序中，你应该将以下的程序</p>

<pre><code>FILE *in = fopen("i_dont_exist.txt", "r");改为
FILE *in;   if (!(in = fopen("dont_exist.txt", "r"))) {     fprintf(stderr, "Can't open the file.\n");      return 1;   }
</code></pre>

<p>很可能你写的程序需要一些选项，如果你创建了一个聊天程序，它需要一些偏好设置，如果你写了一个命令行工具，你可能需要提供类似以下的命令行的一些选项</p>

<pre><code>ps -ae
tail -f logfile.out
</code></pre>

<p>有一个叫做getopt()的库函数能让你更好地处理命令行选项,每次你调用它，它将返回下一个在命令行中的命令行选项
假设你有一个函数，能提供多个命令行选项</p>

<pre><code>rocket_to -e 4 -a Brasilia Tokyo London这个函数将需要两个个选项，其中一个选项需要提供一个值，另一个仅仅表示此选项是否开关,你可以在一个循环中调用getopt()来处理这些选项，如下
</code></pre>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/getopt.png">
在循环中，你用switch来处理每一个合法的选项,字符串&#8221;ae:&ldquo;告知getopt()函数a和e是合法的选项，紧跟在e之后的冒号表示-e后面需要一个的值，getopt()将用optarg变量表示这个值当循环结束，你让argv和argc变量跳过所有的选项，此时它们表示跟随这些选项之后的命令行参数，这样，argv数组表示如下</p>

<p><img src="http://xiekunRonaldo.github.io/images/2014/7/skipargv.png">我们也可以将两个选项结合起来
如用-td而不是-t -d
默认情况下，如果程序在命令行中看到以&#8221;&ndash;&ldquo;开头的命令行，程序将会把它当作命令行选项，如果要避免此种情况，可以在&rdquo;&ndash;&ldquo;前加&mdash;,这样，在&rdquo;&mdash;&ldquo;之后的参数就被当作普通的参数了</p>

<pre><code>set_temperature -c -- -4
</code></pre>

<p>以上的命令行中，-4就被当作普通的参数而非命令行选项</p>
]]></content>
  </entry>
  
</feed>
