
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>AllenToFight Blog</title>
	<meta name="author" content="AllenToFight">

	
	<meta name="description" content="Aug 12th, 2014 iOS Swift 变量定义 常量用let,变量用var 1
2
3
4
var myVariable = 42
myVariable = 50
let myConstant = 42
let explicitDouble: Double = 70 &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="AllenToFight Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://xiekunRonaldo.github.io/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<img src="http://www.gravatar.com/avatar/27a0140c11f18fab9bf284743d2b2b4c?s=160" alt="Profile Picture" style="width: 160px;" />
	
</div>
<hgroup>
  <h1><a href="/">AllenToFight Blog</a></h1>
  
    <h2>Life To Code.</h2>
  
</hgroup>

<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="weibo" href="http://www.weibo.com/1876496750" title="Weibo">Facebook</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-12T21:29:29+08:00" data-updated="true" itemprop="datePublished">Aug 12<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/08/12/swift/" itemprop="url">Swift</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4>变量定义</h4>

<p>常量用let,变量用var</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var myVariable = 42
</span><span class='line'>myVariable = 50
</span><span class='line'>let myConstant = 42
</span><span class='line'>let explicitDouble: Double = 70
</span></code></pre></td></tr></table></div></figure>


<p>变量的值不会自动转化为其他类型的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let label = "The width is "
</span><span class='line'>let width = 94
</span><span class='line'>let widthLabel = label+String(width)</span></code></pre></td></tr></table></div></figure>


<p>String内的值替换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let apples = 3
</span><span class='line'>let oranges = 5
</span><span class='line'>let appleSummary = "I have \(apples) apples.”</span></code></pre></td></tr></table></div></figure>


<p>数组和字典</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var shoppingList = ["catfish", "water", "tulips", "blue paint"]
</span><span class='line'>
</span><span class='line'>shoppingList[1] = "bottle of water"
</span><span class='line'> 
</span><span class='line'>var occupations = [
</span><span class='line'>
</span><span class='line'>    "Malcolm": "Captain",
</span><span class='line'>
</span><span class='line'>    "Kaylee": "Mechanic",
</span><span class='line'>]
</span><span class='line'>occupations["Jayne"] = "Public Relations”
</span><span class='line'>
</span><span class='line'>let emptyArray = String[]()
</span><span class='line'>let emptyDictionary = Dictionary&lt;String, Float&gt;()
</span></code></pre></td></tr></table></div></figure>


<p>如果类型是能推断的，可以用[]创建一个空数组，用[:]创建一个空字典</p>

<h4>条件语句</h4>

<p>if&hellip;else&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let individualScores = [75, 43, 103, 87, 12]
</span><span class='line'>var teamScore = 0
</span><span class='line'>for score in individualScores {
</span><span class='line'>    if score &gt; 50 {
</span><span class='line'>        teamScore += 3
</span><span class='line'>    } else {
</span><span class='line'>        teamScore += 1
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>teamScore</span></code></pre></td></tr></table></div></figure>


<p>注意，在if条件语句中，condition必须是bool表达式，所以类似<code>if score {...}</code>这样的代码是错误的
if和optional value组成的条件表达式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var optionalString: String? = "Hello"
</span><span class='line'>optionalString == nil
</span><span class='line'> 
</span><span class='line'>var optionalName: String? = "John Appleseed"
</span><span class='line'>var greeting = "Hello!"
</span><span class='line'>if let name = optionalName {
</span><span class='line'>    greeting = "Hello, \(name)"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>switch和case语句支持多种类型的比较,不限于integer</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vegetable = "red pepper"
</span><span class='line'>switch vegetable {
</span><span class='line'>case "celery":
</span><span class='line'>    let vegetableComment = "Add some raisins and make ants on a log."
</span><span class='line'>case "cucumber", "watercress":
</span><span class='line'>    let vegetableComment = "That would make a good tea sandwich."
</span><span class='line'>case let x where x.hasSuffix("pepper"):
</span><span class='line'>    let vegetableComment = "Is it a spicy \(x)?"
</span><span class='line'>default:
</span><span class='line'>    let vegetableComment = "Everything tastes good in soup."
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意:执行完case语句，程序就从switch语句里终止了，所以无需break!</p>

<p>遍历dictionary</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let interestingNumbers = [
</span><span class='line'>    "Prime": [2, 3, 5, 7, 11, 13],
</span><span class='line'>    "Fibonacci": [1, 1, 2, 3, 5, 8],
</span><span class='line'>    "Square": [1, 4, 9, 16, 25],
</span><span class='line'>]
</span><span class='line'>var largest = 0
</span><span class='line'>for (kind, numbers) in interestingNumbers {
</span><span class='line'>    for number in numbers {
</span><span class='line'>        if number &gt; largest {
</span><span class='line'>            largest = number
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>largest</span></code></pre></td></tr></table></div></figure>


<p>while语句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var n = 2
</span><span class='line'>while n &lt; 100 {
</span><span class='line'>    n = n * 2
</span><span class='line'>}
</span><span class='line'>n
</span><span class='line'> 
</span><span class='line'>var m = 2
</span><span class='line'>do {
</span><span class='line'>    m = m * 2
</span><span class='line'>} while m &lt; 100
</span><span class='line'>m</span></code></pre></td></tr></table></div></figure>


<p><code>..</code>的妙用,以下两个循环是等价的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var firstForLoop = 0
</span><span class='line'>for i in 0..3 {
</span><span class='line'>    firstForLoop += i
</span><span class='line'>}
</span><span class='line'>firstForLoop
</span><span class='line'> 
</span><span class='line'>var secondForLoop = 0
</span><span class='line'>for var i = 0; i &lt; 3; ++i {
</span><span class='line'>    secondForLoop += 1
</span><span class='line'>}
</span><span class='line'>secondForLoop</span></code></pre></td></tr></table></div></figure>


<h4>函数和闭包</h4>

<p>函数的声明
用->将参数与返回值区分开来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func greet(name: String, day: String) -&gt; String {
</span><span class='line'>    return "Hello \(name), today is \(day)."
</span><span class='line'>}
</span><span class='line'>greet("Bob", "Tuesday")</span></code></pre></td></tr></table></div></figure>


<p>用tuple从函数中返回多个值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func getGasPrices() -&gt; (Double, Double, Double) {
</span><span class='line'>    return (3.59, 3.69, 3.79)
</span><span class='line'>}
</span><span class='line'>getGasPrices()</span></code></pre></td></tr></table></div></figure>


<p>函数也能接收不定数量的参数，将它们封成到一个数组里</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sumOf(numbers: Int...) -&gt; Int {
</span><span class='line'>    var sum = 0
</span><span class='line'>    for number in numbers {
</span><span class='line'>        sum += number
</span><span class='line'>    }
</span><span class='line'>    return sum
</span><span class='line'>}
</span><span class='line'>sumOf()
</span><span class='line'>sumOf(42, 597, 12)</span></code></pre></td></tr></table></div></figure>


<p>函数也能嵌套，内嵌的函数能访问声明在外部函数的变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func returnFifteen() -&gt; Int {
</span><span class='line'>    var y = 10
</span><span class='line'>    func add() {
</span><span class='line'>        y += 5
</span><span class='line'>    }
</span><span class='line'>    add()
</span><span class='line'>    return y
</span><span class='line'>}
</span><span class='line'>returnFifteen()</span></code></pre></td></tr></table></div></figure>


<p>函数是first-class类型，这意味着函数也能返回另一个函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func makeIncrementer() -&gt; (Int -&gt; Int) {
</span><span class='line'>    func addOne(number: Int) -&gt; Int {
</span><span class='line'>        return 1 + number
</span><span class='line'>    }
</span><span class='line'>    return addOne
</span><span class='line'>}
</span><span class='line'>var increment = makeIncrementer()
</span><span class='line'>increment(7)</span></code></pre></td></tr></table></div></figure>


<p>函数的参数也能是函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool {
</span><span class='line'>    for item in list {
</span><span class='line'>        if condition(item) {
</span><span class='line'>            return true
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>}
</span><span class='line'>func lessThanTen(number: Int) -&gt; Bool {
</span><span class='line'>    return number &lt; 10
</span><span class='line'>}
</span><span class='line'>var numbers = [20, 19, 7, 12]
</span><span class='line'>hasAnyMatches(numbers, lessThanTen)</span></code></pre></td></tr></table></div></figure>


<p>函数实际上是闭包的一种特殊形式，我们可以用{}来写一个匿名的闭包,用in来将参数和返回类型区分开来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numbers.map({
</span><span class='line'>    (number: Int) -&gt; Int in
</span><span class='line'>    let result = 3 * number
</span><span class='line'>    return result
</span><span class='line'>    })</span></code></pre></td></tr></table></div></figure>


<p>如果一个closure的类型是已知的，比如已知一个delegate的回调，我们可以省略参数的类型，返回类型或两者都省略,以上可以改写成以下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numbers.map({ number in 3 * number })</span></code></pre></td></tr></table></div></figure>


<p>我们也可以用数字而不是名字来表示参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sort([1, 5, 3, 12, 2]) { $0 &gt; $1 }</span></code></pre></td></tr></table></div></figure>


<h4>对象和类</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Shape {
</span><span class='line'>    var numberOfSides = 0
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        return "A shape with \(numberOfSides) sides."
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var shape = Shape()
</span><span class='line'>shape.numberOfSides = 7
</span><span class='line'>var shapeDescription = shape.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p><code>init</code>的使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class NamedShape {
</span><span class='line'>    var numberOfSides: Int = 0
</span><span class='line'>    var name: String
</span><span class='line'>    
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        return "A shape with \(numberOfSides) sides."
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>每一个property都需要赋值，可以在它声明的时候(如numberOfSlides)也可以在initializer里(如name)
定义deinit来创建一个deinitializer如果你需要在对象被释放前做一些清理工作的话
继承时，如果要重写superclass的方法，必须要在重写的方法前加override</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Square: NamedShape {
</span><span class='line'>    var sideLength: Double
</span><span class='line'>    
</span><span class='line'>    init(sideLength: Double, name: String) {
</span><span class='line'>        self.sideLength = sideLength
</span><span class='line'>        super.init(name: name)
</span><span class='line'>        numberOfSides = 4
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    func area() -&gt;  Double {
</span><span class='line'>        return sideLength * sideLength
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    override func simpleDescription() -&gt; String {
</span><span class='line'>        return "A square with sides of length \(sideLength)."
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let test = Square(sideLength: 5.2, name: "my test square")
</span><span class='line'>test.area()
</span><span class='line'>test.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p>为property定义getter和setter</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class EquilateralTriangle: NamedShape {
</span><span class='line'>    var sideLength: Double = 0.0
</span><span class='line'>    
</span><span class='line'>    init(sideLength: Double, name: String) {
</span><span class='line'>        self.sideLength = sideLength
</span><span class='line'>        super.init(name: name)
</span><span class='line'>        numberOfSides = 3
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    var perimeter: Double {
</span><span class='line'>    get {
</span><span class='line'>        return 3.0 * sideLength
</span><span class='line'>    }
</span><span class='line'>    set {
</span><span class='line'>        sideLength = newValue / 3.0
</span><span class='line'>    }
</span><span class='line'> }
</span><span class='line'> 
</span><span class='line'> override func simpleDescription() -&gt; String {
</span><span class='line'>          return "An equilateral triagle with sides of length \(sideLength)."
</span><span class='line'>      }
</span><span class='line'> }
</span><span class='line'>var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
</span><span class='line'>triangle.perimeter
</span><span class='line'>triangle.perimeter = 9.9
</span><span class='line'>triangle.sideLength</span></code></pre></td></tr></table></div></figure>


<p>在perimeter的setter方法中，新值有一个默认的名字newValue,我们可以在set后的括号里为这个值指定一个名字
如果你无需计算property的值，但需要在设置新值的前后做一些操作，可以用<code>willSet</code>和<code>didSet</code>,比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class TriangleAndSquare {
</span><span class='line'>    var triangle: EquilateralTriangle {
</span><span class='line'>      willSet {
</span><span class='line'>          square.sideLength = newValue.sideLength
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    var square: Square {
</span><span class='line'>      willSet {
</span><span class='line'>          triangle.sideLength = newValue.sideLength
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    init(size: Double, name: String) {
</span><span class='line'>        square = Square(sideLength: size, name: name)
</span><span class='line'>        triangle = EquilateralTriangle(sideLength: size, name: name)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
</span><span class='line'>triangleAndSquare.square.sideLength
</span><span class='line'>triangleAndSquare.triangle.sideLength
</span><span class='line'>triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
</span><span class='line'>triangleAndSquare.triangle.sideLength</span></code></pre></td></tr></table></div></figure>


<p>类方法与函数有一个很重要的区别，类方法里可以为参数指定一个别名,而函数不行，如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Counter {
</span><span class='line'>    var count: Int = 0
</span><span class='line'>    func incrementBy(amount: Int, numberOfTimes times: Int) {
</span><span class='line'>        count += amount * times
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var counter = Counter()
</span><span class='line'>counter.incrementBy(2, numberOfTimes: 7)</span></code></pre></td></tr></table></div></figure>


<p>当与optional values工作时，你可以在有关方法，属性和[]操作前写一个<code>?</code>如果在?前的值为nil,则一切在？后的操作都被忽略了，整个表达式的值也就是nil了，否则optional value unwrapped,所有?后表达式对应的值为optional value,无论如何，整个表达式的值都是optional value</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
</span><span class='line'>let sideLength = optionalSquare?.sideLength</span></code></pre></td></tr></table></div></figure>


<h4>Enumerations and Structures</h4>

<p>像类和其他类型一样,enumerations可以有方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Rank: Int {
</span><span class='line'>    case Ace = 1  //也可以用字符串或符点型来指定枚举的类型
</span><span class='line'>    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
</span><span class='line'>    case Jack, Queen, King
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        switch self {
</span><span class='line'>        case .Ace:
</span><span class='line'>            return "ace"
</span><span class='line'>        case .Jack:
</span><span class='line'>            return "jack"
</span><span class='line'>        case .Queen:
</span><span class='line'>            return "queen"
</span><span class='line'>        case .King:
</span><span class='line'>            return "king"
</span><span class='line'>        default:
</span><span class='line'>            return String(self.toRaw())
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let ace = Rank.Ace
</span><span class='line'>let aceRawValue = ace.toRaw() //1</span></code></pre></td></tr></table></div></figure>


<p>用<code>toRaw</code>和<code>fromRaw</code>函数来对raw value和枚举值进行相互转换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let convertedRank = Rank.fromRaw(3) {
</span><span class='line'>    let threeDescription = convertedRank.simpleDescription()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The member values of an enumeration are actual values, not just another way of writing their raw values.如果没有一个有意义的raw value，你不需要再指定它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Suit {
</span><span class='line'>    case Spades, Hearts, Diamonds, Clubs
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        switch self {
</span><span class='line'>        case .Spades:
</span><span class='line'>            return "spades"
</span><span class='line'>        case .Hearts:
</span><span class='line'>            return "hearts"
</span><span class='line'>        case .Diamonds:
</span><span class='line'>            return "diamonds"
</span><span class='line'>        case .Clubs:
</span><span class='line'>            return "clubs"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let hearts = Suit.Hearts
</span><span class='line'>let heartsDescription = hearts.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p>用struct来创建一个结构,struct支持类的很多方面，如方法和初始化，和类的最大区别是structures总量以copy的形式传递，而class则以引用的形式传递</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Card {
</span><span class='line'>    var rank: Rank
</span><span class='line'>    var suit: Suit
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let threeOfSpades = Card(rank: .Three, suit: .Spades)
</span><span class='line'>let threeOfSpadesDescription = threeOfSpades.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p>Instances of the same enumeration member can have different values associated with them.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum ServerResponse {
</span><span class='line'>    case Result(String, String)
</span><span class='line'>    case Error(String)
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>let success = ServerResponse.Result("6:00 am", "8:09 pm")
</span><span class='line'>let failure = ServerResponse.Error("Out of cheese.")
</span><span class='line'> 
</span><span class='line'>switch success {
</span><span class='line'>case let .Result(sunrise, sunset):
</span><span class='line'>    let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)."
</span><span class='line'>case let .Error(error):
</span><span class='line'>    let serverResponse = "Failure...  \(error)"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意sunrise和sunset如何匹配switch中case的条件而从ServerResponse里值取出来的</p>

<h4>协议和Extensions</h4>

<p>用<code>protocol</code>来声明一个协议</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol ExampleProtocol {
</span><span class='line'>    var simpleDescription: String { get }
</span><span class='line'>    mutating func adjust()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>class SimpleClass: ExampleProtocol {
</span><span class='line'>    var simpleDescription: String = "A very simple class."
</span><span class='line'>    var anotherProperty: Int = 69105
</span><span class='line'>    func adjust() {
</span><span class='line'>        simpleDescription += "  Now 100% adjusted."
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var a = SimpleClass()
</span><span class='line'>a.adjust()
</span><span class='line'>let aDescription = a.simpleDescription
</span><span class='line'> 
</span><span class='line'>struct SimpleStructure: ExampleProtocol {
</span><span class='line'>    var simpleDescription: String = "A simple structure"
</span><span class='line'>    mutating func adjust() {
</span><span class='line'>        simpleDescription += " (adjusted)"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var b = SimpleStructure()
</span><span class='line'>b.adjust()
</span><span class='line'>let bDescription = b.simpleDescription</span></code></pre></td></tr></table></div></figure>


<p>注意在struct中mutating的使用,class中的方法无需标记为mutating,因为类中的方法总是可以改变类的
用extensions来为一个已知的类型添加功能，比如新的方法和computed properties</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Int: ExampleProtocol {
</span><span class='line'>    var simpleDescription: String {
</span><span class='line'>    return "The number \(self)"
</span><span class='line'>    }
</span><span class='line'>    mutating func adjust() {
</span><span class='line'>        self += 42
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>7.simpleDescription</span></code></pre></td></tr></table></div></figure>


<p>You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let protocolValue: ExampleProtocol = a
</span><span class='line'>protocolValue.simpleDescription
</span><span class='line'>// protocolValue.anotherProperty  // Uncomment to see the error”</span></code></pre></td></tr></table></div></figure>


<p>尽管protocolValue有一个运行时的类型SimpleClass,但编译器仍把它当作ExampleProtocol的一种类型，也就是说说了定义时协议对应的方法，你不能调用它实际所属类的方法，属性</p>

<h4>Generics</h4>

<p>在尖括号里写一个名字来创建一个generic函数或类型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; ItemType[] {
</span><span class='line'>    var result = ItemType[]()
</span><span class='line'>    for i in 0..times {
</span><span class='line'>        result += item
</span><span class='line'>    }
</span><span class='line'>    return result
</span><span class='line'>}
</span><span class='line'>repeat("knock", 4)</span></code></pre></td></tr></table></div></figure>


<p>我们既可以将这种形式用在函数和方法上，也可以用在类，枚举，结构体的定义上</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Reimplement the Swift standard library's optional type
</span><span class='line'>enum OptionalValue&lt;T&gt; {
</span><span class='line'>    case None
</span><span class='line'>    case Some(T)
</span><span class='line'>}
</span><span class='line'>var possibleInteger: OptionalValue&lt;Int&gt; = .None
</span><span class='line'>possibleInteger = .Some(100)</span></code></pre></td></tr></table></div></figure>


<p>在类型名后加一个where来指定一些必须条件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Bool {
</span><span class='line'>    for lhsItem in lhs {
</span><span class='line'>        for rhsItem in rhs {
</span><span class='line'>            if lhsItem == rhsItem {
</span><span class='line'>                return true
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>}
</span><span class='line'>anyCommonElements([1, 2, 3], [3])</span></code></pre></td></tr></table></div></figure>


<p>练习
Modify the anyCommonElements function to make a function that returns an array of the elements that any two sequences have in common.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element:     Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Array&lt;T.GeneratorType.Element&gt; {
</span><span class='line'>    var toReturn = Array&lt;T.GeneratorType.Element&gt;()
</span><span class='line'>    for lhsItem in lhs {
</span><span class='line'>        for rhsItem in rhs {
</span><span class='line'>            if lhsItem == rhsItem {
</span><span class='line'>                toReturn.append(lhsItem)
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return toReturn
</span><span class='line'>}
</span><span class='line'>anyCommonElements([1, 2, 3], [3])</span></code></pre></td></tr></table></div></figure>


<p>在一些简单的情况下，可以省略where，只在分号后写一个protocol或是类名，&lt;T: Equatable>和<T where T: Equatable>是一样的
Swift是类型安全的语言,如果你的代码希望的是String类型，类型安全将阻止你赋Int值给它</p>

<h4>常量和变量的命名</h4>

<p>我们几乎可以用任何字符来命名常量和变量，包括Unicode字符</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let π = 3.14159
</span><span class='line'>let 你好 = "你好世界"
</span><span class='line'>let 🐶🐮 = "dogcow”</span></code></pre></td></tr></table></div></figure>


<p>一旦你声明了某种类型的常量和变量，你就不能为它赋予其他类型的变量</p>

<h4>打印</h4>

<p>打印变量</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println(friendlyWelcome)</span></code></pre></td></tr></table></div></figure>


<p>打印中包含字符替换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The current value of friendlyWelcome is \(friendlyWelcome)")</span></code></pre></td></tr></table></div></figure>


<h4>注释</h4>

<p>不像C语言中的多行注释，Swift的多行注释是可以嵌套的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* this is the start of the first multiline comment
</span><span class='line'>/* this is the second, nested multiline comment */
</span><span class='line'>this is the end of the first multiline comment */</span></code></pre></td></tr></table></div></figure>


<h4>分号的使用</h4>

<p>如果一行中包含多条语句，就得用分号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let cat = "🐱"; println(cat)
</span><span class='line'>// prints "🐱”</span></code></pre></td></tr></table></div></figure>


<h4>整型</h4>

<ul>
<li>整型范围</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
</span><span class='line'>let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8”</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Int型和UInt
在32位OS上，(U)Int和(U)Int32的大小一样
在64位OS上，(U)Int和(U)Int64的大小一样
只有在你确实需要和OS本身的字大小一样的非整形类型时才用UInt，否则尽量用Int

<h4>浮点型</h4></li>
<li>Double代表了64位的浮点数，有至少15位小数的精度</li>
<li>Float代表了32位，只有6位小数的精度

<h4>Numeric Literals</h4>

<p>整型字面量可以写成以下形式</p></li>
<li>10进制，无前缀</li>
<li>二进度，0b前缀</li>
<li>八进制，0o前缀</li>
<li>十六进制，0x前缀</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let decimalInteger = 17
</span><span class='line'>let binaryInteger = 0b10001       // 17 in binary notation
</span><span class='line'>let octalInteger = 0o21           // 17 in octal notation
</span><span class='line'>let hexadecimalInteger = 0x11     // 17 in hexadecimal notation”</span></code></pre></td></tr></table></div></figure>


<p>浮点型可以是十制的(无前缀),也可以是十六进制的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.25e2 means 1.25 × 102, or 125.0.
</span><span class='line'>1.25e-2 means 1.25 × 10-2, or 0.0125.
</span><span class='line'>0xFp2 means 15 × 2*2, or 60.0.
</span><span class='line'>0xFp-2 means 15 × (2的-2次方), or 3.75.</span></code></pre></td></tr></table></div></figure>


<h4>整型转换</h4>

<p>溢出会报错</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let cannotBeNegative: UInt8 = -1
</span><span class='line'>// UInt8 cannot store negative numbers, and so this will report an error
</span><span class='line'>let tooBig: Int8 = Int8.max + 1
</span><span class='line'>// Int8 cannot store a number larger than its maximum value,
</span><span class='line'>// and so this will also report an error</span></code></pre></td></tr></table></div></figure>


<p>来看以下例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let twoThousand: UInt16 = 2_000
</span><span class='line'>let one: UInt8 = 1
</span><span class='line'>let twoThousandAndOne = twoThousand + UInt16(one)</span></code></pre></td></tr></table></div></figure>


<p>以上的UInt16是必须的,因为两个变量的类型不同</p>

<h4>整形和浮点型的转换</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let three = 3
</span><span class='line'>let pointOneFourOneFiveNine = 0.14159
</span><span class='line'>let pi = Double(three) + pointOneFourOneFiveNine</span></code></pre></td></tr></table></div></figure>


<p>浮点型转为整型，只保留整数,不会出现四舍五入这种情况</p>

<h4>Type Aliases</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typealias AudioSample = UInt16
</span><span class='line'>var maxAmplitudeFound = AudioSample.min</span></code></pre></td></tr></table></div></figure>


<h4>Bool型</h4>

<p>Swift的类型安全阻止了任何非bool型的值自动替换成Bool型的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let i = 1
</span><span class='line'>if i {
</span><span class='line'>    // this example will not compile, and will report an error
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>不过，以下使用方式却是对的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let i = 1
</span><span class='line'>if i == 1 {
</span><span class='line'>    // this example will compile successfully
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Tuples</h4>

<p>tuple将多个值组合一个复合的值，并且这些值可以是不同类型的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let http404Error = (404, "Not Found")
</span><span class='line'>
</span><span class='line'>let (statusCode, statusMessage) = http404Error
</span><span class='line'>println("The status code is \(statusCode)")
</span><span class='line'>// prints "The status code is 404"
</span><span class='line'>println("The status message is \(statusMessage)")
</span><span class='line'>// prints "The status message is Not Found</span></code></pre></td></tr></table></div></figure>


<p>如果你只需要一部分tuple的值 ，你可以用_来忽略你不需要的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let (justTheStatusCode, _) = http404Error
</span><span class='line'>println("The status code is \(justTheStatusCode)")
</span><span class='line'>// prints "The status code is 404</span></code></pre></td></tr></table></div></figure>


<p>也可以用以下方式来获取tuple里的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The status code is \(http404Error.0)")
</span><span class='line'>// prints "The status code is 404"
</span><span class='line'>println("The status message is \(http404Error.1)")
</span><span class='line'>// prints "The status message is Not Found</span></code></pre></td></tr></table></div></figure>


<p>在定义tuple的时候可以为每个element赋值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let http200Status = (statusCode: 200, description: "OK")
</span><span class='line'>println("The status code is \(http200Status.statusCode)")
</span><span class='line'>// prints "The status code is 200"
</span><span class='line'>println("The status message is \(http200Status.description)")
</span><span class='line'>// prints "The status message is OK"</span></code></pre></td></tr></table></div></figure>


<p>注意:Tuples仅仅适用于临时的一组相关的数据,它并不适用于复杂数据类型的创建</p>

<h4>Optionals</h4>

<p>Swift’s optionals let you indicate the absence of a value for any type at all, without the need for special constants.</p>

<h4>Forced Unwrapping</h4>

<p>当我们确定optional<code>确定</code>含有一个值时，我们可以在这个optional的名字后面加一个!来获取它的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if convertedNumber {
</span><span class='line'>    println("\(possibleNumber) has an integer value of \(convertedNumber!)")
</span><span class='line'>} else {
</span><span class='line'>    println("\(possibleNumber) could not be converted to an integer")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Optional Binding</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let constantName = someOptional {
</span><span class='line'>    statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们可以按如下方式重写之前的<code>possibleNumber</code>的例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let actualNumber = possibleNumber.toInt() {
</span><span class='line'>    println("\(possibleNumber) has an integer value of \(actualNumber)")
</span><span class='line'>} else {
</span><span class='line'>    println("\(possibleNumber) could not be converted to an integer")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以赋予一个optional 值为nil,非optional的则不行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var serverResponseCode: Int? = 404
</span><span class='line'>// serverResponseCode contains an actual Int value of 404
</span><span class='line'>serverResponseCode = nil</span></code></pre></td></tr></table></div></figure>


<p>如果在定义一个optional value时不提供一个默认值，则它为nil</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var surveyAnswer: String?
</span><span class='line'>// surveyAnswer is automatically set to nil”</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是swift的nil与oc中的nil不同,oc中的nil是一个指定不存在的对象的指针，而swift中的nil则不是指针，它只是表示某种类型的值不存在，任何类型的optional都能设置为nil，而不仅仅是对象</p>

<h4>Implicitly Unwrapped Optional</h4>

<p>也就是类型后加!,仔细看以下的区别</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let possibleString: String? = "An optional string."
</span><span class='line'>println(possibleString!) // requires an exclamation mark to access its value
</span><span class='line'>// prints "An optional string."
</span><span class='line'> 
</span><span class='line'>let assumedString: String! = "An implicitly unwrapped optional string."
</span><span class='line'>println(assumedString)  // no exclamation mark is needed to access its value
</span><span class='line'>// prints "An implicitly unwrapped optional string.
</span><span class='line'>
</span><span class='line'>if assumedString {
</span><span class='line'>    println(assumedString)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>断言</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let age = -3
</span><span class='line'>assert(age &gt;= 0, "A person's age cannot be less than zero")
</span><span class='line'>// this causes the assertion to trigger, because age is not &gt;= 0</span></code></pre></td></tr></table></div></figure>


<p>也可以不写string</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>assert(age &gt;= 0)</span></code></pre></td></tr></table></div></figure>


<p>注意assert里的string不支持<code>\()</code>形式的替换</p>

<h4>基本操作</h4>

<p>Swift允许你对浮点值进行%的运算
赋值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let b = 10
</span><span class='line'>var a = 5
</span><span class='line'>a = b</span></code></pre></td></tr></table></div></figure>


<p>不过不像C，赋值本身不返回值，所以以下是非法的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if x = y {
</span><span class='line'>    // this is not valid, because x = y does not return a value
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>不像C，Swift默认情况下不允许进行算术运算时的值溢出
两个Character的值，或者一个Character和一个String的值，能相加组成一个新的String的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let dog: Character = "🐶"
</span><span class='line'>let cow: Character = "🐮"
</span><span class='line'>let dogCow = dog + cow
</span><span class='line'>// dogCow is equal to "🐶🐮”</span></code></pre></td></tr></table></div></figure>


<h4>求余运算符%</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-9 % 4   // equals -1</span></code></pre></td></tr></table></div></figure>


<p>除数的符号是被忽略的，也就是说a % b和a % -b的值是一样的
浮点数的求余操作</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>8 % 2.5   // equals 0.5</span></code></pre></td></tr></table></div></figure>


<h4>比较操作符</h4>

<p><code>===</code>可以用来测试两个对象的引用是否指向同一个对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let name = "world"
</span><span class='line'>if name == "world" {
</span><span class='line'>    println("hello, world")
</span><span class='line'>} else {
</span><span class='line'>    println("I'm sorry \(name), but I don't recognize you")
</span><span class='line'>}
</span><span class='line'>// prints "hello, world", because name is indeed equal to "world"</span></code></pre></td></tr></table></div></figure>


<h4>Range操作</h4>

<p>闭区间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for index in 1...5 {
</span><span class='line'>    println("\(index) times 5 is \(index * 5)")
</span><span class='line'>}
</span><span class='line'>// 1 times 5 is 5
</span><span class='line'>// 2 times 5 is 10
</span><span class='line'>// 3 times 5 is 15
</span><span class='line'>// 4 times 5 is 20
</span><span class='line'>// 5 times 5 is 25”</span></code></pre></td></tr></table></div></figure>


<p>开区间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Anna", "Alex", "Brian", "Jack"]
</span><span class='line'>let count = names.count
</span><span class='line'>for i in 0..count {
</span><span class='line'>    println("Person \(i + 1) is called \(names[i])")
</span><span class='line'>}
</span><span class='line'>// Person 1 is called Anna
</span><span class='line'>// Person 2 is called Alex
</span><span class='line'>// Person 3 is called Brian
</span><span class='line'>// Person 4 is called Jack</span></code></pre></td></tr></table></div></figure>


<h4>字符串和字符</h4>

<p>Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.
注意OC中的string相关的API，Swift都的String都能使用</p>

<h5>String Literals</h5>

<ul>
<li>转义字符\0(空字符),\(返斜杆),\t,\n,\r,\&ldquo;,`</li>
<li>单字节的Unicode scalars,\xnn,nn是两位十六进制的数字</li>
<li>两个字节的Unicode scalars,\unnnn,nnnn是一个四位十六进制的数字</li>
<li>四个字节的Unicode scalars,\Unnnnnnnn,nnnnnnnn是八位的十六进制的数字</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"
</span><span class='line'>// "Imagination is more important than knowledge" - Einstein
</span><span class='line'>let dollarSign = "\x24"        // $,  Unicode scalar U+0024
</span><span class='line'>let blackHeart = "\u2665"      // ♥,  Unicode scalar U+2665
</span><span class='line'>let sparklingHeart = "\U0001F496"  // 💖, Unicode scalar U+1F496”</span></code></pre></td></tr></table></div></figure>


<h4>初始化一个空字符串</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var emptyString = ""               // empty string literal
</span><span class='line'>var anotherEmptyString = String()  // initializer syntax
</span><span class='line'>// these two strings are both empty, and are equivalent to each other</span></code></pre></td></tr></table></div></figure>


<p>判断一个String的值是否是空的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if emptyString.isEmpty {
</span><span class='line'>    println("Nothing to see here")
</span><span class='line'>}
</span><span class='line'>// prints "Nothing to see here</span></code></pre></td></tr></table></div></figure>


<p>你可以在定义一个字符串时用var和let来表示字符串是否可变</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var variableString = "Horse"
</span><span class='line'>variableString += " and carriage"
</span><span class='line'>// variableString is now "Horse and carriage"
</span><span class='line'> 
</span><span class='line'>let constantString = "Highlander"
</span><span class='line'>constantString += " and another Highlander"
</span><span class='line'>// this reports a compile-time error - a constant string cannot be modified</span></code></pre></td></tr></table></div></figure>


<h4>Strings是值类型</h4>

<p>也就是说如果string的值被传入函数或方法，或被赋值时，它是被copy的！幕后，Swift的编译器优化了string的使用，所以copy只有在真正需要的时候才发生,这意味着你无需担心性能总量</p>

<h5>遍历string中的字符</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for character in "Dog!🐶" {
</span><span class='line'>    println(character)
</span><span class='line'>}
</span><span class='line'>// D
</span><span class='line'>// o
</span><span class='line'>// g
</span><span class='line'>// !
</span><span class='line'>// 🐶”</span></code></pre></td></tr></table></div></figure>


<p>创建一个character</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let yenSign: Character = "¥"</span></code></pre></td></tr></table></div></figure>


<h4>计算Characters的个数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
</span><span class='line'>println("unusualMenagerie has \(countElements(unusualMenagerie)) characters")
</span><span class='line'>// prints "unusualMenagerie has 40 characters”</span></code></pre></td></tr></table></div></figure>


<p>不同的Unicode字符或同一Unicode字符的不同表示形式在内存中占的空间不一样，基于此，swift中的字符并不占用同样的内存，所以要计算一个string的长度，我们必须逐个遍历字符</p>

<p><code>Note</code> also that the character count returned by countElements is not always the same as the length property of an NSString that contains the same characters. The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode characters within the string. To reflect this fact, the length property from NSString is called utf16count when it is accessed on a Swift String value.</p>

<h4>连接字符串和字符</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let string1 = "hello"
</span><span class='line'>let string2 = " there"
</span><span class='line'>let character1: Character = "!"
</span><span class='line'>let character2: Character = "?"
</span><span class='line'> 
</span><span class='line'>let stringPlusCharacter = string1 + character1        // equals "hello!"
</span><span class='line'>let stringPlusString = string1 + string2              // equals "hello there"
</span><span class='line'>let characterPlusString = character1 + string1        // equals "!hello"
</span><span class='line'>let characterPlusCharacter = character1 + character2  // equals "!?”</span></code></pre></td></tr></table></div></figure>


<h4>比较字符串</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let quotation = "We're a lot alike, you and I."
</span><span class='line'>let sameQuotation = "We're a lot alike, you and I."
</span><span class='line'>if quotation == sameQuotation {
</span><span class='line'>    println("These two strings are considered equal")
</span><span class='line'>}
</span><span class='line'>// prints "These two strings are considered equal</span></code></pre></td></tr></table></div></figure>


<h5>前缀和后缀的比较</h5>

<p>hasPrefix和hasSuffix
前缀</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let romeoAndJuliet = [
</span><span class='line'>    "Act 1 Scene 1: Verona, A public place",
</span><span class='line'>    "Act 1 Scene 2: Capulet's mansion",
</span><span class='line'>    "Act 1 Scene 3: A room in Capulet's mansion",
</span><span class='line'>    "Act 1 Scene 4: A street outside Capulet's mansion",
</span><span class='line'>    "Act 1 Scene 5: The Great Hall in Capulet's mansion",
</span><span class='line'>    "Act 2 Scene 1: Outside Capulet's mansion",
</span><span class='line'>    "Act 2 Scene 2: Capulet's orchard",
</span><span class='line'>    "Act 2 Scene 3: Outside Friar Lawrence's cell",
</span><span class='line'>    "Act 2 Scene 4: A street in Verona",
</span><span class='line'>    "Act 2 Scene 5: Capulet's mansion",
</span><span class='line'>    "Act 2 Scene 6: Friar Lawrence's cell"
</span><span class='line'>]
</span><span class='line'>
</span><span class='line'>var act1SceneCount = 0
</span><span class='line'>for scene in romeoAndJuliet {
</span><span class='line'>    if scene.hasPrefix("Act 1 ") {
</span><span class='line'>        ++act1SceneCount
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println("There are \(act1SceneCount) scenes in Act 1")
</span><span class='line'>// prints "There are 5 scenes in Act 1</span></code></pre></td></tr></table></div></figure>


<p>后缀</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var mansionCount = 0
</span><span class='line'>var cellCount = 0
</span><span class='line'>for scene in romeoAndJuliet {
</span><span class='line'>    if scene.hasSuffix("Capulet's mansion") {
</span><span class='line'>        ++mansionCount
</span><span class='line'>    } else if scene.hasSuffix("Friar Lawrence's cell") {
</span><span class='line'>        ++cellCount
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
</span><span class='line'>// prints "6 mansion scenes; 2 cell scenes”</span></code></pre></td></tr></table></div></figure>


<h5>大小写转换</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let normal = "Could you help me, please?""
</span><span class='line'>let shouty = normal.uppercaseString
</span><span class='line'>// shouty is equal to "COULD YOU HELP ME, PLEASE?"
</span><span class='line'>let whispered = normal.lowercaseString
</span><span class='line'>// whispered is equal to "could you help me, please?”</span></code></pre></td></tr></table></div></figure>


<h4>Unicode p118</h4>

<h4>Collection 类型</h4>

<h5>Array</h5>

<p>不同于OC中的array(可存储不同类型的对象)，array存储了同类型的对象，无需一定要存储对象，也可存储Int等类型
以下两个定义等价</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var shoppingList: String[] = ["Eggs", "Milk"]
</span><span class='line'>var shoppingList = ["Eggs", "Milk"]</span></code></pre></td></tr></table></div></figure>


<h5>访问或修改array</h5>

<p>计算array的大小</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>“println("The shopping list contains \(shoppingList.count) items.")
</span><span class='line'>// prints "The shopping list contains 2 items.”</span></code></pre></td></tr></table></div></figure>


<p>用isEmpty来判断coun得否为0</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if shoppingList.isEmpty {
</span><span class='line'>    println("The shopping list is empty.")
</span><span class='line'>} else {
</span><span class='line'>    println("The shopping list is not empty.")
</span><span class='line'>}
</span><span class='line'>// prints "The shopping list is not empty."</span></code></pre></td></tr></table></div></figure>


<p>添加元素</p>

<ul>
<li>用append</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList.append("Flour")
</span><span class='line'>// shoppingList now contains 3 items, and someone is making pancakes”</span></code></pre></td></tr></table></div></figure>


<ul>
<li>用+=</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList += "Baking Powder"
</span><span class='line'>// shoppingList now contains 4 items”
</span><span class='line'>
</span><span class='line'>shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
</span><span class='line'>// shoppingList now contains 7 items”</span></code></pre></td></tr></table></div></figure>


<p>用Range来改变数组里一些元素的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList[4...6] = ["Bananas", "Apples"]
</span><span class='line'>// shoppingList now contains 6 items”</span></code></pre></td></tr></table></div></figure>


<p>在某位置插入元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList.insert("Maple Syrup", atIndex: 0)
</span><span class='line'>// shoppingList now contains 7 items
</span><span class='line'>// "Maple Syrup" is now the first item in the list”</span></code></pre></td></tr></table></div></figure>


<p>移除元素</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let mapleSyrup = shoppingList.removeAtIndex(0)
</span><span class='line'>let apples = shoppingList.removeLast()</span></code></pre></td></tr></table></div></figure>


<p>遍历</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for item in shoppingList {
</span><span class='line'>    println(item)
</span><span class='line'>}
</span><span class='line'>// Six eggs
</span><span class='line'>// Milk
</span><span class='line'>// Flour
</span><span class='line'>// Baking Powder
</span><span class='line'>// Bananas”</span></code></pre></td></tr></table></div></figure>


<p>如果你在遍历时需要知道对应的index，可以用以下方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (index, value) in enumerate(shoppingList) {
</span><span class='line'>    println("Item \(index + 1): \(value)")
</span><span class='line'>}
</span><span class='line'>// Item 1: Six eggs
</span><span class='line'>// Item 2: Milk
</span><span class='line'>// Item 3: Flour
</span><span class='line'>// Item 4: Baking Powder
</span><span class='line'>// Item 5: Bananas</span></code></pre></td></tr></table></div></figure>


<h4>创建和初始化Array</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someInts = Int[]()
</span><span class='line'>println("someInts is of type Int[] with \(someInts.count) items.")
</span><span class='line'>// prints "someInts is of type Int[] with 0 items.</span></code></pre></td></tr></table></div></figure>


<p>注意以下例子，虽然someInt=[]不指定任何类型，但从前段代码可知它的元素是Int类型的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>someInts.append(3)
</span><span class='line'>// someInts now contains 1 value of type Int
</span><span class='line'>someInts = []
</span><span class='line'>// someInts is now an empty array, but is still of type Int[]</span></code></pre></td></tr></table></div></figure>


<p>指定default值和数目的初始化</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var threeDoubles = Double[](count: 3, repeatedValue: 0.0)
</span><span class='line'>// threeDoubles is of type Double[], and equals [0.0, 0.0, 0.0]
</span><span class='line'>
</span><span class='line'>var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)
</span><span class='line'>// anotherThreeDoubles is inferred as Double[], and equals [2.5, 2.5, 2.5]</span></code></pre></td></tr></table></div></figure>


<p>最后我们能通过+来将两个数组连成一个</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var sixDoubles = threeDoubles + anotherThreeDoubles
</span><span class='line'>// sixDoubles is inferred as Double[], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]”</span></code></pre></td></tr></table></div></figure>


<h4>字典</h4>

<p>对key的唯一要求是hashable,Enumeration member values without associated values (as described in Enumerations) are also hashable by default.
以下两个定义是等价的，swift能推测出它的类型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]”
</span><span class='line'>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]
</span></code></pre></td></tr></table></div></figure>


<h4>访问和修改字典</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The dictionary of airports contains \(airports.count) items.")
</span><span class='line'>// prints "The dictionary of airports contains 2 items.</span></code></pre></td></tr></table></div></figure>


<p>方法updateValue(forKey:)的使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let oldValue = airports.updateValue("Dublin International", forKey: "DUB") {
</span><span class='line'>    println("The old value for DUB was \(oldValue).")
</span><span class='line'>}
</span><span class='line'>// prints "The old value for DUB was Dublin.</span></code></pre></td></tr></table></div></figure>


<p>注意，此方法对应的是key对应的旧值，返回的是一个optional value
用[]获取的值也是optional vlaue</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let airportName = airports["DUB"] {
</span><span class='line'>    println("The name of the airport is \(airportName).")
</span><span class='line'>} else {
</span><span class='line'>    println("That airport is not in the airports dictionary.")
</span><span class='line'>}
</span><span class='line'>// prints "The name of the airport is Dublin International.</span></code></pre></td></tr></table></div></figure>


<p>我们可以将nil赋予key对应的值来移除此key</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>airports["APL"] = "Apple International"
</span><span class='line'>// "Apple International" is not the real airport for APL, so delete it
</span><span class='line'>airports["APL"] = nil
</span><span class='line'>// APL has now been removed from the dictionary</span></code></pre></td></tr></table></div></figure>


<p>也可以用<code>removeValueForKey</code>方法
此方法返回的是key对应的旧值,或者nil(如果不存在的话)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let removedValue = airports.removeValueForKey("DUB") {
</span><span class='line'>    println("The removed airport's name is \(removedValue).")
</span><span class='line'>} else {
</span><span class='line'>    println("The airports dictionary does not contain a value for DUB.")
</span><span class='line'>}
</span><span class='line'>// prints "The removed airport's name is Dublin International.”</span></code></pre></td></tr></table></div></figure>


<h5>遍历字典</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (airportCode, airportName) in airports {
</span><span class='line'>    println("\(airportCode): \(airportName)")
</span><span class='line'>}
</span><span class='line'>// TYO: Tokyo
</span><span class='line'>// LHR: London Heathrow
</span><span class='line'>
</span><span class='line'>for airportCode in airports.keys {
</span><span class='line'>    println("Airport code: \(airportCode)")
</span><span class='line'>}
</span><span class='line'>// Airport code: TYO
</span><span class='line'>// Airport code: LHR
</span><span class='line'> 
</span><span class='line'>for airportName in airports.values {
</span><span class='line'>    println("Airport name: \(airportName)")
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//用keys或values创建一个数组
</span><span class='line'>let airportCodes = Array(airports.keys)
</span><span class='line'>// airportCodes is ["TYO", "LHR"]
</span><span class='line'> 
</span><span class='line'>let airportNames = Array(airports.values)
</span><span class='line'>// airportNames is ["Tokyo", "London Heathrow"]</span></code></pre></td></tr></table></div></figure>


<h4>创建一个空的字典</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var namesOfIntegers = Dictionary&lt;Int, String&gt;()</span></code></pre></td></tr></table></div></figure>


<p>注意以下,namesIntegers能被推断出是&lt;Int,String></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>namesOfIntegers[16] = "sixteen"
</span><span class='line'>// namesOfIntegers now contains 1 key-value pair
</span><span class='line'>namesOfIntegers = [:]</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>Behind the scenes, Swift’s array and dictionary types are implemented as generic collections</p>

<h4>Mutability Of Collections</h4>

<p>对字典来说,immutability意味着你不能改变一个key对应的值，而对数组来说，你只是不能改变它的大小，但仍然能改变某个index对应的值</p>

<h4>条件语句</h4>

<p>注意,swift的switch中的case后无需跟着break，因为执行完case里的语句就自动break了，cases也能匹配不同的类型，包括range,tuples或转换为某一具体的类型</p>

<h5>For Loops</h5>

<ul>
<li>For-In</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for index in 1...5 {
</span><span class='line'>    println("\(index) times 5 is \(index * 5)")
</span><span class='line'>}
</span><span class='line'>// 1 times 5 is 5
</span><span class='line'>// 2 times 5 is 10
</span><span class='line'>// 3 times 5 is 15
</span><span class='line'>// 4 times 5 is 20
</span><span class='line'>// 5 times 5 is 25”</span></code></pre></td></tr></table></div></figure>


<p>如果你不需要index，可以用<code>_</code>来忽略它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let base = 3
</span><span class='line'>let power = 10
</span><span class='line'>var answer = 1
</span><span class='line'>for _ in 1...power {
</span><span class='line'>    answer *= base
</span><span class='line'>}
</span><span class='line'>println("\(base) to the power of \(power) is \(answer)")
</span><span class='line'>// prints "3 to the power of 10 is 59049</span></code></pre></td></tr></table></div></figure>


<p>array,dictionary,characters的for-in</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Anna", "Alex", "Brian", "Jack"]
</span><span class='line'>for name in names {
</span><span class='line'>    println("Hello, \(name)!")
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
</span><span class='line'>for (animalName, legCount) in numberOfLegs {
</span><span class='line'>    println("\(animalName)s have \(legCount) legs")
</span><span class='line'>}
</span><span class='line'>// spiders have 8 legs
</span><span class='line'>// ants have 6 legs
</span><span class='line'>// cats have 4 legs
</span><span class='line'>
</span><span class='line'>for character in "Hello" {
</span><span class='line'>    println(character)
</span><span class='line'>}
</span><span class='line'>// H
</span><span class='line'>// e
</span><span class='line'>// l
</span><span class='line'>// l
</span><span class='line'>// o</span></code></pre></td></tr></table></div></figure>


<h5>For-Condition-Increment</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for var index = 0; index &lt; 3; ++index {
</span><span class='line'>    println("index is \(index)")
</span><span class='line'>}
</span><span class='line'>// index is 0
</span><span class='line'>// index is 1
</span><span class='line'>// index is 2</span></code></pre></td></tr></table></div></figure>


<p>注意for后无需括号</p>

<h5>条件语句</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var temperatureInFahrenheit = 30
</span><span class='line'>if temperatureInFahrenheit &lt;= 32 {
</span><span class='line'>    println("It's very cold. Consider wearing a scarf.")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>switch语句</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someCharacter: Character = "e"
</span><span class='line'>switch someCharacter {
</span><span class='line'>case "a", "e", "i", "o", "u":
</span><span class='line'>    println("\(someCharacter) is a vowel")
</span><span class='line'>case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
</span><span class='line'>"n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
</span><span class='line'>    println("\(someCharacter) is a consonant")
</span><span class='line'>default:
</span><span class='line'>    println("\(someCharacter) is not a vowel or a consonant")
</span><span class='line'>}
</span><span class='line'>// prints "e is a vowel”</span></code></pre></td></tr></table></div></figure>


<p>注意，以下方式不行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anotherCharacter: Character = "a"
</span><span class='line'>switch anotherCharacter {
</span><span class='line'>case "a":
</span><span class='line'>case "A":
</span><span class='line'>    println("The letter A")
</span><span class='line'>default:
</span><span class='line'>    println("Not the letter A")
</span><span class='line'>}
</span><span class='line'>// this will report a compile-time error</span></code></pre></td></tr></table></div></figure>


<p>每个case里必须对应相应的语句</p>

<h5>Range Matching</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let count = 3_000_000_000_000
</span><span class='line'>let countedThings = "stars in the Milky Way"
</span><span class='line'>var naturalCount: String
</span><span class='line'>switch count {
</span><span class='line'>case 0:
</span><span class='line'>    naturalCount = "no"
</span><span class='line'>case 1...3:
</span><span class='line'>    naturalCount = "a few"
</span><span class='line'>case 4...9:
</span><span class='line'>    naturalCount = "several"
</span><span class='line'>case 10...99:
</span><span class='line'>    naturalCount = "tens of"
</span><span class='line'>case 100...999:
</span><span class='line'>    naturalCount = "hundreds of"
</span><span class='line'>case 1000...999_999:
</span><span class='line'>    naturalCount = "thousands of"
</span><span class='line'>default:
</span><span class='line'>    naturalCount = "millions and millions of"
</span><span class='line'>}
</span><span class='line'>println("There are \(naturalCount) \(countedThings).")
</span><span class='line'>// prints "There are millions and millions of stars in the Milky Way.”</span></code></pre></td></tr></table></div></figure>


<h5>Tuples</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let somePoint = (1, 1)
</span><span class='line'>switch somePoint {
</span><span class='line'>case (0, 0):
</span><span class='line'>    println("(0, 0) is at the origin")
</span><span class='line'>case (_, 0):
</span><span class='line'>    println("(\(somePoint.0), 0) is on the x-axis")
</span><span class='line'>case (0, _):
</span><span class='line'>    println("(0, \(somePoint.1)) is on the y-axis")
</span><span class='line'>case (-2...2, -2...2):
</span><span class='line'>    println("(\(somePoint.0), \(somePoint.1)) is inside the box")
</span><span class='line'>default:
</span><span class='line'>    println("(\(somePoint.0), \(somePoint.1)) is outside of the box")
</span><span class='line'>}
</span><span class='line'>// prints "(1, 1) is inside the box”</span></code></pre></td></tr></table></div></figure>


<h4>Value Bindings</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anotherPoint = (2, 0)
</span><span class='line'>switch anotherPoint {
</span><span class='line'>case (let x, 0):
</span><span class='line'>    println("on the x-axis with an x value of \(x)")
</span><span class='line'>case (0, let y):
</span><span class='line'>    println("on the y-axis with a y value of \(y)")
</span><span class='line'>case let (x, y):
</span><span class='line'>    println("somewhere else at (\(x), \(y))")
</span><span class='line'>}
</span><span class='line'>// prints "on the x-axis with an x value of 2”</span></code></pre></td></tr></table></div></figure>


<h5>where的使用</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let yetAnotherPoint = (1, -1)
</span><span class='line'>switch yetAnotherPoint {
</span><span class='line'>case let (x, y) where x == y:
</span><span class='line'>    println("(\(x), \(y)) is on the line x == y")
</span><span class='line'>case let (x, y) where x == -y:
</span><span class='line'>    println("(\(x), \(y)) is on the line x == -y")
</span><span class='line'>case let (x, y):
</span><span class='line'>    println("(\(x), \(y)) is just some arbitrary point")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Control Transfer语句</h5>

<p>注意FallThrough的使用,来看以下例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let integerToDescribe = 5
</span><span class='line'>var description = "The number \(integerToDescribe) is"
</span><span class='line'>switch integerToDescribe {
</span><span class='line'>case 2, 3, 5, 7, 11, 13, 17, 19:
</span><span class='line'>    description += " a prime number, and also"
</span><span class='line'>    fallthrough
</span><span class='line'>default:
</span><span class='line'>    description += " an integer."
</span><span class='line'>}
</span><span class='line'>println(description)
</span><span class='line'>// prints "The number 5 is a prime number, and also an integer.”</span></code></pre></td></tr></table></div></figure>


<h4>Labeled语句</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gameLoop: while square != finalSquare {
</span><span class='line'>    if ++diceRoll == 7 { diceRoll = 1 }
</span><span class='line'>    switch square + diceRoll {
</span><span class='line'>    case finalSquare:
</span><span class='line'>        // diceRoll will move us to the final square, so the game is over
</span><span class='line'>        break gameLoop
</span><span class='line'>    case let newSquare where newSquare &gt; finalSquare:
</span><span class='line'>        // diceRoll will move us beyond the final square, so roll again
</span><span class='line'>        continue gameLoop
</span><span class='line'>    default:
</span><span class='line'>        // this is a valid move, so find out its effect
</span><span class='line'>        square += diceRoll
</span><span class='line'>        square += board[square]
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println("Game over!")”</span></code></pre></td></tr></table></div></figure>


<h4>函数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayHello(personName: String) -&gt; String {
</span><span class='line'>    let greeting = "Hello, " + personName + "!"
</span><span class='line'>    return greeting
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>println(sayHello("Anna"))
</span><span class='line'>// prints "Hello, Anna!"
</span><span class='line'>println(sayHello("Brian"))
</span><span class='line'>// prints "Hello, Brian!”
</span><span class='line'>
</span><span class='line'>func sayHelloWorld() -&gt; String {
</span><span class='line'>    return "hello, world"
</span><span class='line'>}
</span><span class='line'>println(sayHelloWorld())
</span><span class='line'>// prints "hello, world”</span></code></pre></td></tr></table></div></figure>


<p>无返回值的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayGoodbye(personName: String) {
</span><span class='line'>    println("Goodbye, \(personName)!")
</span><span class='line'>}
</span><span class='line'>sayGoodbye("Dave")
</span><span class='line'>// prints "Goodbye, Dave!"</span></code></pre></td></tr></table></div></figure>


<p>注意，实际上，虽然函数没写返回值，但它返回的是一个空的tuple<code>()</code></p>

<h5>返回多个值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func count(string: String) -&gt; (vowels: Int, consonants: Int, others: Int) {
</span><span class='line'>    var vowels = 0, consonants = 0, others = 0
</span><span class='line'>    for character in string {
</span><span class='line'>        switch String(character).lowercaseString {
</span><span class='line'>        case "a", "e", "i", "o", "u":
</span><span class='line'>            ++vowels
</span><span class='line'>        case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
</span><span class='line'>        "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
</span><span class='line'>            ++consonants
</span><span class='line'>        default:
</span><span class='line'>            ++others
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return (vowels, consonants, others)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let total = count("some arbitrary string!")
</span><span class='line'>println("\(total.vowels) vowels and \(total.consonants) consonants")
</span><span class='line'>// prints "6 vowels and 13 consonants”</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>,.vowerls和.consonants依然可用!!!</p>

<h5>External Parameter Names</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunction(externalParameterName localParameterName: Int) {
</span><span class='line'>    // function body goes here, and can use localParameterName
</span><span class='line'>    // to refer to the argument value for that parameter
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func join(string s1: String, toString s2: String, withJoiner joiner: String)
</span><span class='line'>    -&gt; String {
</span><span class='line'>        return s1 + joiner + s2
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>join(string: "hello", toString: "world", withJoiner: ", ")</span></code></pre></td></tr></table></div></figure>


<h5>Shorthand External Parameter Names</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool {
</span><span class='line'>    for character in string {
</span><span class='line'>        if character == characterToFind {
</span><span class='line'>            return true
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let containsAVee = containsCharacter(string: "aardvark", characterToFind: "v")
</span><span class='line'>// containsAVee equals true, because "aardvark" contains a "v”</span></code></pre></td></tr></table></div></figure>


<h4>参数的默认值</h4>

<p>将有默认值的参数放在最后</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func join(string s1: String, toString s2: String,
</span><span class='line'>    withJoiner joiner: String = " ") -&gt; String {
</span><span class='line'>        return s1 + joiner + s2
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>join(string: "hello", toString: "world", withJoiner: "-")
</span><span class='line'>// returns "hello-world"
</span><span class='line'>
</span><span class='line'>join(string: "hello", toString: "world")
</span><span class='line'>// returns "hello world"</span></code></pre></td></tr></table></div></figure>


<h5>External Names for Parameters with Default Values</h5>

<p>Swift provides an automatic external name for any defaulted parameter you define
故可以像如下调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>join("hello", "world", joiner: "-")</span></code></pre></td></tr></table></div></figure>


<h5>Variadic Parameters</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func arithmeticMean(numbers: Double...) -&gt; Double {
</span><span class='line'>    var total: Double = 0
</span><span class='line'>    for number in numbers {
</span><span class='line'>        total += number
</span><span class='line'>    }
</span><span class='line'>    return total / Double(numbers.count)
</span><span class='line'>}
</span><span class='line'>arithmeticMean(1, 2, 3, 4, 5)
</span><span class='line'>// returns 3.0, which is the arithmetic mean of these five numbers
</span><span class='line'>arithmeticMean(3, 8, 19)
</span><span class='line'>// returns 10.0, which is the arithmetic mean of these three numbers</span></code></pre></td></tr></table></div></figure>


<p>一个函数至多只能有一个variadic参数，它必须总是在所有参数的最后!</p>

<h5>Constant 和 Variable 参数</h5>

<p>函数的参数默认是constant的,如果试图修改它将导致错误,我们可以在参数前加var来让它可修改</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func alignRight(var string: String, count: Int, pad: Character) -&gt; String {
</span><span class='line'>    let amountToPad = count - countElements(string)
</span><span class='line'>    for _ in 1...amountToPad {
</span><span class='line'>        string = pad + string
</span><span class='line'>    }
</span><span class='line'>    return string
</span><span class='line'>}
</span><span class='line'>let originalString = "hello"
</span><span class='line'>let paddedString = alignRight(originalString, 10, "-")
</span><span class='line'>// paddedString is equal to "-----hello"
</span><span class='line'>// originalString is still equal to "hello”</span></code></pre></td></tr></table></div></figure>


<h5>In-Out参数</h5>

<p>来看个demo就明白In-Out是如何使用的了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoInts(inout a: Int, inout b: Int) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoInts(&someInt, &anotherInt)
</span><span class='line'>println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
</span><span class='line'>// prints "someInt is now 107, and anotherInt is now 3”</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是In-out参数不能有默认值,variadic参数不能与inout一起使用,let也不行</p>

<h5>函数类型</h5>

<p>可以像以下这么用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var mathFunction: (Int, Int) -&gt; Int = addTwoInts
</span><span class='line'>println("Result: \(mathFunction(2, 3))")</span></code></pre></td></tr></table></div></figure>


<p>同样的函数签名也可以赋值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mathFunction = multiplyTwoInts
</span><span class='line'>println("Result: \(mathFunction(2, 3))")
</span><span class='line'>// prints "Result: 6</span></code></pre></td></tr></table></div></figure>


<p>也可以根据Swift的自动推断功能像以下方法使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anotherMathFunction = addTwoInts</span></code></pre></td></tr></table></div></figure>


<h5>充当参数的函数类型</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func printMathResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int) {
</span><span class='line'>    println("Result: \(mathFunction(a, b))")
</span><span class='line'>}
</span><span class='line'>printMathResult(addTwoInts, 3, 5)
</span><span class='line'>// prints "Result: 8”</span></code></pre></td></tr></table></div></figure>


<h5>作为返回类型的函数类型</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func stepForward(input: Int) -&gt; Int {
</span><span class='line'>    return input + 1
</span><span class='line'>}
</span><span class='line'>func stepBackward(input: Int) -&gt; Int {
</span><span class='line'>    return input - 1
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
</span><span class='line'>    return backwards ? stepBackward : stepForward
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var currentValue = 3
</span><span class='line'>let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
</span><span class='line'>// moveNearerToZero now refers to the stepBackward() function
</span><span class='line'>
</span><span class='line'>println("Counting to zero:")
</span><span class='line'>// Counting to zero:
</span><span class='line'>while currentValue != 0 {
</span><span class='line'>    println("\(currentValue)... ")
</span><span class='line'>    currentValue = moveNearerToZero(currentValue)
</span><span class='line'>}
</span><span class='line'>println("zero!")
</span><span class='line'>// 3...
</span><span class='line'>// 2...
</span><span class='line'>// 1...
</span><span class='line'>// zero!</span></code></pre></td></tr></table></div></figure>


<h5>嵌套函数</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
</span><span class='line'>    func stepForward(input: Int) -&gt; Int { return input + 1 }
</span><span class='line'>    func stepBackward(input: Int) -&gt; Int { return input - 1 }
</span><span class='line'>    return backwards ? stepBackward : stepForward
</span><span class='line'>}
</span><span class='line'>var currentValue = -4
</span><span class='line'>let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
</span><span class='line'>// moveNearerToZero now refers to the nested stepForward() function
</span><span class='line'>while currentValue != 0 {
</span><span class='line'>    println("\(currentValue)... ")
</span><span class='line'>    currentValue = moveNearerToZero(currentValue)
</span><span class='line'>}
</span><span class='line'>println("zero!")
</span><span class='line'>// -4...
</span><span class='line'>// -3...
</span><span class='line'>// -2...
</span><span class='line'>// -1...
</span><span class='line'>// zero!</span></code></pre></td></tr></table></div></figure>


<h4>闭包</h4>

<p>类似OC中的block</p>

<h5>Sort函数</h5>

<p>第一种使用方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</span><span class='line'>//demo 1
</span><span class='line'>func backwards(s1: String, s2: String) -&gt; Bool {
</span><span class='line'>    return s1 &gt; s2
</span><span class='line'>}
</span><span class='line'>var reversed = sort(names, backwards)</span></code></pre></td></tr></table></div></figure>


<p>第二种</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in
</span><span class='line'>    return s1 &gt; s2
</span><span class='line'>    })</span></code></pre></td></tr></table></div></figure>


<p>closure的body和声明用in关键词分隔开来</p>

<h5>Inferring Type From Context</h5>

<p>由于sort的closure是以参数的形式传入函数，所以swift能从推测出闭包的参数类型和返回值类型,所以我们可以按以下方式来写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { s1, s2 in return s1 &gt; s2 } )</span></code></pre></td></tr></table></div></figure>


<p>也可以省略return,因为默认是有return这个关键字的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { s1, s2 in  s1 &gt; s2 } )</span></code></pre></td></tr></table></div></figure>


<h5>Shorthand Argument Names</h5>

<p>Swift默认为内联的参数名指定了诸如$0, $1等名字
If you use these shorthand argument names within your closure expression, you can omit the closure’s argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type. The in keyword can also be omitted, because the closure expression is made up entirely of its body:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { $0 &gt; $1 } )</span></code></pre></td></tr></table></div></figure>


<p>以上的demo中,$0和$1分别指向了闭包的第一个和第二个String参数</p>

<h5>Operators Function</h5>

<p>There’s actually an even shorter way to write the closure expression above. Swift’s String type defines its string-specific implementation of the greater-than operator (>) as a function that has two parameters of type String, and returns a value of type Bool. This exactly matches the function type needed for the sort function’s second parameter. Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, &gt;)</span></code></pre></td></tr></table></div></figure>


<h5>Trailing Closures</h5>

<p>如果你将一个闭包指定为一个函数的最后一个参数，并且这个闭包表达式很长，你可以将它作为一个trailing closure,它是一个写在函数的括号之外的closure</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunctionThatTakesAClosure(closure: () -&gt; ()) {
</span><span class='line'>    // function body goes here
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// here's how you call this function without using a trailing closure:
</span><span class='line'> 
</span><span class='line'>someFunctionThatTakesAClosure({
</span><span class='line'>    // closure's body goes here
</span><span class='line'>    })
</span><span class='line'> 
</span><span class='line'>// here's how you call this function with a trailing closure instead:
</span><span class='line'> 
</span><span class='line'>someFunctionThatTakesAClosure() {
</span><span class='line'>    // trailing closure's body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>:如果一个closure expression是一个函数的惟参数,则无需要括号，故以上也可以写成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>someFunctionThatTakesAClosure {
</span><span class='line'>    // trailing closure's body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看一个Array中的map方法的例子，只有一个参数，也是一个closure</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let digitNames = [
</span><span class='line'>    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
</span><span class='line'>    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
</span><span class='line'>]
</span><span class='line'>let numbers = [16, 58, 510]
</span><span class='line'>
</span><span class='line'>let strings = numbers.map {
</span><span class='line'>    (var number) -&gt; String in
</span><span class='line'>    var output = ""
</span><span class='line'>    while number &gt; 0 {
</span><span class='line'>        output = digitNames[number % 10]! + output
</span><span class='line'>        number /= 10
</span><span class='line'>    }
</span><span class='line'>    return output
</span><span class='line'>}
</span><span class='line'>// strings is inferred to be of type String[]
</span><span class='line'>// its value is ["OneSix", "FiveEight", "FiveOneZero"]</span></code></pre></td></tr></table></div></figure>


<h5>Capturing Values</h5>

<p>Swift中closure的最简单形式是一个内嵌的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
</span><span class='line'>    var runningTotal = 0
</span><span class='line'>    func incrementor() -&gt; Int {
</span><span class='line'>        runningTotal += amount
</span><span class='line'>        return runningTotal
</span><span class='line'>    }
</span><span class='line'>    return incrementor
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>because it modifies the runningTotal variable each time it is called, incrementor captures a reference to the current runningTotal variable, and not just a copy of its initial value. Capturing a reference ensures sure that runningTotal does not disappear when the call to makeIncrementor ends, and ensures that runningTotal will continue to be available the next time that the incrementor function is called.
注意以下的调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let incrementByTen = makeIncrementor(forIncrement: 10)
</span><span class='line'>
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 10
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 20
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 30</span></code></pre></td></tr></table></div></figure>


<p>If you create another incrementor, it will have its own stored reference to a new, separate runningTotal variable</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let incrementBySeven = makeIncrementor(forIncrement: 7)
</span><span class='line'>incrementBySeven()
</span><span class='line'>// returns a value of 7
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 40</span></code></pre></td></tr></table></div></figure>


<p>incrementByTen捕获的变量与incrementBySeven捕获的无关</p>

<h5>Closure是引用类型</h5>

<p>也就是说如果你将closure赋给两个不同的常量或变量，这两个常量或变量将指向一样的closure</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let alsoIncrementByTen = incrementByTen
</span><span class='line'>alsoIncrementByTen()
</span><span class='line'>// returns a value of 50</span></code></pre></td></tr></table></div></figure>


<h4>Enumerations</h4>

<p>Enumerations in Swift are first-class types in their own right. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial member value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</p>

<h5>Enumeration Syntax</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum CompassPoint {
</span><span class='line'>    case North
</span><span class='line'>    case South
</span><span class='line'>    case East
</span><span class='line'>    case West
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code></p>

<pre><code>    Unlike C and Objective-C, Swift enumeration members are not assigned a default integer value when they are created. In the CompassPoints example above, North, South, East and West do not implicitly equal 0, 1, 2 and 3. Instead, the different enumeration members are fully-fledged values in their own right, with an explicitly-defined type of CompassPoint.
</code></pre>

<p>多个成员值可以出现在同一行上，用<code>,</code>分开</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Planet {
</span><span class='line'>    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>来看以下例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var directionToHead = CompassPoint.West
</span><span class='line'>directionToHead = .East</span></code></pre></td></tr></table></div></figure>


<p>一旦知道了directionToHead的类型，它的type(CompassPoint)可以省略</p>

<h5>Switch..case</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>directionToHead = .South
</span><span class='line'>switch directionToHead {
</span><span class='line'>case .North:
</span><span class='line'>    println("Lots of planets have a north")
</span><span class='line'>case .South:
</span><span class='line'>    println("Watch out for penguins")
</span><span class='line'>case .East:
</span><span class='line'>    println("Where the sun rises")
</span><span class='line'>case .West:
</span><span class='line'>    println("Where the skies are blue")
</span><span class='line'>}
</span><span class='line'>// prints "Watch out for penguins</span></code></pre></td></tr></table></div></figure>


<h5>Associated Values</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Barcode {
</span><span class='line'>    case UPCA(Int, Int, Int)
</span><span class='line'>    case QRCode(String)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var productBarcode = Barcode.UPCA(8, 85909_51226, 3)
</span><span class='line'>productBarcode = .QRCode("ABCDEFGHIJKLMNOP")
</span><span class='line'>
</span><span class='line'>switch productBarcode {
</span><span class='line'>case .UPCA(let numberSystem, let identifier, let check):
</span><span class='line'>    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
</span><span class='line'>case .QRCode(let productCode):
</span><span class='line'>    println("QR code with value of \(productCode).")
</span><span class='line'>}
</span><span class='line'>// prints "QR code with value of ABCDEFGHIJKLMNOP.”</span></code></pre></td></tr></table></div></figure>


<p>If all of the associated values for a enumeration member are extracted as constants, or if all are extracted as variables, you can place a single var or let annotation before the member name, for brevity:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>switch productBarcode {
</span><span class='line'>case let .UPCA(numberSystem, identifier, check):
</span><span class='line'>    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
</span><span class='line'>case let .QRCode(productCode):
</span><span class='line'>    println("QR code with value of \(productCode).")
</span><span class='line'>}
</span><span class='line'>// prints "QR code with value of ABCDEFGHIJKLMNOP.”</span></code></pre></td></tr></table></div></figure>


<h5>Raw Values</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum ASCIIControlCharacter: Character {
</span><span class='line'>    case Tab = "\t"
</span><span class='line'>    case LineFeed = "\n"
</span><span class='line'>    case CarriageReturn = "\r"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The raw value for a particular enumeration member is always the same. Associated values are set when you create a new constant or variable based on one of the enumeration’s members, and can be different each time you do so.
注意，如果整型被用来作为raw values,如果其他enumeration member无值，则其他的将会自动增长</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Planet: Int {
</span><span class='line'>    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>.venus = 2,&hellip;依此类推
用toRaw方法来获取一个enumeration member的rawValue值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let earthsOrder = Planet.Earth.toRaw()
</span><span class='line'>// earthsOrder is 3</span></code></pre></td></tr></table></div></figure>


<p>用fromRaw来获取拥有一个raw value的enumberation member</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let possiblePlanet = Planet.fromRaw(7)</span></code></pre></td></tr></table></div></figure>


<p>注意fromRaw返回的是optional value,所以可以像如下这个写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let positionToFind = 9
</span><span class='line'>if let somePlanet = Planet.fromRaw(positionToFind) {
</span><span class='line'>    switch somePlanet {
</span><span class='line'>    case .Earth:
</span><span class='line'>        println("Mostly harmless")
</span><span class='line'>    default:
</span><span class='line'>        println("Not a safe place for humans")
</span><span class='line'>    }
</span><span class='line'>} else {
</span><span class='line'>    println("There isn't a planet at position \(positionToFind)")
</span><span class='line'>}
</span><span class='line'>// prints "There isn't a planet at position 9”</span></code></pre></td></tr></table></div></figure>


<h4>Classes和Structures</h4>

<p>Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures. In Swift, you define a class or a structure in a single file, and the external interface to that class or structure is automatically made available for other code to use.</p>

<h5>二者的比较</h5>

<p>共同之处</p>

<ul>
<li>Define properties to store values</li>
<li>Define methods to provide functionality</li>
<li>Define subscripts to provide access to their values using subscript syntax</li>
<li>Define initializers to set up their initial state</li>
<li>Be extended to expand their functionality beyond a default implementation</li>
<li><p>Conform to protocols to provide standard functionality of a certain kind
类有的，而Structure木有的</p></li>
<li><p>Inheritance enables one class to inherit the characteristics of another.</p></li>
<li>Type casting enables you to check and interpret the type of a class instance at runtime.</li>
<li>Deinitializers enable an instance of a class to free up any resources it has assigned.</li>
<li>Reference counting allows more than one reference to a class instance.
<code>注意</code>Structures总是被copies的而不用引用计数

<h5>语法定义</h5></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Resolution {
</span><span class='line'>    var width = 0
</span><span class='line'>    var height = 0
</span><span class='line'>}
</span><span class='line'>class VideoMode {
</span><span class='line'>    var resolution = Resolution()
</span><span class='line'>    var interlaced = false
</span><span class='line'>    var frameRate = 0.0
</span><span class='line'>    var name: String?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Class and Structures Instances</h5>

<p>创建对象实例</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someResolution = Resolution()
</span><span class='line'>let someVideoMode = VideoMode()</span></code></pre></td></tr></table></div></figure>


<h5>访问属性</h5>

<p>可以层层访问，注意以下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The width of someVideoMode is \(someVideoMode.resolution.width)")
</span><span class='line'>// prints "The width of someVideoMode is 0”</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>
Unlike Objective-C, Swift enables you to set sub-properties of a structure property directly. In the last example above, the width property of the resolution property of someVideoMode is set directly, without your needing to set the entire resolution property to a new value.</p>

<h5>Memberwise Initializers for Structure Types</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vga = Resolution(width: 640, height: 480)</span></code></pre></td></tr></table></div></figure>


<p>不过不像structures,类的对象初始化时没有这样默认的成员初始化</p>

<h4>Structus和Enumerations是值类型</h4>

<p>也就是说当它赋给一个变量或专给函数时，它们是copy的
实际上,Swift中的所有基本类型，整型，浮点型，bool型，string，array和dictionary都是值类型，不过幕后都以structure的形式呈现
demo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum CompassPoint {
</span><span class='line'>    case North, South, East, West
</span><span class='line'>}
</span><span class='line'>var currentDirection = CompassPoint.West
</span><span class='line'>let rememberedDirection = currentDirection
</span><span class='line'>currentDirection = .East
</span><span class='line'>if rememberedDirection == .West {
</span><span class='line'>    println("The remembered direction is still .West")
</span><span class='line'>}
</span><span class='line'>// prints "The remembered direction is still .West”</span></code></pre></td></tr></table></div></figure>


<h4>类是引用类型</h4>

<p>我们可以判断两个变量是否指向同一个类的对象
可以用<code>===</code></p>

<h4>选择类或是Structure</h4>

<p>structure总是按值传递，class总是按引用传递</p>

<h4>Assignment and Copy Behavior for Collection Types</h4>

<ul>
<li>Assignment and Copy Behavior for Dictionaries
当你将一个dictionary赋予一个常量或变量，或者将它传入函数时,dictionary就被copied了
如果keys/values是值类型,它们也在赋值或作为参数传入函数时也被copy了，不过如果它们是引用类型的话，只是引用copy了，对象并未被copy，这种copy规则与一个structure的properties一样，如果structure被copy的话</li>
<li>Assignment and Copy Behavior for Arrays
array的copy规则与dictionary的大大不同!array的copy只发生在你所做的修改会改变array的大小的时候</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var a = [1, 2, 3]
</span><span class='line'>var b = a
</span><span class='line'>var c = a
</span><span class='line'>
</span><span class='line'>a[0] = 42
</span><span class='line'>println(a[0])
</span><span class='line'>// 42
</span><span class='line'>println(b[0])
</span><span class='line'>// 42
</span><span class='line'>println(c[0])
</span><span class='line'>// 42
</span><span class='line'>
</span><span class='line'>a.append(4)
</span><span class='line'>a[0] = 777
</span><span class='line'>println(a[0])
</span><span class='line'>// 777
</span><span class='line'>println(b[0])
</span><span class='line'>// 42
</span><span class='line'>println(c[0])
</span><span class='line'>// 42</span></code></pre></td></tr></table></div></figure>


<h4>确保array是唯一的</h4>

<p>通过对一个array的变量调用unshare方法，你能确保这个这个变量对这个array的唯一性，也就是说如果有多个变量指向同一个array,如果你对其中的某一个变量调用unshare方法，这个array就被copy了,所以这个变量有此array的独立拷贝,不过如果只有一个变量指向此array,则copy不会发生
在以上的例子中,假设我们调用了如下语句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b.unshare()</span></code></pre></td></tr></table></div></figure>


<p>则结果如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b[0] = -105
</span><span class='line'>println(a[0])
</span><span class='line'>// 777
</span><span class='line'>println(b[0])
</span><span class='line'>// -105
</span><span class='line'>println(c[0])
</span><span class='line'>// 42</span></code></pre></td></tr></table></div></figure>


<h5>Checking Whether Two Arrays Share the Same Elements</h5>

<p>Check whether two arrays or subarrays share the same storage and elements by comparing them with the identity operators (=== and !==).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if b === c {
</span><span class='line'>    println("b and c still share the same array elements.")
</span><span class='line'>} else {
</span><span class='line'>    println("b and c now refer to two independent sets of array elements.")
</span><span class='line'>}
</span><span class='line'>// prints "b and c now refer to two independent sets of array elements.</span></code></pre></td></tr></table></div></figure>


<p>Alternatively, use the identity operators to check whether two subarrays share the same elements. The example below compares two identical subarrays from b and confirms that they refer to the same elements:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if b[0...1] === b[0...1] {
</span><span class='line'>    println("These two subarrays share the same elements.")
</span><span class='line'>} else {
</span><span class='line'>    println("These two subarrays do not share the same elements.")
</span><span class='line'>}
</span><span class='line'>// prints "These two subarrays share the same elements.”</span></code></pre></td></tr></table></div></figure>


<h5>强制array的copy</h5>

<p>调用array的copy方法,这个方法只是对array进行<code>浅复制</code></p>

<h4>Properties</h4>

<p>Properties associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.</p>

<p>Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties.</p>

<p>In addition, you can define property observers to monitor changes in a property’s value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</p>

<h5>Stored Properties</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct FixedLengthRange {
</span><span class='line'>    var firstValue: Int
</span><span class='line'>    let length: Int
</span><span class='line'>}
</span><span class='line'>var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
</span><span class='line'>// the range represents integer values 0, 1, and 2
</span><span class='line'>rangeOfThreeItems.firstValue = 6
</span><span class='line'>// the range now represents integer values 6, 7, and 8</span></code></pre></td></tr></table></div></figure>


<h5>Stored Properties of Constant Structure Instances</h5>

<p>如果你创建了一个structure的instance，并且将这个instance赋予一个常量,你不能通过这个常量修改这个instance的properties,即使它们被声明为variable properties</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
</span><span class='line'>// this range represents integer values 0, 1, 2, and 3
</span><span class='line'>rangeOfFourItems.firstValue = 6
</span><span class='line'>// this will report an error, even thought firstValue is a variable property</span></code></pre></td></tr></table></div></figure>


<p>这是因为structure是值类型的缘故,如果一个值类型的instance被标记为常量，则它的property也是
不过class与此不同，class照样可修改instance的variable properties，既然它被赋值为一个常量</p>

<h5>Lazy Stored Properties</h5>

<p>A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the @lazy attribute before its declaration.</p>

<p><code>注意</code>
You must always declare a lazy property as a variable (with the var keyword), because its initial value may not be retrieved until after instance initialization completes. Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.</p>

<p>Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance’s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.</p>

<p>The example below uses a lazy stored property to avoid unnecessary initialization of a complex class. This example defines two classes called DataImporter and DataManager, neither of which is shown in full:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class DataImporter {
</span><span class='line'>    /*
</span><span class='line'>    DataImporter is a class to import data from an external file.
</span><span class='line'>    The class is assumed to take a non-trivial amount of time to initialize.
</span><span class='line'>    */
</span><span class='line'>    var fileName = "data.txt"
</span><span class='line'>    // the DataImporter class would provide data importing functionality here
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class DataManager {
</span><span class='line'>    @lazy var importer = DataImporter()
</span><span class='line'>    var data = String[]()
</span><span class='line'>    // the DataManager class would provide data management functionality here
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>let manager = DataManager()
</span><span class='line'>manager.data += "Some data"
</span><span class='line'>manager.data += "Some more data"
</span><span class='line'>// the DataImporter instance for the importer property has not yet been created</span></code></pre></td></tr></table></div></figure>


<p>只有在importer的property首次被访问的时候，importer才被创建</p>

<h4>Computed Properties</h4>

<p>主要用来计算，而非存储，主要提供了一个getter和一个可选的setter</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>struct Rect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    var center: Point {
</span><span class='line'>    get {
</span><span class='line'>        let centerX = origin.x + (size.width / 2)
</span><span class='line'>        let centerY = origin.y + (size.height / 2)
</span><span class='line'>        return Point(x: centerX, y: centerY)
</span><span class='line'>    }
</span><span class='line'>    set(newCenter) {
</span><span class='line'>        origin.x = newCenter.x - (size.width / 2)
</span><span class='line'>        origin.y = newCenter.y - (size.height / 2)
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var square = Rect(origin: Point(x: 0.0, y: 0.0),
</span><span class='line'>    size: Size(width: 10.0, height: 10.0))
</span><span class='line'>let initialSquareCenter = square.center
</span><span class='line'>square.center = Point(x: 15.0, y: 15.0)
</span><span class='line'>println("square.origin is now at (\(square.origin.x), \(square.origin.y))")
</span><span class='line'>// prints "square.origin is now at (10.0, 10.0)</span></code></pre></td></tr></table></div></figure>


<h5>Shorthand Setter Declaration</h5>

<p>如果一个computed property的setter并不为新值定义一个名字,则新值的默认名为newValue</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct AlternativeRect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    var center: Point {
</span><span class='line'>    get {
</span><span class='line'>        let centerX = origin.x + (size.width / 2)
</span><span class='line'>        let centerY = origin.y + (size.height / 2)
</span><span class='line'>        return Point(x: centerX, y: centerY)
</span><span class='line'>    }
</span><span class='line'>    set {
</span><span class='line'>        origin.x = newValue.x - (size.width / 2)
</span><span class='line'>        origin.y = newValue.y - (size.height / 2)
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>只读的Computed Properties
一个computed property如果只有一个getter，而没有setter，则它被称为read-only computed property,它只能返回一个值(通过.)而不能赋值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Cuboid {
</span><span class='line'>    var width = 0.0, height = 0.0, depth = 0.0
</span><span class='line'>    var volume: Double {
</span><span class='line'>    return width * height * depth
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
</span><span class='line'>println("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
</span><span class='line'>// prints "the volume of fourByFiveByTwo is 40.0”</span></code></pre></td></tr></table></div></figure>


<p> <code>注意</code>你必须用var来声明computed properties(即使是只读的也一样),let只用于constant properties</p>

<p> #####Property Observer
Property observers observe and respond to changes in a property’s value. Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</p>

<p>You can add property observers to any stored properties you define, apart from lazy stored properties. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass</p>

<p><code>注意</code>
You don’t need to define property observers for non-overridden computed properties, because you can observe and respond to changes to their value from directly within the computed property’s setter.</p>

<p>you have the option to define either or both of these observers on a property:</p>

<ul>
<li>willSet is called just before the value is stored.</li>
<li>didSet is called immediately after the new value is stored.</li>
</ul>


<p>If you implement a willSet observer, it is passed the new property value as a constant parameter. You can specify a name for this parameter as part of your willSet implementation. If you choose not to write the parameter name and parentheses within your implementation, the parameter will still be made available with a default parameter name of newValue.</p>

<p>Similarly, if you implement a didSet observer, it will be passed a constant parameter containing the old property value. You can name the parameter if you wish, or use the default parameter name of oldValue.</p>

<p><code>注意</code>
willSet and didSet observers are not called when a property is first initialized. They are only called when the property’s value is set outside of an initialization context.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class StepCounter {
</span><span class='line'>    var totalSteps: Int = 0 {
</span><span class='line'>    willSet(newTotalSteps) {
</span><span class='line'>        println("About to set totalSteps to \(newTotalSteps)")
</span><span class='line'>    }
</span><span class='line'>    didSet {
</span><span class='line'>        if totalSteps &gt; oldValue  {
</span><span class='line'>            println("Added \(totalSteps - oldValue) steps")
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let stepCounter = StepCounter()
</span><span class='line'>stepCounter.totalSteps = 200
</span><span class='line'>// About to set totalSteps to 200
</span><span class='line'>// Added 200 steps
</span><span class='line'>stepCounter.totalSteps = 360
</span><span class='line'>// About to set totalSteps to 360
</span><span class='line'>// Added 160 steps
</span><span class='line'>stepCounter.totalSteps = 896
</span><span class='line'>// About to set totalSteps to 896
</span><span class='line'>// Added 536 steps</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>
If you assign a value to a property within its own didSet observer, the new value that you assign will replace the one that was just set</p>

<h4>全局和局部变量</h4>

<p>The capabilities described above for computing and observing properties are also available to global variables and local variables.</p>

<p>The global and local variables you have encountered in previous chapters have all been stored variables. Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.</p>

<p>However, you can also define computed variables and define observers for stored variables, in either a global or local scope. Computed variables calculate rather than store a value, and are written in the same way as computed properties.</p>

<p><code>注意</code>
Global constants and variables are always computed lazily, in a similar manner to Lazy Stored Properties. Unlike lazy stored properties, global constants and variables do not need to be marked with the @lazy attribute.</p>

<p>Local constants and variables are never computed lazily.</p>

<h4>Type Properties</h4>

<p>For value types (that is, structures and enumerations), you can define stored and computed type properties. For classes, you can define computed type properties only.</p>

<p>Stored type properties for value types can be variables or constants. Computed type properties are always declared as variable properties, in the same way as
computed instance properties.</p>

<p><code>注意</code>
Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>

<h5>Type property语法</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct SomeStructure {
</span><span class='line'>    static var storedTypeProperty = "Some value."
</span><span class='line'>    static var computedTypeProperty: Int {
</span><span class='line'>    // return an Int value here
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>enum SomeEnumeration {
</span><span class='line'>    static var storedTypeProperty = "Some value."
</span><span class='line'>    static var computedTypeProperty: Int {
</span><span class='line'>    // return an Int value here
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>class SomeClass {
</span><span class='line'>    class var computedTypeProperty: Int {
</span><span class='line'>    // return an Int value here
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Querying and Setting Type Properties</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println(SomeClass.computedTypeProperty)
</span><span class='line'>// prints "42"
</span><span class='line'> 
</span><span class='line'>println(SomeStructure.storedTypeProperty)
</span><span class='line'>// prints "Some value."
</span><span class='line'>SomeStructure.storedTypeProperty = "Another value."
</span><span class='line'>println(SomeStructure.storedTypeProperty)
</span><span class='line'>// prints "Another value."</span></code></pre></td></tr></table></div></figure>


<p>再来看一个例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct AudioChannel {
</span><span class='line'>    static let thresholdLevel = 10
</span><span class='line'>    static var maxInputLevelForAllChannels = 0
</span><span class='line'>    var currentLevel: Int = 0 {
</span><span class='line'>    didSet {
</span><span class='line'>        if currentLevel &gt; AudioChannel.thresholdLevel {
</span><span class='line'>            // cap the new audio level to the threshold level
</span><span class='line'>            currentLevel = AudioChannel.thresholdLevel
</span><span class='line'>        }
</span><span class='line'>        if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels {
</span><span class='line'>            // store this as the new overall maximum input level
</span><span class='line'>            AudioChannel.maxInputLevelForAllChannels = currentLevel
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>注意</code>
In the first of these two checks, the didSet observer sets currentLevel to a different value. This does not, however, cause the observer to be called again.</p>

<h4>方法</h4>

<p>与C不同,Swift中的Structure和enumerations能定义方法</p>

<h5>Instance Methods</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Counter {
</span><span class='line'>    var count = 0
</span><span class='line'>    func increment() {
</span><span class='line'>        count++
</span><span class='line'>    }
</span><span class='line'>    func incrementBy(amount: Int) {
</span><span class='line'>        count += amount
</span><span class='line'>    }
</span><span class='line'>    func reset() {
</span><span class='line'>        count = 0
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let counter = Counter()
</span><span class='line'>// the initial counter value is 0
</span><span class='line'>counter.increment()
</span><span class='line'>// the counter's value is now 1
</span><span class='line'>counter.incrementBy(5)
</span><span class='line'>// the counter's value is now 6
</span><span class='line'>counter.reset()
</span><span class='line'>// the counter's value is now 0</span></code></pre></td></tr></table></div></figure>


<h5>Local and External Parameter Names for Methods</h5>

<p>Function parameters can have both a local name (for use within the function’s body) and an external name (for use when calling the function)</p>

<p>The same is true for method parameters, because methods are just functions that are associated with a type. However, the default behavior of local names and external names is <code>different</code> for functions and methods.</p>

<p>Specifically, Swift gives the first parameter name in a method a local parameter name by default, and gives the second and subsequent parameter names both local and external parameter names by default.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Counter {
</span><span class='line'>    var count: Int = 0
</span><span class='line'>    func incrementBy(amount: Int, numberOfTimes: Int) {
</span><span class='line'>        count += amount * numberOfTimes
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let counter = Counter()
</span><span class='line'>counter.incrementBy(5, numberOfTimes: 3)
</span><span class='line'>// counter value is now 15</span></code></pre></td></tr></table></div></figure>


<p>This default behavior effectively treats the method as if you had written a hash symbol (#) before the numberOfTimes parameter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func incrementBy(amount: Int, #numberOfTimes: Int) {
</span><span class='line'>    count += amount * numberOfTimes
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Modifying External Parameter Name Behavior for Methods</h5>

<p>Sometimes it’s useful to provide an external parameter name for a method’s first parameter, even though this is not the default behavior. You can either add an explicit external name yourself, or you can prefix the first parameter’s name with a hash symbol to use the local name as an external name too.</p>

<p>Conversely, if you do not want to provide an external name for the second or subsequent parameter of a method, override the default behavior by using an underscore character (_) as an explicit external parameter name for that parameter.</p>

<h5>The self Property</h5>

<p>以上的可以改成以下的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func increment() {
</span><span class='line'>    self.count++
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method.</p>

<p>The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance. In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way. You use the implicit self property to distinguish between the parameter name and the property name.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    func isToTheRightOfX(x: Double) -&gt; Bool {
</span><span class='line'>        return self.x &gt; x
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let somePoint = Point(x: 4.0, y: 5.0)
</span><span class='line'>if somePoint.isToTheRightOfX(1.0) {
</span><span class='line'>    println("This point is to the right of the line where x == 1.0")
</span><span class='line'>}
</span><span class='line'>// prints "This point is to the right of the line where x == 1.0”</span></code></pre></td></tr></table></div></figure>


<h4>Modifying Value Types from Within Instance Methods</h4>

<p>Structures 和 enumerations都是值类型,值类型的属性是不能在它的instance方法里修改的,不过你可以在方法名前加mutating来对property进行修改</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>        x += deltaX
</span><span class='line'>        y += deltaY
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var somePoint = Point(x: 1.0, y: 1.0)
</span><span class='line'>somePoint.moveByX(2.0, y: 3.0)
</span><span class='line'>println("The point is now at (\(somePoint.x), \(somePoint.y))")
</span><span class='line'>// prints "The point is now at (3.0, 4.0)”</span></code></pre></td></tr></table></div></figure>


<p>The method can also assign a completely new instance to its implicit self property, and this new instance will replace the existing one when the method ends.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>        self = Point(x: x + deltaX, y: y + deltaY)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Mutating methods for enumerations can set the implicit self parameter to be a different member from the same enumeration:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum TriStateSwitch {
</span><span class='line'>    case Off, Low, High
</span><span class='line'>    mutating func next() {
</span><span class='line'>        switch self {
</span><span class='line'>        case Off:
</span><span class='line'>            self = Low
</span><span class='line'>        case Low:
</span><span class='line'>            self = High
</span><span class='line'>        case High:
</span><span class='line'>            self = Off
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var ovenLight = TriStateSwitch.Low
</span><span class='line'>ovenLight.next()
</span><span class='line'>// ovenLight is now equal to .High
</span><span class='line'>ovenLight.next()
</span><span class='line'>// ovenLight is now equal to .Off</span></code></pre></td></tr></table></div></figure>


<h4>Type Methods</h4>

<p> 对class,在方法的func关键字前加class,对structure和enumeration,在func前加static</p>

<p>  <code>注意</code>:In Objective-C, you can define type-level methods only for Objective-C classes. In Swift, you can define type-level methods for all classes, structures, and enumerations. Each type method is explicitly scoped to the type it supports.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//对类而言
</span><span class='line'>class SomeClass {
</span><span class='line'>    class func someTypeMethod() {
</span><span class='line'>        // type method implementation goes here
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>SomeClass.someTypeMethod()
</span><span class='line'>//对structure和enumeration而言
</span></code></pre></td></tr></table></div></figure>


<p>在一个type方法的方法体里,self指的是type本身</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct LevelTracker {
</span><span class='line'>    static var highestUnlockedLevel = 1
</span><span class='line'>    static func unlockLevel(level: Int) {
</span><span class='line'>        if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
</span><span class='line'>    }
</span><span class='line'>    static func levelIsUnlocked(level: Int) -&gt; Bool {
</span><span class='line'>        return level &lt;= highestUnlockedLevel
</span><span class='line'>    }
</span><span class='line'>    var currentLevel = 1
</span><span class='line'>    mutating func advanceToLevel(level: Int) -&gt; Bool {
</span><span class='line'>        if LevelTracker.levelIsUnlocked(level) {
</span><span class='line'>            currentLevel = level
</span><span class='line'>            return true
</span><span class='line'>        } else {
</span><span class='line'>            return false
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>与Player类的结合使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Player {
</span><span class='line'>    var tracker = LevelTracker()
</span><span class='line'>    let playerName: String
</span><span class='line'>    func completedLevel(level: Int) {
</span><span class='line'>        LevelTracker.unlockLevel(level + 1)
</span><span class='line'>        tracker.advanceToLevel(level + 1)
</span><span class='line'>    }
</span><span class='line'>    init(name: String) {
</span><span class='line'>        playerName = name
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Subscripts</h4>

<p>You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript. Subscripts are not limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom type’s needs.</p>

<h5>Subscript Syntax</h5>

<p>不像其他的instance方法,subscripts可以是读写的或是只读的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subscript(index: Int) -&gt; Int {
</span><span class='line'>    get {
</span><span class='line'>        // return an appropriate subscript value here
</span><span class='line'>    }
</span><span class='line'>    set(newValue) {
</span><span class='line'>        // perform a suitable setting action here
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于只读的computed property,对只读的subscripts,我们可以去掉get关键字</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subscript(index: Int) -&gt; Int {
</span><span class='line'>    // return an appropriate subscript value here
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct TimesTable {
</span><span class='line'>    let multiplier: Int
</span><span class='line'>    subscript(index: Int) -&gt; Int {
</span><span class='line'>        return multiplier * index
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let threeTimesTable = TimesTable(multiplier: 3)
</span><span class='line'>println("six times three is \(threeTimesTable[6])")
</span><span class='line'>// prints "six times three is 18”</span></code></pre></td></tr></table></div></figure>


<h5>Subscript Options</h5>

<p>Subscripts能接收任意数量的参数，并且这些参数可以是任意类型的
Subscripts能接收variable 参数 和 variadic 参数,但不能使用in-out参数或是为参数提供默认值</p>

<p>A class or structure can provide as many subscript implementations as it needs, and the appropriate subscript to be used will be inferred based on the types of the value or values that are contained within the subscript braces at the point that the subscript is used. This definition of multiple subscripts is known as subscript overloading.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Matrix {
</span><span class='line'>    let rows: Int, columns: Int
</span><span class='line'>    var grid: Double[]
</span><span class='line'>    init(rows: Int, columns: Int) {
</span><span class='line'>        self.rows = rows
</span><span class='line'>        self.columns = columns
</span><span class='line'>        grid = Array(count: rows * columns, repeatedValue: 0.0)
</span><span class='line'>    }
</span><span class='line'>    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
</span><span class='line'>        return row &gt;= 0 && row &lt; rows && column &gt;= 0 && column &lt; columns
</span><span class='line'>    }
</span><span class='line'>    subscript(row: Int, column: Int) -&gt; Double {
</span><span class='line'>        get {
</span><span class='line'>            assert(indexIsValidForRow(row, column: column), "Index out of range")
</span><span class='line'>            return grid[(row * columns) + column]
</span><span class='line'>        }
</span><span class='line'>        set {
</span><span class='line'>            assert(indexIsValidForRow(row, column: column), "Index out of range")
</span><span class='line'>            grid[(row * columns) + column] = newValue
</span><span class='line'>        }
</span><span class='line'>     }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var matrix = Matrix(rows: 2, columns: 2)
</span><span class='line'>
</span><span class='line'>matrix[0, 1] = 1.5
</span><span class='line'>matrix[1, 0] = 3.2
</span><span class='line'>
</span><span class='line'>let someValue = matrix[2, 2]
</span><span class='line'>// this triggers an assert, because [2, 2] is outside of the matrix bounds
</span></code></pre></td></tr></table></div></figure>


<h4>继承</h4>

<p>只有类能继承
Classes can also add property observers to inherited properties in order to be notified when the value of a property changes. Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Vehicle {
</span><span class='line'>    var numberOfWheels: Int
</span><span class='line'>    var maxPassengers: Int
</span><span class='line'>    func description() -&gt; String {
</span><span class='line'>        return "\(numberOfWheels) wheels; up to \(maxPassengers) passengers"
</span><span class='line'>    }
</span><span class='line'>    init() {
</span><span class='line'>        numberOfWheels = 0
</span><span class='line'>        maxPassengers = 1
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let someVehicle = Vehicle()
</span></code></pre></td></tr></table></div></figure>


<h5>Subclassing</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Bicycle: Vehicle {
</span><span class='line'>    init() {
</span><span class='line'>        super.init()
</span><span class='line'>        numberOfWheels = 2
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let bicycle = Bicycle()
</span><span class='line'>println("Bicycle: \(bicycle.description())")
</span><span class='line'>// Bicycle: 2 wheels; up to 1 passengers</span></code></pre></td></tr></table></div></figure>


<p>The Bicycle class also defines an initializer to set up its tailored characteristics. The initializer for Bicycle calls super.init(), the initializer for the Bicycle class’s superclass, Vehicle, and ensures that all of the inherited properties are initialized by Vehicle before Bicycle tries to modify them.
<code>注意</code>:initializers are not inherited by default in Swift. For more information</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-03T15:35:28+08:00" data-updated="true" itemprop="datePublished">Aug 3<span>rd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/wwdc2014/'>wwdc2014</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/08/03/whats-new-in-xcode6/" itemprop="url">Whats New in Xcode6</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Storyboard中能实时看到Custom Fonts</p>

<p><img src="/images/2014/8/customfont.png"></p>

<p>swift如需使用不在某文件中定义的类，不需要import,会自动import，不过，你依然需要为你信赖的framework import modules,
创建.swift文件时，默认创建了.h头文件，所以如果在.m文件中引用swift文件中的类，可以用import .swift对应的头文件来引用
在ios8中，可以@import第三方的framework了!</p>

<h5>在IB中动态改变显示效果，如动态改变圆角</h5>

<p>注意以下几个方法的使用
<code>class</code>前写@IBDesignable,属性前写@IBInspectable,还有override以下方法</p>

<p>@override func prepareForInterfaceBuilder(){}</p>

<p><code>Size Classes</code></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-30T15:42:25+08:00" data-updated="true" itemprop="datePublished">Jul 30<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/30/fibers-threads-processes/" itemprop="url">Fibers Threads Processes</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Ruby gives you two basic ways to organize your program so that you can run different parts of it apparently “at the same time.” Fibers let you suspend execution of one part of your program and run some other part. For more decoupled execution, you can split up cooper- ating tasks within the program, using multiple threads, or you can split up tasks between different programs, using multiple processes. Let’s look at each in turn.####Fibers
Ruby 1.9引入了fibers的概念,尽管名字意味着某种轻量级的线程，实际上，fibers仅仅是一种非常简单的coroutine机制，它能让你写一些看起来用了线程的程序，实际上没有引发任何线程中内在的复杂机制
计算一个文件中单词的出现次数，不用fibers版本</p>

<pre><code>counts = Hash.new(0) 
File.foreach("testfile") do |line|
    line.scan(/\w+/) do |word| 
    word = word.downcase 
    counts[word] += 1
    end 
end
counts.keys.sort.each {|k| print "#{k}:#{counts[k]} "} 
produces:
and:1 is:3 line:3 on:1 one:1 so:1 this:3 three:1 two:1这段代码非常的ugly,它混合了查找word和计算word两种逻辑,来看看用Fiber的方法
words = Fiber.new do 
    File.foreach("testfile") do |line|          line.scan(/\w+/) do |word| 
        Fiber.yield word.downcase
        end 
    end     nil ￼end
counts = Hash.new(0)
while word = words.resume 
    counts[word] += 1
end
counts.keys.sort.each {|k| print "#{k}:#{counts[k]} "} 
produces:
and:1 is:3 line:3 on:1 one:1 so:1 this:3 three:1 two:1
</code></pre>

<p>再来看一个demo</p>

<pre><code>twos = Fiber.new do 
    num = 2     loop do         Fiber.yield(num) unless num % 3 == 0 
        num += 2
        end 
    end 10.times { print twos.resume, " " } 
produces:
2 4 8 10 14 16 20 22 26 28
</code></pre>

<p>以上也可以用之前提到的lazy Enumberators中实现由于fibers也是对象，你可以将它们存储在变量中，并且fibers只能在创建它们的线程中resume
fibers can yield control only back to the code that resumed them,不过Ruby提供了两种标准库来拓展这种行为fiber库和continuation库</p>

<h4>多线程</h4>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-30T14:27:07+08:00" data-updated="true" itemprop="datePublished">Jul 30<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/30/basic-input-and-output/" itemprop="url">Basic Input and Output</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>两个I/O routines
第一个是基本的交互界面</p>

<pre><code>print "Enter your name: " 

name = gets
</code></pre>

<p>一系列I/O相关的方法在Kernel module里实现gets, open, print, printf, putc, puts, readline, readlines, 和 test,这些方法通常都与标准输入，标准输出有关
第二个则是与IO对象交互
IO类，有两个子类File和BasicSocket</p>

<h5>开头文件</h5>

<pre><code>file = File.new("testfile", "r") 
# ... process the file 
file.close
</code></pre>

<p>File与Block</p>

<pre><code>File.open("testfile", "r") do |file| 
    # ... process the file
end # &lt;- file automatically closed here与exception结合
class File
    def File.open(*args)
        result = f = File.new(*args) 
            if block_given?
                begin
                    result = yield f
                ensure
                    f.close
                end 
            end
            result
            end 
end
</code></pre>

<h5>读写文件</h5>

<p>来看一段copy.rb代码</p>

<pre><code>while line = gets 

    puts line
end
</code></pre>

<p>如果运行程序木有命令行参数，则与console交互</p>

<pre><code>$ ruby copy.rb 

These are lines 

These are lines 

that I am typing 

that I am typing 

^D
</code></pre>

<p>如果带文件名，则与文件交互</p>

<pre><code>$ ruby copy.rb testfile 

This is line one
This is line two
This is line three
And so on...
</code></pre>

<p>我们可以用File类来读写文件</p>

<pre><code>File.open("testfile") do |file| 
    while line = file.gets          puts line       end 
end
    produces:
This is line one
This is line two
This is line three
And so on...
</code></pre>

<h5>Iterators for Reading</h5>

<p>你可以用各种iterators与IO流交互
O#each_byte invokes a block with the next 8-bit byte from the IO object,chr则将integer转化为ASCII字符</p>

<pre><code>File.open("testfile") do |file| 
    file.each_byte.with_index do |ch, index|
        print "#{ch.chr}:#{ch} "
        break if index &gt; 10 
    end
end
produces:
T:84 h:104 i:105 s:115  :32 i:105 s:115  :32 l:108 i:105 n:110 e:101
</code></pre>

<p>IO#each_line</p>

<pre><code>File.open("testfile") do |file|
    file.each_line {|line| puts "Got #{line.dump}" }
end
produces:
Got "This is line one\n"
Got "This is line two\n"
Got "This is line three\n"
Got "And so on...\n"
</code></pre>

<p>你也可以将一串字符传给each_line来作为一个line separator,默认是\n</p>

<pre><code>File.open("testfile") do |file|
    file.each_line("e") {|line| puts "Got #{ line.dump }" }
end
produces:
Got "This is line"
Got " one"
Got "\nThis is line"
Got " two\nThis is line"
Got " thre"
Got "e"
Got "\nAnd so on...\n"
</code></pre>

<p>combine iterator和autoclosing block,我们得到了IO.foreach,这个方法打开文件，调用iterator一次一行，然后自动关闭文件</p>

<pre><code>IO.foreach("testfile") {|line| puts line }将整个文件文件的内容保存在一个string或每行保存在一个数组里
//保存在string中
# read into string
str = IO.read("testfile")
str.length # =&gt; 66
str[0, 30] # =&gt; "This is line one\nThis is line "

//保存在array中

# read into an array    arr = IO.readlines("testfile") 
arr.length # =&gt; 4
arr[0] # =&gt; "This is line one\n"
</code></pre>

<h4>写入文件</h4>

<pre><code># Note the "w", which opens the file for writing
File.open("output.txt", "w") do |file| 
file.puts "Hello"
file.puts "1 + 2 = #{1+2}"
end
# Now read the file in and print its contents to STDOUT
puts File.read("output.txt")
produces:
Hello 1+2=3
</code></pre>

<p>如果将二进制数据转为string,有以下三种方法</p>

<pre><code>str1 = "\001\002\003" # =&gt; "\u0001\u0002\u0003" 

str2 = ""
str2 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 # =&gt; "\u0001\u0002\u0003" 
[ 1, 2, 3 ].pack("c*") # =&gt; "\x01\x02\x03"
</code></pre>

<p>你也可以用&lt;&lt;将对象添加到输出流中</p>

<pre><code>endl = "\n"
STDOUT &lt;&lt; 99 &lt;&lt; " red balloons" &lt;&lt; endl
produces:
99 red balloons 
</code></pre>

<p>&lt;&lt;方法在打印前将用to_s将它的参数转为string</p>

<h5>Doing I/O with StringsStringIO对象，它们操作起来就像I/O对象，但它们只是读写strings，而不是files</h5>

<pre><code>require 'stringio'
ip = StringIO.new("now is\nthe time\nto learn\nRuby!")
op = StringIO.new("", "w")
ip.each_line do |line| 
    op.puts line.reverse
end
op.string # =&gt; "\nsi won\n\nemit eht\n\nnrael ot\n!ybuR\n"
</code></pre>

<h4>Talking to Networkds</h4>

<p>socekt库封装了TCP,UDP,SOCKS和Unix domainsockes require &lsquo;socket&rsquo;    client = TCPSocket.open(&lsquo;127.0.0.1&rsquo;, &lsquo;www&rsquo;)</p>

<pre><code>client.send("OPTIONS /~dave/ HTTP/1.0\n\n", 0) 
puts client.readlines
client.close
produces:
# 0 means standard packet
HTTP/1.1 200 OK
Date: Mon, 27 May 2013 17:31:00 GMT
Server: Apache/2.2.22 (Unix) DAV/2 PHP/5.3.15 with Suhosin-Patch mod_ssl/2.2.22
OpenSSL/0.9.8r
Allow: GET,HEAD,POST,OPTIONS
Content-Length: 0
Connection: close
Content-Type: text/html
</code></pre>

<p>在高层,lib/net library modules提供了对通信协议的许多支持(FTP, HTTP, POP, SMTP, and telnet)</p>

<pre><code>//以下只是一部分代码
require 'net/http'
http = Net::HTTP.new('pragprog.com', 80)
response = http.get('/book/ruby3/programming-ruby-1-9')
if response.message == "OK"
puts response.body.scan(/&lt;img alt=".*?" src="(.*?)"/m).uniq[0,3]
end
produces:
       http://pragprog.com/assets/logo-c5c7f9c2f950df63a71871ba2f6bb115.gif
       http://pragprog.com/assets/drm-
       free80-9120ffac998173dc0ba7e5875d082f18.png
       http://imagery.pragprog.com/products/99/ruby3_xlargecover.jpg?
       1349967653open-url库中的Object#open方法能识别文件中的http://和ftp://URLs,也能自动处理重定向 
require 'open-uri'
open('http://pragprog.com') do |f|
puts f.read.scan(/&lt;img alt=".*?" src="(.*?)"/m).uniq[0,3]
end
produces:
       http://pragprog.com/assets/logo-c5c7f9c2f950df63a71871ba2f6bb115.gif
       http://pragprog.com/assets/drm-free80-9120ffac998173dc0ba7e5875d082f18.png
       http://imagery.pragprog.com/products/353/jvrails2_xlargebeta.jpg?1368826914
</code></pre>

<h4>Parsing HTML</h4>

<pre><code>require 'open-uri'
page = open('http://pragprog.com/titles/ruby3/programming-ruby-1-9').read 
if page =~ %r{&lt;title&gt;(.*?)&lt;/title&gt;}m
    puts "Title is #{$1.inspect}" 
end
produces:
       Title is "The Pragmatic Bookshelf | Programming Ruby 1.9"
</code></pre>

<p>但用此法不太妥当，可能title和尖括号间多个个空格如何是好，可以用第三方库Nokogiri</p>

<pre><code>require 'open-uri' 
require 'nokogiri'
doc = Nokogiri::HTML(open("http://pragprog.com/"))
puts "Page title is " + doc.xpath("//title").inner_html
# Output the first paragraph in the div with an id="copyright" 
# (nokogiri supports both xpath and css-like selectors)
puts doc.css('div#copyright p')
# Output the second hyperlink in the site-links div using xpath and css
puts "\nSecond hyperlink is"
puts doc.xpath('id("site-links")//a[2]') puts doc.css('#site-links a:nth-of-type(2)')
produces:
Page title is The Pragmatic Bookshelf
&lt;p&gt;
    The &lt;em&gt;Pragmatic BookshelfTM&lt;/em&gt; is an imprint of
        &lt;a href="http://pragprog.com/"&gt;The Pragmatic Programmers, LLC&lt;/a&gt;.
    &lt;br&gt;
    Copyright © 1999–2013 The Pragmatic Programmers, LLC.
    All Rights Reserved.
&lt;/p&gt;
Second hyperlink is
&lt;a href="http://pragprog.com/about"&gt;About Us&lt;/a&gt;
&lt;a href="http://pragprog.com/about"&gt;About Us&lt;/a&gt;
</code></pre>

<p>Nokogiri can also update and create HTML and XML.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-30T11:52:27+08:00" data-updated="true" itemprop="datePublished">Jul 30<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/30/exceptions-catch-throw/" itemprop="url">Exceptions-catch-throw</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4>The Exception Class</h4>

<p>异常的信息被封装进了Exception类的对象或者Exception类的子类对象里,Ruby预定义了exceptions的hierarchy,如下</p>

<p><img src="/images/2014/7/exception_hierarchy.png"></p>

<p>如果你需要抛出异常,你可以用内置的Exception的类,或者可以自己创建一个，不过请确保你创建的Exception
子类继承自StandardError或者它的子类,否则默认情况下异常是不会被捕捉的
每一个Exception都有一个消息和stack backtrace与之关联，如果你定义了自己的异常，你可以添加额外的信息
这是有一个用open-url的库来下载一个网页的内容并将它写入一个文件中的demo</p>

<pre><code>require 'open-uri'
web_page = open("http://pragprog.com/podcasts") 
output = File.open("podcasts.html", "w")
while line = web_page.gets

output.puts line
end
output.close
</code></pre>

<p>如果中途出现错误怎么办，我们当然不想保存一张不完整的网页
我们看看如何处理异常的代码，我们将可能发生异常的代码放在begin/end的block中，然后用rescue语句来告诉Ruby我们想要捕获的异常类型</p>

<pre><code>require 'open-uri'
page = "podcasts"
file_name = "#{page}.html"
web_page = open("http://pragprog.com/#{page}") output = File.open(file_name, "w")
begin
    while line = web_page.gets output.puts line
end
output.close 
rescue Exception
    STDERR.puts "Failed to download #{page}: #{$!}" output.close
        File.delete(file_name)
        raise
end 
</code></pre>

<p>When an exception is raised and independent of any subsequent exception handling, Ruby places a reference to the associated exception object into the global variable $! (the exclamation point presumably mirroring our surprise that any of our code could cause errors). In the previous example, we used the $! variable to format our error message.
关掉并删除文件后，我们可以调用无参的raise，这样又在$!里重新抛出了异常，抛到更高层去了
还可以为捕获取的异常指定别名</p>

<pre><code>begin
    eval string
rescue SyntaxError, NameError =&gt; boom
    print "String doesn't compile: " + boom 
rescue StandardError =&gt; bang
    print "Error running script: " + bang 
end
</code></pre>

<h5>System ErrorsSystem errors are raised when a call to the operating system returns an error code,On POSIX systems, these errors have names such as EAGAIN and EPERM. (If you’re on a Unix box, you could type man errno to get a list of these errors.)</h5>

<p>Ruby将这些错误打包成一个具体的exception的对象,每一个是SymstemCallError的子类，并且都定义在Errno module中,这意味着你将看到Excetion的类另如Errno::EAGAIN, Errno::EIO, 和Errno::EPERM,如果你想要获取system error code,每个Error exception类都有一个叫做Errno类常量</p>

<pre><code>Errno::EAGAIN::Errno # =&gt; 35 

Errno::EPERM::Errno # =&gt; 1 

Errno::EWOULDBLOCK::Errno # =&gt; 35
</code></pre>

<p>注意EWOULDBLOCK 和 EAGAIN有同样的error code,所以在rescue中，Ruby把它们看作一样的，如果你想rescue一个，你再rescue两个，为此你可以重新定义 SystemCallError#===,这样，如果两个SystemCallError比较就会基于error number而不是它们在层次中的位置了</p>

<p>ensure相当于java中的finally</p>

<pre><code>f = File.open("testfile") 

begin
# .. process
rescue
  # .. handle error
ensure
f.close
end
</code></pre>

<p>注意File.open不能放在begin里面，因为open它自己也可能抛出异常，如果发生了，你应该不想在ensure里来执行相应的代码，因为没有文件要去close</p>

<p>else语句</p>

<pre><code>f = File.open("testfile") 

begin
# .. process
rescue
  # .. handle error
else
puts "Congratulations-- no errors!" 
ensure
f.close
end
</code></pre>

<p>注意else里的语句只有在无异发生时才会调用
有时你能改正抛出异常的cause,此时可以用retry语句来重新执行begin/end的block</p>

<pre><code>@esmtp = true
begin
    # First try an extended login. If it fails, fall back to a normal login
    if @esmtp then @command.ehlo(helodom) 
                    else @command.helo(helodom)
        end
rescue ProtocolError
    if @esmtp then
            @esmtp = false
            retry 
        else
            raise
        end 
end
</code></pre>

<h5>Raising Exceptions</h5>

<p>你可以用Object#raise方法来抛出异常</p>

<pre><code>raise   //抛出当前的exception,如果没有，则抛出RuntimeError
raise "bad mp3 encoding"    //创建一个新的RuntimeError,然后抛到调用栈上

//创建InterfaceException，与之相关的信息，然后抛到stack trace上 raise InterfaceException, "Keyboard failure", caller
</code></pre>

<p>stack trace通常用Object#caller
也可以将Exception抛给call stack一部分的子集
假设我们定义了一个RetryException类</p>

<pre><code>class RetryException &lt; RuntimeError
    attr :ok_to_retry
        def initialize(ok_to_retry)
                   @ok_to_retry = ok_to_retry
        end 
end
</code></pre>

<p>在代码的某个地方，一个错误发生了</p>

<pre><code>def read_data(socket) 

    data = socket.read(512) 

    if data.nil?
    raise RetryException.new(true), "transient read error" 
    end        # .. normal processing   endhigher up te call stack,我们处理异常
begin        stuff = read_data(socket)        # .. process stuff    rescue RetryException =&gt; detail 
    retry if detail.ok_to_retry 
    raise   end
</code></pre>

<h5>catch and throw</h5>

<pre><code>word_list = File.open("wordlist") 
word_in_error = catch(:done) do
        result = []
        while line = word_list.gets
    word = line.chomp
    throw(:done, word) unless word =~ /^\w+$/ 
        result &lt;&lt; word
    end
      puts result.reverse
end
if word_in_error
    puts "Failed: '#{word_in_error}' found, but a word was expected" 
end
</code></pre>

<p>throw不一定非要出现在catch语句里</p>

<pre><code>def prompt_and_get(prompt)
    print prompt
    res = readline.chomp
    throw :quit_requested if res == "!" 
    res
end
catch :quit_requested do
    name = prompt_and_get("Name: ") 
    age = prompt_and_get("Age: ") 
    sex = prompt_and_get("Sex: ") 
    # ..
    # process information
end 
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-30T09:14:04+08:00" data-updated="true" itemprop="datePublished">Jul 30<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/30/expressions/" itemprop="url">Expressions</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>显而易见的是我们可以chain statements</p>

<pre><code>a = b = c = 0 # =&gt; 0
[ 3, 1, 7, 0 ].sort.reverse # =&gt; [7, 3, 1, 0]
</code></pre>

<p>比如不明显的是，在C或Java中的语句在Ruby中通常是expressions,比如if和case语句都返回了最后一个表达式</p>

<pre><code>song_type = if song.mp3_type == MP3::Jazz
                if song.written &lt; Date.new(1935, 1, 1)
                    Song::TradJazz
                else
                    Song::Jazz
                end 
            else
                Song::Other
            end
rating = case votes_cast
￼         when 0...10     then Rating::SkipThisOne
            when 10...50    then Rating::CouldDoBetter 
            else    Rating::Rave
         end
</code></pre>

<h5>Operator Expressions</h5>

<p>在Ruby中，许多operations是以方法调用的形式实现的，比如，当你写a*b+c时，实际上你是调用了a的方法<code>*</code>传入参数b,然后a<code>*</code>b的结果返回一个对象，我们再对其执行<code>+</code>的方法,然后将c作为参数传入,实际下相当于以下代码</p>

<pre><code>a, b, c = 1, 2, 3
a * b + c # =&gt; 5
 (a.*(b)).+(c) # =&gt; 5
</code></pre>

<p>我们问题可以定义最基本的运算符操作</p>

<pre><code>class Fixnum
alias old_plus + # We can reference the original '+' as 'old_plus'
def +(other) # Redefine addition of Fixnums. This is a BAD IDEA! 
old_plus(other).succ
end end
1 + 2 # =&gt; 4 a=3
a+=4 #=&gt;8 
a + a + a # =&gt; 26    
</code></pre>

<h6>&lt;&lt;操作符</h6>

<pre><code>a = [ 1, 2, 3 ]
    a&lt;&lt;4 #=&gt;[1,2,3,4]
</code></pre>

<p>我们也可以定义&lt;&lt;操作符方法</p>

<pre><code>class ScoreKeeper 
    def initialize
               @total_score = @count = 0
        end
        def &lt;&lt;(score)
                   @total_score += score
                   @count += 1
                   self
        end
        def average
            fail "No scores" if @count.zero?
            Float(@total_score) / @count
        end 
end      
scores = ScoreKeeper.new
scores &lt;&lt; 10 &lt;&lt; 20 &lt;&lt; 40
puts "Average = #{scores.average}"
produces:
       Average = 23.333333333333332
</code></pre>

<p>注意&lt;&lt;方法中返回了self，这样它就允许<code>scores &lt;&lt; 10 &lt;&lt; 20 &lt;&lt; 40</code>这样的形式
<code>[]</code>也能被定义为一个方法调用，你可以这么写</p>

<pre><code>some_obj[1,2,3]
</code></pre>

<p>我们可以这样定义</p>

<pre><code>class SomeClass
    def [](p1, p2, p3)
        # ...
        end
end
</code></pre>

<p>同样地，也可以定义<code>[]=</code>方法  class SomeClass</p>

<pre><code>    def []=(*params)
        value = params.pop
        puts "Indexed with #{params.join(', ')}" 
        puts "value = #{value.inspect}"
    end
end
s = SomeClass.new
s[1] = 2
s['cat', 'dog'] = 'enemies'
produces:
       Indexed with 1
       value = 2
       Indexed with cat, dog
       value = "enemies"
</code></pre>

<p>从上面我们可以看到<code>[]</code>里的参数作为params的前n个数，而=右边的值为params的最后一个参数</p>

<h5>各种各样的表达式</h5>

<ul>
<li>Command Expression
以&#8220;括起来的字符串或以%x开头的字符串被OS解析为一条bash命令,注意换行符还在
      <code>date</code> # => &ldquo;Mon May 27 12:30:56 CDT 2013\n&rdquo;
      <code>ls</code>.split[34] # => &ldquo;newfile&rdquo;
          %x{echo &ldquo;hello there&rdquo;} # => &ldquo;hello there\n&rdquo;
              for i in 0..3
          status = <code>dbmanager status id=#{i}</code> # &hellip;
      end
我们可以通过全局变量$?来查看命令的exit status

<h4>重定义`</h4>

以上我们得知&#8220;里的字符串默认被当作命令来执行，实际上，string是被当作参数传给了方法Object#`,如果你想，可以重写它，
  alias old_backquote <code>
      def</code>(cmd)
          result = old_backquote(cmd)
          if $? != 0
              puts &ldquo;<strong><em> Command #{cmd} failed: status = #{$?.exitstatus}&rdquo;
          end     result  end
  print <code>ls -l /etc/passwd</code>
  print <code>ls -l /etc/wibble</code>
  produces:
     -rw-r&mdash;r&mdash;  1 root  wheel  5086 Jul 20  2011 /etc/passwd
     ls: /etc/wibble: No such file or directory
     </em></strong> Command ls -l /etc/wibble failed: status = 1

<h4>赋值</h4>

<p>Ruby有两种形式的赋值，第一种是将对象的引用赋予一个变量或常量
      instrument = &ldquo;piano&rdquo;
  MIDDLE_A = 440
第二种形式涉及到<code>having an object attribute or element reference on the left side.</code>这种形式是很特别的，因为它们通过在左值中调用方法来实现，也就是说你可以重写这些方法
   class ProjectList
       def initialize
          @projects = []
      end
      def projects=(list)
          @projects = list.map(&amp;:upcase) # store list of names in uppercase
      end
      def <a href="offset"></a>
          @projects[offset]
      end
  end
  list = ProjectList.new
  list.projects = %w{ strip sand prime sand paint sand paint rub paint }
  list[3] # => &ldquo;SAND&rdquo;
  list[4] # => &ldquo;PAINT&rdquo;
来看一段有意思的代码</p>

<p>  class Test
      def val=(val)
          @val = val
          return 99
      end
  end</p>

<p>  t = Test.new
      result = (t.val = 2)
  result
以上的result会是什么值?
在Ruby的过去版本中，赋值方法的返回值<code>总量</code>return的值，而从Ruby1.8开始,返回值总是传入的参数值
所以以上的result值如果在过去的版本中为99，但在1.8版本后则为2</p></li>
</ul>


<h6>Parallel Assignment</h6>

<pre><code>a,b=1,2 #a=1,b=2 

a,b=b,a #b=2,a=1
a=1,2,3,4 # a=[1,2,3,4] 
    b=[1,2,3,4] # b=[1,2,3,4]   
a,b=1,2,3,4 # a=1, b=2 
c,=1,2,3,4 # c=1
</code></pre>

<h5>Splats and Assignment</h5>

<pre><code>a, b, c, d, e = *(1..2), 3, *[4, 5] # a=1, b=2, c=3, d=4, e=5       a,*b=1,2,3 # a=1, b=[2,3] a,*b=1 # a=1, b=[]
*a,b=1,2,3,4        # a=[1,2,3], b=4
c,*d,e=1,2,3,4      # c=1, d=[2,3], e=4
f,*g,h,i,j=1,2,3,4  # f=1, g=[], h=2, i=3, j=4      first, *, last = 1,2,3,4,5,6 # first=1, last=6#####嵌套赋值
a, (b, c), d = 1,2,3,4          # a=1, b=2, c=nil, d=3
a, (b, c), d = [1,2,3,4]        # a=1, b=2, c=nil, d=3
a, (b, c), d = 1,[2,3],4        # a=1, b=2, c=3, d=4
a, (b, c), d = 1,[2,3,4],5      # a=1, b=2, c=3, d=5
a, (b,*c), d = 1,[2,3,4],5      # a=1, b=2, c=[3, 4], d=5Ruby中木有++和--运算符
</code></pre>

<h4>Conditional Execution</h4>

<pre><code>var ||= "default value"
</code></pre>

<p>相当于</p>

<pre><code>var = "default value" unless var 
</code></pre>

<h5>defined?</h5>

<pre><code>defined? 1          # =&gt; "expression"
defined? dummy      # =&gt; nil
defined? printf     # =&gt; "method"
defined? String     # =&gt; "contant"
defined? $_         # =&gt; "global-variable"
defined? Math::PI # =&gt; "constant"
defined? a = 1      # =&gt; "assignment"
defined? 42.abs     # =&gt; "method"
defined? nil        # =&gt; "nil"
</code></pre>

<h5>Comparing Objects</h5>

<p>除了boolean运算符，Ruby对象支持用方法==，===，&lt;=>, =~,eql?和equal?来比较,&lt;=>定义在Object类中,但通常被重写来实现类希望的语义,比如Array类重定义了==所以两个array对象只有在它们的元素个数一样，并且相应的元素也相等的情况下才真正的相等
==和=~都有相应地否定形式,!=和!~,如果调用!=或!~,Ruby首先寻找此类的!=或!~,如果发现就调用它们，如果不发现，就调用==或=~,然后再对结果取反</p>

<pre><code>class T
    def ==(other)
            puts "Comparing self == #{other}"
        other == "value" 
        end
end
t = T.new
p (t == "value") 
p (t != "value")
produces:
Comparing self == value
true
Comparing self == value
false
</code></pre>

<p>以上调用<code>t != "value"</code>时,首先调用t = &ldquo;value&rdquo;,然后再对结果取反
各操作符的意义如下</p>

<p><img src="/images/2014/7/operator.png"></p>

<h5>if and unless Expressions</h5>

<p>if then语句</p>

<pre><code>if artist == "Gillespie" then handle = "Dizzy"
elsif artist == "Parker" then handle = "Bird"
else
handle = "unknown" 
end
</code></pre>

<p>关键字<code>then</code>是optional的，如果你想将语句多行排列的话</p>

<pre><code>if artist == "Gillespie" 
    handle = "Dizzy"
elsif artist == "Parker" 
    handle = "Bird"
else
handle = "unknown" 
end
</code></pre>

<p>不过如果你想将then后对应的语句与if语句放在同一行，then是必不可少的!</p>

<pre><code>if artist == "Gillespie" then handle = "Dizzy" 
elsif artist == "Parker" then handle = "Bird" 
else handle = "unknown"
end
</code></pre>

<p>与if对应的是unless</p>

<pre><code>unless duration &gt; 180 
    listen_intently
end
</code></pre>

<h5>if and unless Modifiers</h5>

<pre><code>mon, day, year = $1, $2, $3 if date =~ /(\d\d)-(\d\d)-(\d\d)/ 
puts "a = #{a}" if $DEBUG
print total unless total.zero?
File.foreach("/etc/passwd") do |line|
next if line =~ /^#/ # Skip comments 
parse(line) unless line =~ /^$/ # Don't parse empty lines
end
</code></pre>

<h5>case Expressions</h5>

<ul>
<li>第一种形式
      case
          when song.name == &ldquo;Misty&rdquo;
          puts &ldquo;Not again!&rdquo;
          when song.duration > 120
          puts &ldquo;Too long!&rdquo;
          when Time.now.hour > 21
          puts &ldquo;It&rsquo;s too late&rdquo;
          else
          song.play
          end

<ul>
<li>第二种形式           case command
  when &ldquo;debug&rdquo;
    dump_debug_info
    dump_symbols
  when /p\s+(\w+)/
  dump_variable($1)
  when &ldquo;quit&rdquo;, &ldquo;exit&rdquo;
  exit
  else
  print &ldquo;Illegal command: #{command}&rdquo;
  end</li>
</ul>
</li>
<li><p>第三种形式
与then语句结合使用</p>

<pre><code>  kind = case year
  when 1850..1889 then "Blues"
  when 1890..1909 then "Ragtime"
  when 1910..1929 then "New Orleans Jazz" when 1930..1939 then "Swing"
  else "Jazz"
  end
</code></pre>

case的比较是用 <code>===</code>来比较的,所以，只要类为<code>===</code>定义了有意义的语义,此类的对象就能用在case语句中
需要<code>注意</code>的是,ruby的类是<code>Class</code>类的对象，===已经在Class类中定义了，可以用来测试相应的argument是否是receiver的instance或它的superclasses之一，所以你可以测试对象的类
  case shape
  when Square, Rectangle
  # &hellip;
  when Circle
  # &hellip;
  when Triangle
  # &hellip;
  else
  # &hellip;
  end

<h4>Loops</h4>

<p>while与until表达的意义相反
  while line = gets # &hellip;
  end   <br/>
  until play_list.duration > 60</p>

<p>  play_list.add(song_list.pop)
  end
  a=1
  a*=2 whilea<100 a # => 128
  a &ndash;= 10 until a &lt; 100 a # => 98</p></li>
</ul>


<p>range用作条件语句</p>

<pre><code>file = File.open("ordinal") 
while line = file.gets
    puts(line) if line =~ /third/ .. line =~ /fifth/ 
end
produces:
third
fourth
fifth
</code></pre>

<p>range中的起始位置也可以是表达式</p>

<pre><code>File.foreach("ordinal") do |line|       if (($. == 1) || line =~ /eig/) .. (($. == 3) || line =~ /nin/)     print line      end 
end
produces:
first
second
third
eighth
ninth如果你用`begin.....end`block，则不论while的条件语句是什么，都会`至少`执行一次
print "Hello\n" while false 
begin
    print "Goodbye\n" 
end while false
produces:
Goodbye
</code></pre>

<h4>Iterators</h4>

<pre><code>3.times do

print "Ho! "
end
produces:
Ho! Ho! Ho!
</code></pre>

<p>upto有使用</p>

<pre><code>0.upto(9) do |x|
print x, " "
end
produces:
0123456789step
0.step(12, 3) {|x| print x, " " } 
produces:
0 3 6 9 12
</code></pre>

<p>array的遍历</p>

<pre><code>[ 1, 1, 2, 3, 5 ].each {|val| print val, " " } 
produces:
11235
</code></pre>

<p>each</p>

<pre><code>File.open("ordinal").grep(/d$/) do |line| 

    puts line
end
produces:
second
third
</code></pre>

<p>loop的使用</p>

<pre><code>loop do     # block ... end
</code></pre>

<p>for&hellip;in</p>

<pre><code>for song in playlist

song.play
end
</code></pre>

<p>如果按以上这么写，则Ruby会将它翻译成</p>

<pre><code>playlist.each do |song|

    song.play
end你可以将for....in用在任何定义了each的方法的类上
for i in File.open("ordinal").find_all {|line| line =~ /d$/} 
    print i.chomp, " "
end

class Periods 
    def each
    yield "Classical" 
    yield "Jazz" 
    yield "Rock"
    end 
end
periods = Periods.new 
for genre in periods
print genre, " " end
produces:
Classical 
Jazz 
Rock
</code></pre>

<h5>break,redo,next</h5>

<p>break和next后面可以跟一个value</p>

<pre><code>result = while line = gets
            break(line) if line =~ /answer/
         end process_answer(result) if result
</code></pre>

<h4>作用域</h4>

<p>注意以下代码中,a的赋值语句虽然没有执行，但在之后的语句中a仍然可用</p>

<pre><code>a = "never used" if false 
[99].each do |i|
    a = i # this sets the variable in the outer scope 
end
a # =&gt; 99
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-29T22:17:21+08:00" data-updated="true" itemprop="datePublished">Jul 29<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/29/more-about-methods/" itemprop="url">More About Methods</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h5>定义一个方法</h5>

<p>一个方法用关键字def来定义，方法名应该以一个小写字母或一个下划线开头，紧跟着字母，数字和下划线,方法名也许以一个?,!或=号结尾，一个返回bool值的方法通常以一个?结果</p>

<pre><code>1.even? # =&gt; false 

2.even? # =&gt; true 

1.instance_of?(Fixnum) # =&gt; true
</code></pre>

<p>危险的方法，或是修改调用者的方法，可以用一个!来结尾,有时这些方法叫做<code>bang methods</code>,比如，类String提供了chop和chop！两种方法，前者返回了一个修改的string，后者则修改了调用此方法的字符串
能出现在赋值运算符<code>=</code>左边的方法以一个<code>=</code>结尾,如</p>

<pre><code>class BookInStock
        attr_reader :isbn, :price
    def initialize(isbn, price) 
    @isbn = isbn
    @price = Float(price)
    end
    def price=(new_price) 
    @price = new_price
    end     # ...   end
book = BookInStock.new("isbn1", 33.80) 
book.price = book.price * 0.75
</code></pre>

<p>有参和无参方法定义如下</p>

<pre><code>def my_new_method(arg1, arg2, arg3) # 3 arguments 

    # Code for the method would go here end
def my_other_new_method # No arguments 
    # Code for the method would go here     end
</code></pre>

<p>可以为参数指定默认值</p>

<pre><code>    def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach") 
    "#{arg1}, #{arg2}, #{arg3}."
end

cool_dude                           # =&gt; "Miles, Coltrane, Roach."
            cool_dude("Bart")                   # =&gt; "Bart, Coltrane, Roach."
cool_dude("Bart", "Elwood")         # =&gt; "Bart, Elwood, Roach."
cool_dude("Bart", "Elwood", "Linus") # =&gt; "Bart, Coltrane, Linus."
</code></pre>

<p>后一个参数的默认值也可以指定为与前一个参数相关的表达式</p>

<pre><code>def surround(word, pad_width=word.length/2) 
    "[" * pad_width + word + "]" * pad_width
end
surround("elephant") # =&gt; "[[[[elephant]]]]" 
surround("fox") # =&gt; "[fox]"
surround("fox", 10) # =&gt; "[[[[[[[[[[fox]]]]]]]]]]"#####可变参数
def varargs(arg1, *rest)
    "arg1=#{arg1}. rest=#{rest.inspect}"
end
varargs("one")                  # =&gt; arg1=one.  rest=[]
varargs("one", "two")           # =&gt; arg1=one.  rest=["two"]
varargs "one", "two", "three"   # =&gt; arg1=one.  rest=["two", "three"]   
</code></pre>

<p>有时我们用*来指定不被此类方法但被superclass中的此同名方法调用的参数,注意这种情况下我们直接调用super(无任何参数)，这种特殊的情况下意味着&#8221;在superclass中调用此方法，此所有的参数传到此类super的同名方法&#8221;</p>

<pre><code>class Child &lt; Parent
def do_something(*not_used)
    # our processing
super end
end
</code></pre>

<p>你也可以只写一个*</p>

<pre><code>class Child &lt; Parent 

    def do_something(*)
            # our processing
            super 
        end
end
</code></pre>

<p>你可以将带*的参数放在方法参数列表的任意位置</p>

<pre><code>def split_apart(first, *splat, last)
        puts "First: #{first.inspect}, splat: #{splat.inspect}, " +     "last: #{last.inspect}" 
end
split_apart(1,2)
split_apart(1,2,3)
split_apart(1,2,3,4)
produces:
First: 1, splat: [], last: 2
First: 1, splat: [2], last: 3
First: 1, splat: [2, 3], last: 4
你也可以只关心起始的参数，这样，你可以像以下这样定义方法
def split_apart(first, *, last)
</code></pre>

<h5>Methods and Blocks</h5>

<p>方法可以用yield来调用与它相关联的block</p>

<pre><code>def double(p1) yield(p1*2)
end
double(3) {|val| "I got #{val}" } # =&gt; "I got 6" 
double("tom") {|val| "Then I got #{val}" } # =&gt; "Then I got tomtom"如果一个方法的最后一个参数以&amp;开头，任何相关的block都能当作参数传入方法并被转化为一个Proc对象
class TaxCalculator
    def initialize(name, &amp;block)
            @name, @block = name, block
        end
        def get_tax(amount)
            "#@name on #{amount} = #{ @block.call(amount) }" 
        end
end
tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 } 
tc.get_tax(100) # =&gt; "Sales tax on 100 = 7.5"
tc.get_tax(250) # =&gt; "Sales tax on 250 = 18.75"
</code></pre>

<h5>调用方法</h5>

<pre><code>connection.download_mp3("jitterbug") {|p| show_progress(p) } //对象

File.size("testfile") # =&gt; 66           //类

Math.sin(Math::PI/4) # =&gt; 0.7071067811865475    //Module
</code></pre>

<p>如果省略了receiver,默认是self</p>

<pre><code>class InvoiceWriter
        def initialize(order)

        @order = order
                end
    def write_on(output)
        write_header_on(output)
        write_body_on(output)
        write_totals_on(output)
    end

private     def write_header_on(output)
    # ...
    end
    def write_body_on(output)
    # ...
    end
    def write_totals_on(output)
    # ...
    end 
end#####将参数传给方法
</code></pre>

<p>在不引起歧义的情况下，你可以省略括号，不过通常不推荐这么做</p>

<pre><code># for some suitable value in 
obj: a = obj.hash # Same as
a = obj.hash() # this.
obj.some_method "Arg1", arg2, arg3 # Same thing as //1.8之前
obj.some_method("Arg1", arg2, arg3) # with parentheses. 如果你将多个参数传给return语句，方法将会以数组的形式返回这些参数
def meth_three 100.times do |num|
   square = num*num
return num, square if square &gt; 1000 end
end
meth_three # =&gt; [32, 1024]
</code></pre>

<p>你可以按以下方式来获取返回的值</p>

<pre><code>num, square = meth_three 
num # =&gt; 32
square # =&gt; 1024    
</code></pre>

<h5>*!在方法调用中展开Collections</h5>

<pre><code>def five(a, b, c, d, e)
    "I was passed #{a} #{b} #{c} #{d} #{e}"
end
five(1,2,3,4,5) #=&gt;"Iwaspassed12345" 
five(1, 2, 3, *['a', 'b']) # =&gt; "I was passed 1 2 3 a b" 
five(*['a', 'b'], 1, 2, 3) # =&gt; "I was passed a b 1 2 3" five(*(10..14)) 
#=&gt;"Iwaspassed1011121314" 
five(*[1,2], 3, *(4..5)) #=&gt;"Iwaspassed12345"
</code></pre>

<p>Ruby 1.9中， 带*参数可以出现参数列表中的任意位置</p>

<h5>Block的妙用</h5>

<p>先来看一段代码</p>

<pre><code>print "(t)imes or (p)lus: " operator = gets
print "number: "
number = Integer(gets)
if operator =~ /^t/
puts((1..10).collect {|n| n*number }.join(", "))
else
puts((1..10).collect {|n| n+number }.join(", ")) 
end
produces:
(t)imes or (p)lus: t
number: 2
2, 4, 6, 8, 10, 12, 14, 16, 18, 20
</code></pre>

<p>以上的代码能工作，但是很丑陋，我们注意到if和else的语句几乎一样，可以用block来改进如下</p>

<pre><code>print "(t)imes or (p)lus: " 
operator = gets
print "number: "
number = Integer(gets)
if operator =~ /^t/
calc = lambda {|n| n*number }
else
  calc = lambda {|n| n+number }
end
puts((1..10).collect(&amp;calc).join(", "))
produces:
(t)imes or (p)lus: t
number: 2
2, 4, 6, 8, 10, 12, 14, 16, 18, 20
</code></pre>

<p>如果方法的最后一个参数是以&amp;开头的，则Ruby认为它是一个Proc对象，方法将它移除出参数列表，然后将Proc对象转为block，再与方法关联</p>

<h5>Hash and Keyword Arguments</h5>

<p>先来看一段代码</p>

<pre><code>class SongList
    def search(field, params)
        # ...
        end 
end
list = SongList.new
list.search(:titles, { genre: "jazz", duration_less_than: 270 })
</code></pre>

<p>实际上这种方式不值得推荐，{}很容易让人误认为是一个block，所以Ruby提供了一个捷径，在参数列表中你可以传入key => value这种形式,只要它们跟在正常的参数之后，在任何的*和block参数之前，所有的这些键值对都将被组装成一个hash参数传入方法中,可以略去{}</p>

<pre><code>list.search(:titles, genre: "jazz", duration_less_than: 270)
</code></pre>

<h5>Keyword Argument Lists</h5>

<p>我们仔细研究一下search方法，它接受一个field的名字和一个options hash,也许我们想要默认的duration为120s，并且加入验证方法-非法的验证不让它通过</p>

<p>Ruby 2.0之前，代码是这么写的</p>

<pre><code>def search(field, options)
    options = { duration: 120 }.merge(options) 
    if options.has_key?(:duration)
        duration = options[:duration]
        options.delete(:duration)
    end
    if options.has_key?(:genre)
        genre = options[:genre]
        options.delete(:genre)
    end
    fail "Invalid options: #{options.keys.join(', ')}" unless options.empty? 
    # rest of method
end 如果是Ruby 2.0，可以简化为以下
def search(field, genre: nil, duration: 120) 
    p [field, genre, duration ]
end search(:title)
search(:title, duration: 432)
search(:title, duration: 432, genre: "jazz")
produces:
[:title, nil, 120]
[:title, nil, 432]
[:title, "jazz", 432]
</code></pre>

<p>如果传入的是一个非法选项，Ruby将会报错</p>

<pre><code>search(:title, duraton: 432)
produces:
//是duration，不是duraton!  prog.rb:5:in `&lt;main&gt;': unknown keyword: duraton (ArgumentError)
</code></pre>

<p>你也可以将多个hash参数整合为一个hash参数，只要在方法的参数列表里在某参数的前面加<code>两个</code>星号</p>

<pre><code>def search(field, genre: nil, duration: 120, **rest) 
    p [field, genre, duration, rest ]
end
search(:title, duration: 432, stars: 3, genre: "jazz", tempo: "slow") 
produces:
[:title, "jazz", 432, {:stars=&gt;3, :tempo=&gt;"slow"}]
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-29T12:59:58+08:00" data-updated="true" itemprop="datePublished">Jul 29<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/29/regular-expression/" itemprop="url">Regular Expression</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>正则表达式如下</p>

<pre><code>/cat/

/123/
</code></pre>

<p>正则表达式<code>/.../</code>里的常量和双引号的字符串类似,实际上，你可以在正则里，你也可以用<code>#{...}</code>表达式的替换形式</p>

<h5>Matching Strings with Patterns</h5>

<pre><code>/cat/ =~ "dog and cat" # =&gt; 8 

/cat/ =~ "catch" # =&gt; 0 

/cat/ =~ "Cat" # =&gt; nil
</code></pre>

<p>如果你喜欢也可以把字符串放在前面</p>

<pre><code>"dog and cat" =~ /cat/ # =&gt; 8 

"catch" =~ /cat/ # =&gt; 0 

"Cat" =~ /cat/ # =&gt; nil
</code></pre>

<p>模式匹配如果失败，会返回nil、，而nil在条件表达式中相当于false，所以可以把正则表达式的匹配结果作为if和while的条件语句</p>

<pre><code>str = "cat and dog"
    if str =~ /cat/
puts "There's a cat here somewhere"
end
produces:
There's a cat here somewhere
</code></pre>

<p>以下的代码打印&#8221;testfile&#8221;文件中有&#8221;on&#8221;字符串的行</p>

<pre><code>File.foreach("testfile").with_index do |line, index| 

puts "#{index}: #{line}" if line =~ /on/
    end
produces:
0: This is line one
3: And so on...你可以用!~来查找`不匹配`的字符串

File.foreach("testfile").with_index do |line, index| 

    puts "#{index}: #{line}" if line !~ /on/
        end
produces:
1: This is line two
2: This is line three
</code></pre>

<h5>Changing Strings with Patterns</h5>

<p>sub方法用来查找并替换匹配的字符串</p>

<pre><code>str = "Dog and Cat"
    new_str = str.sub(/Cat/, "Gerbil")
puts "Let's go to the #{new_str} for a pint."
produces:
Let's go to the Dog and Gerbil for a pint.
</code></pre>

<p>sub只是替换第一个匹配的，要替换全局匹配的，就用gsub</p>

<pre><code>str = "Dog and Cat"
    new_str1 = str.sub(/a/, "*") 
new_str2 = str.gsub(/a/, "*") 
puts "Using sub: #{new_str1}" 
puts "Using gsub: #{new_str2}"
produces:
Using sub: Dog *nd Cat
Using gsub: Dog *nd C*t 
</code></pre>

<p>需要注意的是，sub和gsub都返回一个全新的string,不论是否替换！如果替换，也返回原string的一个copy
如果你想要修改原始的string，你可以用sub!和gsub!的形式</p>

<pre><code>str = "now is the time" 

str.sub!(/i/, "*") 

str.gsub!(/t/, "T") 

puts str
    produces:
now *s The Time
</code></pre>

<p>不过不像sub和gsub，sub!和gsub!只有在匹配正则表达式时才返回string，如果不匹配，则返回nil，这意味着你可以将它放在条件语句中</p>

<h5>Digging Deeper</h5>

<p>未完待续&hellip;.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-28T08:10:44+08:00" data-updated="true" itemprop="datePublished">Jul 28<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/28/standard-types/" itemprop="url">Standard Types</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p> 这一章主要介绍Ruby中的几个标准类型:numbers,strings,ranges,regular expressions</p>

<h4>Numbers</h4>

<p>Integers可以是任何长度(内存有多大，长度就有多大),在一定范围内(通常是pow(-2,30)&hellip;pow(2,30)-1或是pow(-2,62)&hellip;pow(2,62)-1)的Integers是类Fixnum的对象,超出此范围的则是类Bignum的对象,这个转化过程由Ruby自动来处理</p>

<pre><code>num = 10001 4.times do
    puts "#{num.class}: #{num}" num *= num
end
    produces:
       Fixnum: 10001
       Fixnum: 100020001
       Fixnum: 10004000600040001
       Bignum: 100080028005600700056002800080001
</code></pre>

<p>我们可以在数字前添加0x,0b等前缀,或是下划线</p>

<pre><code>123456 =&gt; 123456    # Fixnum
0d123456 =&gt; 123456      # Fixnum
123_456 =&gt; 123456       # Fixnum - underscore ignored
-543 =&gt; -543            # Fixnum - negative number
0xaabb =&gt; 43707         # Fixnum - hexadecimal
0377 =&gt; 255             # Fixnum - octal
-0b10_1010 =&gt; -42       # Fixnum - binary (negated)
123_456_789_123_456_789 =&gt; 123456789123456789 # Bignum
</code></pre>

<p>Ruby支持rational和complex number,Rational numbers是两个整数的比</p>

<pre><code>Rational(3, 4) * Rational(2, 3) # =&gt; (1/2) Rational("3/4") * Rational("2/3") # =&gt; (1/2)
Complex(1, 2) * Complex(3, 4) # =&gt; (-5+10i) Complex("1+2i") * Complex("3+4i") # =&gt; (-5+10i)
</code></pre>

<p>需要注意的是,不像Perl，在表达式计算时，Strings中的数字并不会自动转为数字
假设有一个文字如下，我们需要计算每行两个数字的和</p>

<pre><code>3   4 

5   6 

7   8
</code></pre>

<p>以下的代码并不工作</p>

<pre><code>some_file.each do |line| 

v1, v2 = line.split         # split line on spaces

print v1 + v2, " "
    end
produces:
34 56 78
</code></pre>

<p>应该先把strings转为integers</p>

<pre><code>some_file.each do |line|
    v1, v2 = line.split
print Integer(v1) + Integer(v2), " "
end
produces:
7 11 15
</code></pre>

<h5>How Number interact</h5>

<pre><code>1 + 2                   # =&gt; 3
1 + 2.0                 # =&gt; 3.0
1.0+2                   # =&gt; 3.0

1.0 + Complex(1,2)      # =&gt; (2.0+2i)
1 + Rational(2,3)       # =&gt; (5/3)
1.0 + Rational(2,3)     # =&gt; 1.6666666666666665
</code></pre>

<p>如果你需要除法能返回 一个Rational number,则需引入mathn库,这个库能帮我们以最<code>自然</code>的方式展示两数运算的结果</p>

<pre><code>22 / 7 # =&gt; 3

Complex::I * Complex::I # =&gt; (-1+0i)
require 'mathn' 22 / 7 # =&gt; (22/7) 
Complex::I * Complex::I # =&gt; -1
</code></pre>

<h5>Looping Using Numbers</h5>

<pre><code>3.times { print "X " } 

1.upto(5) {|i| print i, " " } 

99.downto(95) {|i| print i, " " } 

50.step(80, 5) {|i| print i, " " }

produces:
    X X X 1 2 3 4 5 99 98 97 96 95 50 55 60 65 70 75 80
</code></pre>

<p>同其他迭代器一样，如果其后没有block，则会返回一个Enumerator对象</p>

<pre><code>10.downto(7).with_index {|num, index| puts "#{index}: #{num}"}
produces:
   0: 10
   1: 9
   2: 8
   3: 7
</code></pre>

<h4>Strings</h4>

<p>String有两种组成方式，单引号和双引号组成的string
单引号</p>

<pre><code> 'escape using "\\"'   # =&gt; escape using "\"
      'That\'s right'       # =&gt; That's right
</code></pre>

<p>如果是双引号,你可以用#{expr}来替换strings里的值,如果expr是个全局变量，类变量，或是一个类的实例,花括号可以省略</p>

<pre><code>"Seconds/day: #{24*60*60}" 

"#{'Ho! '*3}Merry Christmas!" "Safe level is #$SAFE"
    # =&gt; Seconds/day: 86400
# =&gt; Ho! Ho! Ho! Merry Christmas!
    # =&gt; Safe level is 0
</code></pre>

<p>{}里的代码不一定只是一个表达式，也可以由多条语句构成</p>

<pre><code>puts "now is #{ def the(a)
                 'the ' + a
                end
                the('time')
                } for all bad coders..."
produces:
now is the time for all bad coders...
</code></pre>

<p>你还可以用另外三种方式来构建一个string常量:%q,%Q以及here documents
你可以把%q看成是单引号,%Q看成是双引号</p>

<pre><code>%q/general single-quoted string/        # =&gt; general single-quoted string

%Q!general double-quoted string!        # =&gt; general double-quoted string

%Q{Seconds/day: #{24*60*60}}            # =&gt; Seconds/day: 86400
</code></pre>

<p>实际上Q是可有可无的</p>

<pre><code>%!general double-quoted string! # =&gt; general double-quoted string 

%{Seconds/day: #{24*60*60}} # =&gt; Seconds/day: 86400
</code></pre>

<p>实际上紧跟在q或Q后的是分隔符,分隔符可以由任何<code>nonalphanumeric</code> 或 <code>nonmultibyte</code>字符组成
最后,我们来看看如何用<code>here document</code>来创建string</p>

<pre><code>string = &lt;&lt;END_OF_STRING
    The body of the string is the input lines up to     one starting with the same text that followed the '&lt;&lt;'  END_OF_STRING
</code></pre>

<p>通常terminator从第一行开始，不过，如果你把一个负号放在&lt;&lt;后，你可以对terminator进行缩进，创建的string也会进行缩进</p>

<pre><code>string = &lt;&lt;-END_OF_STRING
    The body of the string is the input lines up to     one starting with the same text that followed the '&lt;&lt;'  END_OF_STRING
</code></pre>

<p>你也可以将多个here documents放在同一行上，每一个代表一个单独的string,here document的bodies从source lines中依次获取</p>

<pre><code>print &lt;&lt;-STRING1, &lt;&lt;-STRING2 
Concat
STRING1
      enate
      STRING2
produces:
Concat 
    enate
</code></pre>

<p> 注意在此情况下Ruby并不会将enate前的空格给去掉</p>

<h4>Strings and Encodings</h4>

<p>每一个string都有一个对应的encoding,一个string的默认的encoding取决于包含它的源文件的encoding,如果没有指明显式的encoding,一个源文件(和它的string)在Ruby 1.9用的是US-ASCII编码，Ruby 2则是UTF-8</p>

<pre><code>plain_string = "dog"
    puts RUBY_VERSION
puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}"

produces:
2.0.0
Encoding of "dog" is UTF-8
</code></pre>

<p>如果你在文件的开头指明用了哪个encoding,文件中所有的string都 会用此encoding</p>

<pre><code>#encoding: utf-8
plain_string = "dog"
puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}" utf_string = "δog"
puts "Encoding of #{utf_string.inspect} is #{utf_string.encoding}"
produces:
Encoding of "dog" is UTF-8
Encoding of "δog" is UTF-8
</code></pre>

<h6>Working with Strings</h6>

<p>假设一个文件有以下格式</p>

<pre><code>/jazz/j00132.mp3  | 3:45 | Fats     Waller     | Ain't Misbehavin'
/jazz/j00319.mp3  | 2:58 | Louis    Armstrong  | Wonderful World
/bgrass/bg0732.mp3| 4:09 | Strength in Numbers | Texas Red
</code></pre>

<p>现在我们要做以下三件事情</p>

<ol>
<li>将每一行分解成fields</li>
<li>将时间从mm:ss转为秒</li>
<li><p>移除artist中名字中的空格
先来看看第一步</p>

<pre><code>  Song = Struct.new(:title, :name, :length)
  File.open("songdata") do |song_file| songs = []
  song_file.each do |line|
  file, length, name, title = line.chomp.split(/\s*\|\s*/) 

  name.squeeze!(" ")      songs &lt;&lt; Song.new(title, name, length)
  end
    puts songs[1]
  end
  produces:
  #&lt;struct Song title="Wonderful World", name="Louis Armstrong", length="2:58"&gt;
</code></pre>

<p>注意上面的line.chomp,因为每一行都有一个换行符，所以必须把它去掉
来看下如何处理时间,用split也可以，但我们用更好的方式scan</p>

<pre><code>  Song = Struct.new(:title, :name, :length) 

  File.open("songdata") do |song_file|
  songs = []
  song_file.each do |line|
  file, length, name, title = line.chomp.split(/\s*\|\s*/) 
  name.squeeze!(" ")
  mins, secs = length.scan(/\d+/)
  songs &lt;&lt; Song.new(title, name, mins.to_i*60 + secs.to_i)
  end
  puts songs[1]
  end
  produces:
  #&lt;struct Song title="Wonderful World", name="Louis Armstrong", length=178&gt;####Ranges
</code></pre>

<p>ranges主要用在以下三个方面:sequences, conditions和intervals</p></li>
</ol>


<p>1.Ranges as Sequences</p>

<pre><code>1..10
'a'..'z' 0..."cat".length
</code></pre>

<p>你可以用to_a将一个range转为一个数组,用to_enum将它转为一个Enumberator</p>

<pre><code>(1..10).to_a # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 


('bar'..'bat').to_a # =&gt; ["bar", "bas", "bat"]
enum = ('bar'..'bat').to_enum
enum.next # =&gt; "bar"
enum.next # =&gt; "bas"
</code></pre>

<p>Ranges有很多方法能让你遍历它们并且用很多方法测试它们</p>

<pre><code>digits = 0..9
digits.include?(5) # =&gt; true
digits.max # =&gt; 9
digits.reject {|i| i &lt; 5 } # =&gt; [5, 6, 7, 8, 9] 
</code></pre>

<p>digits.inject(:+) # => 45
目前我们已经看到了numbers和strings的ranges，实际上，ranges也可以基于你定义的对象来创建,惟一的要求是对象必须定义succ方法，这个方法返回了序列中的下一个对象，这个对象还必须实现<code>&lt;=&gt;</code>(有时称为<code>spaceship operator</code>),允许对象之间的比较,返回-1,0, 1</p>

<pre><code>class PowerOfTwo 
    attr_reader :value 
    def initialize(value)
        @value = value
    end
    def &lt;=&gt;(other)
        @value &lt;=&gt; other.value
    end
    def succ
        PowerOfTwo.new(@value + @value)
    end
    def to_s
    @value.to_s
    end 

end
p1 = PowerOfTwo.new(4)
p2 = PowerOfTwo.new(32)
puts (p1..p2).to_a
produces:
4 
8 
16 
32
</code></pre>

<h5>Ranges as Conditions</h5>

<pre><code>while line = gets
    puts line if line =~ /start/ .. line =~ /end/
end
</code></pre>

<h5>Ranges as Intervals</h5>

<p>可以借此来查看某些值是否在range间,注意必须用<code>===</code></p>

<pre><code>(1..10) === 5 # =&gt; true

(1..10) === 15 # =&gt; false 

(1..10) === 3.14159 # =&gt; true 

('a'..'j') === 'c' # =&gt; true 

('a'..'j') === 'z' # =&gt; false还可用在case中
car_age = gets.to_f # let's assume it's 9.5 
case car_age
when 0...1
    puts "Mmm.. new car smell" 
when 1...3
puts "Nice and new" 
when 3...10
    puts "Reliable but slightly dinged" 
when 10...30
    puts "Clunker" 
else
    puts "Vintage gem" 

end
produces:
Reliable but slightly dinged
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-27T15:03:31+08:00" data-updated="true" itemprop="datePublished">Jul 27<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/27/sharing-functionality-inheritance/" itemprop="url">Sharing Functionality: Inheritance</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4>继承和消息</h4>

<pre><code>class Parent 

    def say_hello   
    puts "Hello from #{self}" 
    end
end
p = Parent.new
p.say_hello
    class Child &lt; Parent # Subclass the parent...

end 
c = Child.new
c.say_hello
produces:
Hello from #&lt;Parent:0x007fb87110fd98&gt;
Hello from #&lt;Child:0x007fb87110fac8&gt;
</code></pre>

<p>superclass的方法返回了一个类的父类</p>

<pre><code>class Parent
end
class Child &lt; Parent
end
Child.superclass # =&gt; Parent
</code></pre>

<p>那么，Parent的superclass是什么</p>

<pre><code>class Parent
end
Parent.superclass # =&gt; Object
</code></pre>

<p>继续探究</p>

<pre><code>Object.superclass # =&gt; BasicObject
BasicObject.superclass.inspect # =&gt; "nil"
</code></pre>

<p>我们可以看到在继承体系中BasicObject是root class</p>

<h4>Modules</h4>

<p>Modules提供了一种将方法，类和常量聚合在同一空间名下的方式,Modules提供了两大优势</p>

<ol>
<li>Modules提供了一个命名空间，并且防止了命名冲突</li>
<li><p>Modules支持mixin的功能</p>

<pre><code> //trig.rb
 module Trig
     PI = 3.141592654 

     def Trig.sin(x)
     # ..
     end
     def Trig.cos(x) 

         # ..
     end 
 end
 //moral.rb
 module Moral
     VERY_BAD = 0
     BAD =1
     def Moral.sin(badness)
     # ...
     end 
 end
</code></pre>

<p>来看看如何使用它们</p>

<pre><code>  require_relative 'trig' 
  require_relative 'moral'
  y = Trig.sin(Trig::PI/4)
  wrongdoing = Moral.sin(Moral::VERY_BAD)
</code></pre>

<h4>Mixins</h4>

<p>Modules还有另外一个很好用的功能，它们可以在很大程序上避免继承的使用,这种方式叫mixin.
从以上的module的demo中我们可以看到，如果我们定义modules的方法，这些方法前面加了module的名字,如果你想到了类方法，那么你可能会想&#8221;我是否能在module里定义instance方法&#8221;!好问题，一个module不能有instances，因为modules不是类，不过你可以将一个module添加到一个类的定义中，这样，所有的modules的instance方法就同类中的instance方法一样可用了，它们mixed in了，实际上 mixed-in 模块有效地充当了superclass的角色
来看下demo</p>

<pre><code>  module Debug 

      def who_am_i?
          "#{self.class.name} (id: #{self.object_id}): #{self.name}"          end
  end
  class Phonograph 
      include Debug 
      attr_reader :name 
      def initialize(name)

      @name = name
  end
  # ...       end
  class EightTrack 
  include Debug 
      attr_reader :name 
      def initialize(name)
      @name = name
  end
  # ...
  end
  ph = Phonograph.new("West End Blues")
  et = EightTrack.new("Surrealistic Pillow")
  ph.who_am_i? # =&gt; "Phonograph (id: 70266478767560): West End Blues" 
  et.who_am_i? # =&gt; "EightTrack (id: 70266478767520): Surrealistic Pillow"
</code></pre></li>
</ol>


<p>mixin的真正威力在mixin的代码开始与使用它的类的代码进行交互时才得以体现出现,我们用Ruby的Mixin Comparable来作一个例子,Comparable mixin为类添加了比较方法(&lt;, &lt;=, ==, >=, 和 >)和between?方法，为了让Comparable工作,Comparable假设所有使用它的类定义了操作符<code>&lt;=&gt;</code></p>

<pre><code>class Person
    include Comparable 
    attr_reader :name
        def initialize(name) 
            @name = name
        end
        def to_s
            "#{@name}" 
        end
        def &lt;=&gt;(other)
            self.name &lt;=&gt; other.name
        end 
    end
p1 = Person.new("Matz") 
p2 = Person.new("Guido")
    p3 = Person.new("Larry") # Compare a couple of names
if p1 &gt; p2
puts "#{p1.name}'s name &gt; #{p2.name}'s name"
end
# Sort an array of Person objects
puts "Sorted list:" 

puts [ p1, p2, p3].sort
</code></pre>

<p>produces:</p>

<pre><code>Matz's name &gt; Guido's name
Sorted list:
Guido
Larry
Matz
</code></pre>

<h4>Iterators and the Enumerable Module</h4>

<p>Ruby的collections类(Array, Hash等)支持许多针对collections的操作:遍历，排序等，你可能会想:&ldquo;如果我的类也支持这些操作该多好&rdquo;</p>

<p>好消息是，由于mixins和module Enumberable的存在,你的类能支持所有的这些特性，你需要做的只是写一个each的迭代器，依次返回你的collection里的元素，然后include Enumerable,这样你的类就支持map,include?,find_all?这些方法了，如果在你的collection里的对象用<code>&lt;=&gt;</code>来实现了一些有意义的排序相关的方法，你也能使用如min,max,sort等的方法</p>

<h4>Composing Modules</h4>

<p>Enumerable是一个标准的mixin,实现了针对host class中的each相关的许多方法,其中一个是我们之前提到的inject方法，由于要用inject就得include Enumerable，我们能将它用在任何include Enumerable并且实现了each方法的类里
来看看许多内置类对它的使用</p>

<pre><code>[ 1, 2, 3, 4, 5 ].inject(:+) # =&gt; 15
( 'a'..'m').inject(:+) # =&gt; "abcdefghijklm"
</code></pre>

<p>来看看如何定义我们自己的类来使用Enumerable中的inject</p>

<pre><code>//vowel_finder.rb
class VowelFinder 
    include Enumerable
    def initialize(string)
     @string = string
    end
    def each
        @string.scan(/[aeiou]/) do |vowel| 
        yield vowel
        end 

    end
end vf = VowelFinder.new("the quick brown fox jumped")  vf.inject(:+) # =&gt; "euiooue"
</code></pre>

<p>我们还能将inject的方法封装在module的方法中，如下</p>

<pre><code>module Summable 
    def sum         inject(:+)      end end class Array         include Summable    end class Range         include Summable    end
    require_relative "vowel_finder" 
class VowelFinder
  include Summable
end
[1,2,3,4,5].sum #=&gt;15 

('a'..'m').sum # =&gt; "abcdefghijklm"
vf = VowelFinder.new("the quick brown fox jumped") 

vf.sum # =&gt; "euiooue"#### Instance Variables in Mixins
</code></pre>

<p>从C++转过来的程序员通常会问&#8221;在mixin里的instance variable是如何处理的&#8221;
在Ruby中instace variables是这么工作的
以@开头的变量在当前的对象(self)里创建instace variable
对一个mixin而言,如果你在一个类中include了module,你的类对象将创建module里的instance variable并且可以用attr_reader和friends来定义accessors,比如,以下例子中的Observable module为每一个include它的类都添加了@observer_list的instance variable</p>

<pre><code>//observer_impl.rb

module Observable 

    def observers

        @observer_list ||= []
    end
    def add_observer(obj)
        observers &lt;&lt; obj
    end
    def notify_observers
        observers.each {|o| o.update }
    end 

end
</code></pre>

<p>然而这种方式可能会导致一些不可预知的错误,一个mixin的instance variables可能会与inclde它的host class定义的instance variables相冲突,以下的例子显示了一个使用我们的Observer module的类的例子，很不幸的是，它也定义了一个叫做@observer_list的instance variable,在运行时，这个程序可能会导致某些难以调试的错误</p>

<pre><code>require_relative 'observer_impl' 
class TelescopeScheduler
    # other classes can register to get notifications # when the schedule changes
    include Observable
    def initialize
    @observer_list = [] # folks with telescope time
    end
    def add_viewer(viewer)
        @observer_list &lt;&lt; viewer
    end
    # ...
end
</code></pre>

<p>所以，大部分情况下,mixin modules并不直接使用instance variables,它们用accessors来从client对象获取信息,不过如果你需要创建一个有它自己状态的mixin,你需要确保这些instance variables<code>必须</code>要有惟一的名字，或者也可以创建一个module-level的hash，(key用当前对象的ID表示)来存储instance-specific的data</p>

<pre><code>module Test
    State = {}
    def state=(value)
        State[object_id] = value
    ￼￼end

    def state State[object_id]
    end 
end
class Client 
    include Test
end
c1 = Client.new
c2 = Client.new 
c1.state = 'cat' 
c2.state = 'dog' 
c1.state # =&gt; "cat" 
c2.state # =&gt; "dog"
</code></pre>

<p>使用这种方法的坏处就是，和某个特别的对象关联的数据在此对象被删后并不会马上释放，通常来说，一个需要维护它自己状态的mixin不应该是个mixin，它应该被写成一个类</p>

<h4>Resolving Ambiguous Method Names</h4>

<p>如果多个被include的mixins，此类，此类的父类中有相同的方法该如何处理
Ruby会首选查看一个对象的类中的方法，然后是被include到mixins,然后是superclass以及其中的mixins,如果一个为类include了多个mixins,最后被include的mixin首先被搜索到</p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2014 - AllenToFight -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
	

<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->







		</div>
	</div>
</body>
</html>
