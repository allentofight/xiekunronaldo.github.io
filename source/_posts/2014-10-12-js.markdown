---

layout: post
title: "Speaking Javascript学习笔记"
date: 2014-10-12 14:22:28 +0800
comments: true
categories: javascript
---

### Primitive Values Versus Objects
JavaScript makes a somewhat arbitrary distinction between values:

* The primitive values are booleans, numbers, strings, null, and undefined.* All other values are objects.
A major difference between the two is how they are compared; each object has a uniqueidentity and is only (strictly) equal to itself:

```javascript
> var obj1 = {}; // an empty object> var obj2 = {}; // another empty object > obj1 === obj2false> obj1 === obj1true
```

#### Primitive Values

* Booleans: true, false * Numbers: 1736, 1.351 * Strings: 'abc', "abc" * Two “nonvalues”: undefined, null 
Primitives have the following characteristics:
* Compared by value
```javascript
> 3 === 3true> 'abc' === 'abc'true```

* Always immutable

	Properties can’t be changed, added, or removed:

```javascript
	 > var str = 'abc';     > str.length = 1; // try to change property `length`     > str.length // ⇒ no effect 3	 > str.foo = 3; // try to create property `foo`	 >str.foo // ⇒ no effect, unknown property undefined
```
#### Objects
All nonprimitive values are objects.The most common kinds of objects are:

* Plain objects

```javascript
 {            firstName: 'Jane',            lastName: 'Doe'}
```
* Arrays

```javascript
[ 'apple', 'banana', 'cherry' ]
```
* Regular expressions

```javascript
/^a+b+$/
```
Objects have the following characteristics:

* Compared by reference
Identities are compared; every value has its own identity:

```javascript
 > {} === {}  // two different empty objectsfalse
> var obj1 = {}; 
> var obj2 = obj1; 
> obj1 === obj2 
true
```
* Mutable by default
You can normally freely change, add, and remove properties

```javascript
> var obj = {};> obj.foo = 123; // add property `foo` > obj.foo123
```
#### undefined and null

Most programming languages have values denoting missing information. JavaScript has two such “nonvalues,” undefined and null:

* undefined means “no value.” Uninitialized variables are undefined:

```javascript
> var foo; 
> foo 
undefined
```
Missing parameters are undefined:

```javascript
> function f(x) { return x } 
> f()undefined
```
If you read a nonexistent property, you get undefined:

```javascript
> var obj = {}; // empty object 
> obj.fooundefined
```
* null means “no object.” It is used as a nonvalue whenever an object is expected (parameters, last in a chain of objects, etc.)

`Note`

undefined and null have no properties, not even standard meth‐ ods such as toString().

#### Checking for undefined or null

```javascript
if (x === undefined || x === null) { 
	...}
```
You can also exploit the fact that both undefined and null are considered false:

```javascript
if (!x) { 
	...}
```
`Note`

false, 0, NaN, and '' are also considered false

#### Categorizing Values Using typeof and instanceof
There are two operators for categorizing values: `typeof` is mainly used for primitive values, while `instanceof` is used for objects.

typeof looks like this:

```javascript
typeof value

> typeof true'boolean'> typeof 'abc''string'> typeof {} // empty object literal'object'> typeof [] // empty array literal'object'
```
The following table lists all results of typeof:

 Operand | Result
------------ | ------------- 
undefined | undefined  
null | 'object'
Boolean value | 'boolean'
Number value | 'number'
String value | 'string'
Function | 'function'
All other normal values | 'object'
(Engine-created value) | JavaScript engines are allowed to create values for whichtypeofreturns arbitrary strings (different from all results listed in this table).

`Note`
typeof null returning 'object' is a bug that can’t be fixed, because it would break existing code. It does not mean that null is an object.

instanceof looks like this:

```javascript
value instanceof Constr
```
It returns true if value is an object that has been created by the constructor Constr

```javascript
> var b = new Bar(); // object created by constructor Bar > b instanceof Bartrue> {} instanceof Objecttrue> [] instanceof Arraytrue> [] instanceof Object  // Array is a subconstructor of Objecttrue> undefined instanceof Objectfalse> null instanceof Objectfalse
```
#### Truthy and Falsy
The following values are interpreted as false:

* undefined,null 
* Boolean:false 
* Number:-0,NaN 
* String:''
Boolean(), called as a function, converts its parameter to a boolean. You can use it to test how a value is interpreted:

```javascript
Boolean(undefined)false> Boolean(0)false> Boolean(3)true> Boolean({}) // empty objecttrue> Boolean([]) // empty arraytrue
```
#### Numbers
All numbers in JavaScript are floating-point:

```javascript
> 1 === 1.0true
```
Special numbers include the following:

* NaN (“not a number”)

```javascript
 An error value:        > Number('xyz')  // 'xyz' can’t be converted to a number		NaN
```
* Infinity
Also mostly an error value:

```javascript
>3/ 0Infinity> Math.pow(2, 1024)  // number too largeInfinity
```
#### Strings
Single characters are accessed via square brackets:

```javascript
> var str = 'abc'; 
> str[1]'b'
```
##### String Methods

```javascript
> 'abc'.slice(1)  // copy a substring'bc'> 'abc'.slice(1, 2)'b'
```
#### Function Declarations Are Hoisted
Function declarations are hoisted—moved in their entirety to the beginning of the cur‐ rent scope. That allows you to refer to functions that are declared later:

```javascript
function foo() {	bar(); // OK, bar is hoisted 
	function bar() {		... 	}}
```
Note that while var declarations are also hoisted (see “Variables Are Hoisted” on page 23), assignments performed by them are not:

```javascript
function foo() {	bar(); // Not OK, bar is still undefined 	var bar = function () {	// ...	}; }
```
#### Too Many or Too Few Arguments
Let’s use the following function to explore how too many or too few parameters are handled in JavaScript

```javascript
function f(x, y) { 
	console.log(x, y);	return toArray(arguments);}
```
Additional parameters will be ignored (except by arguments):

```javascript
> f('a', 'b', 'c')ab[ 'a', 'b', 'c' ]
```
Missing parameters will get the value undefined:

```javascript
> f('a')a undefined[ 'a' ]> f()undefined undefined []
```
#### Optional Parameters
The following is a common pattern for assigning default values to parameters:

```javascript
function pair(x, y) {	x = x || 0; // (1) 	y = y || 0;	return [ x, y ];}
```
#### Enforcing an Arity
If you want to enforce an arity (a specific number of parameters), you can check arguments.length:

```javascript
function pair(x, y) {if (arguments.length !== 2) {	throw new Error('Need exactly 2 arguments'); }	... }
```
#### Converting arguments to an Array
arguments is not an array, it is only array-like (see “Array-Like Objects and Generic Methods” on page 262). It has a property length, and you can access its elements via indices in square brackets. You cannot, however, remove elements or invoke any of the array methods on it. Thus, you sometimes need to convert arguments to an array

```javascript
function toArray(arrayLikeObject) {	return Array.prototype.slice.call(arrayLikeObject);}
````
#### Exception Handling
The most common way to handle exceptions (see Chapter 14) is as follows:

```javascript
function getPerson(id) {
    if (id < 0) {
        throw new Error('ID must not be negative: ' + id);
    }
    return {
        id: id
    }; // normally: retrieved from database }
    function getPersons(ids) {
        var result = [];
        ids.forEach(function(id) {
            try {
                var person = getPerson(id);
                result.push(person);
            } catch (exception) {
                console.log(exception);
            }
        });
        return result;
    }
```
The try clause surrounds critical code, and the catch clause is executed if an exception is thrown inside the try clause. Using the preceding code:
```javascript
 > getPersons([2, -5, 137])    [Error: ID must not be negative: -5]    [ { id: 2 }, { id: 137 } ]```
#### Strict Mode
Strict mode (see `Strict Mode` on page 62) enables more warnings and makes JavaScript a cleaner language (nonstrict mode is sometimes called `sloppy mode`). To switch it on, type the following line first in a JavaScript file or a `<script>` tag:
```javascript
'use strict';```You can also enable strict mode per function:
```javascript
function functionInStrictMode() { 
	'use strict';}```
#### Variables Are Function-Scoped
The scope of a variable is always the complete function (as opposed to the current block). For example:
```javascript
function foo() {
    var x = -512;
    if (x < 0) { // (1) var tmp = -x;
        ...
    }
    console.log(tmp); // 512 
}```
We can see that the variable tmp is not restricted to the block starting in line (1); it exists until the end of the function.
#### Variables Are Hoisted
Each variable declaration is `hoisted`: the declaration is moved to the `beginning` of the function, but assignments that it makes stay put. As an example, consider the variable declaration in line (1) in the following function:
```javascript
function foo() {
    console.log(tmp); // undefined 
    if (false) {
        var tmp = 3; // (1) 
    }
}```
Internally, the preceding function is executed like this:
```javascript
function foo() {
    var tmp; // hoisted declaration 
    console.log(tmp);
    if (false) {
        tmp = 3; // assignment stays put 
    }
}```
#### Closures
Each function stays connected to the variables of the functions that surround it, even after it leaves the scope in which it was created. For example:

```javascript
function createIncrementor(start) {
    return function() { // (1)
        start++;
        return start;
    }
}

> var inc = createIncrementor(5); 
> inc()6> inc()7> inc()8
```
A closure is a function plus the connection to the variables of its surrounding scopes. Thus, what createIncrementor() returns is a closure.

#### The IIFE Pattern: Introducing a New Scope
Sometimes you want to introduce a new variable scope—for example, to prevent a vari‐able from becoming global. In JavaScript, you can’t use a block to do so; you must use a function. But there is a pattern for using a function in a block-like manner. It is called IIFE (immediately invoked function expression, pronounced “iffy”):

```javascript
(function () { // open IIFEvar tmp = ...; // not a global variable}()); // close IIFE
```
An IIFE is a function expression that is called `immediately` after you define it. Inside the function, a new scope exists, preventing tmp from becoming global

##### IIFE use case: inadvertent sharing via closures
Closures keep their connections to outer variables, which is sometimes not what you want:

```javascript
var result = [];
for (var i = 0; i < 5; i++) {
    result.push(function() {
        return i
    }); // (1) 
}
console.log(result[1]()); // 5 (not 1) 
console.log(result[3]()); // 5 (not 3)
```
The value returned in line (1) is always the current value of i, not the value it had when the function was created. After the loop is finished, i has the value 5, which is why all functions in the array return that value. If you want the function in line (1) to receive a snapshot of the current value of i, you can use an IIFE:

```javascript
for (var i = 0; i < 5; i++) {
    (function() {
        var i2 = i; // copy current i
        result.push(function() {
            return i2
        });
    }());
}
```
#### Objects and Constructors
* Single Objects

In JavaScript, you can directly create plain objects, via object literals:

```javascript
'use strict';
var jane = {
    name: 'Jane',
    describe: function() {
        return 'Person named ' + this.name;
    }
};
```
The in operator checks whether a property exists:

```javascript
 > 'newProperty' in janetrue> 'foo' in janefalse
```
If you read a property that does not exist, you get the value undefined. Hence, the previous two checks could also be performed like this:

```javascript
 > jane.newProperty !== undefinedtrue> jane.foo !== undefinedfalse
```
The delete operator removes a property:

```javascript
> delete jane.newPropertytrue
```
#### Arbitrary Property Keys
A property key can be any string. So far, we have seen property keys in object literals and after the dot operator. However, you can use them that way `only if` they are `identifiers` (see “Identifiers and Variable Names” on page 6). If you want to use other strings as keys, you have to quote them in an object literal and use square brackets to get and set the property:

```javascript
> var obj = { 'not an identifier': 123 }; 
> obj['not an identifier']123> obj['not an identifier'] = 456;
```
Square brackets also allow you to compute the key of a property:

```javascript
 > var obj = { hello: 'world' };> var x = 'hello';> obj[x]'world'> obj['hel'+'lo']'world'
```
#### Extracting Methods
If you extract a method, it loses its connection with the object. On its own, the function is not a method anymore, and this has the value undefined (in strict mode).
As an example, let’s go back to the earlier object jane:

```javascript
'use strict';
var jane = {
    name: 'Jane',
    describe: function() {
        return 'Person named ' + this.name;
    }
};
```
We want to extract the method describe from jane, put it into a variable func, and call it. However, that doesn’t work:

```javascript
> var func = jane.describe;> func()TypeError: Cannot read property 'name' of undefined
```
The solution is to use the method bind() that all functions have. It creates a new function whose this always has the given value:

```javascript
> var func2 = jane.describe.bind(jane); 
> func2()'Person named Jane'
```
##### Functions Inside a Method
Every function has its own special variable this. This is inconvenient if you nest a function inside a method, because you can’t access the method’s this from the function. The following is an example where we call forEach with a function to iterate over an array:

```javascript
var jane = {
    name: 'Jane',
    friends: ['Tarzan', 'Cheeta'],
    logHiToFriends: function() {
        'use strict';
        this.friends.forEach(function(friend) {
            // `this` is undefined here
            console.log(this.name + ' says hi to ' + friend);
        });
    }
}
```
Calling logHiToFriends produces an error:

```javascript
> jane.logHiToFriends()TypeError: Cannot read property 'name' of undefined
```
Let’s look at two ways of fixing this.

* First, we could store this in a different variable:

```javascript
logHiToFriends: function() {
    'use strict';
    var that = this;
    this.friends.forEach(function(friend) {
        console.log(that.name + ' says hi to ' + friend);
    });
}
```javascript
* forEach has a second parameter that allows you to provide a value for this:
```javascript
logHiToFriends: function() {
    'use strict';
    this.friends.forEach(function(friend, this) {
        console.log(this.name + ' says hi to ' + friend);
    }, this);
}```
#### Constructors: Factories for Objects
 JavaScript objects also support a feature that is truly object-oriented: inheritance

 In addition to being “real” functions and methods, functions play another role in Java‐ Script: they become constructors—factories for objects—if invoked via the `new` operator.

Constructors are thus a rough analog to classes in other languages. By convention, the names of constructors start with `capital letters`. For example:

```javascript
// Set up instance data
function Point(x, y) {
    this.x = x;
    this.y = y;
}
// Methods
Point.prototype.dist = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};
```
We can see that a constructor has two parts. First, the function Point sets up the instance data. Second, the property Point.prototype contains an object with the methods. The former data is specific to each instance, while the latter data is shared among all instances.````javascript
> var p = new Point(3, 5); 
> p.x3> p.dist() 
5.830951894845301> p instanceof Pointtrue```
#### Arrays
The length property indicates how many elements an array has. You can use it to append elements and to remove elements:

```javascript
> var arr = ['a', 'b']; 
> arr.length
2
> arr[arr.length] = 'c'; 
> arr
[ 'a', 'b', 'c' ]
> arr.length
3
> arr.length = 1; 
> arr
[ 'a' ]
```
The `in` operator works for arrays, too:

```javascript
> var arr = [ 'a', 'b', 'c' ];> 1 in arr // is there an element at index 1? 
true> 5 in arr // is there an element at index 5? false
```
Note that arrays are objects and can thus have object properties:

```javascript
> var arr = []; 
> arr.foo = 123; 
> arr.foo123
```
##### Array Methods

```javascript
> var arr = [ 'a', 'b', 'c' ];
arr.push('x')  // append an element
> arr.pop()  // remove last element'x'> arr[ 'a', 'b', 'c' ]
 > arr.shift()  // remove first element'a'> arr[ 'b', 'c' ]> arr.unshift('x')  // prepend an element3> arr[ 'x', 'b', 'c' ]
```
##### Iterating over Arrays

```javascript
[ 'a', 'b', 'c' ].forEach(function (elem, index) { // (1)            console.log(index + '. ' + elem);        });
```
map creates a new array by applying a function to each element of an existing array:

```javascript
> [1,2,3].map(function (x) { return x*x })[ 1, 4, 9 ]
```
#### Regular Expressions

```javascript
 > /^a+b+$/.test('aaab')true> /^a+b+$/.test('aaa')false
```
##### Method exec(): Match and Capture Groups

```javascript
> /a(b+)a/.exec('_abbba_aba_')
[ 'abbba', 'bbb' ]
```
The returned array contains the complete match at index 0, the capture of the first group at index 1, and so on.

##### Method replace(): Search and Replace

```javascript
> '<a> <bbb>'.replace(/<(.*?)>/g, '[$1]')'[a] [bbb]'
```
#### Evaluating an object literal via eval()
eval parses its argument in statement context. You have to put parentheses around an object literal if you want eval to return an object:

```javascript
 > eval('{ foo: 123 }')123> eval('({ foo: 123 })'){ foo: 123 }
```
#### Immediately invoking a function expression
The following code is an `immediately invoked function expression` (IIFE), a function whose body is executed right away
If you omit the parentheses, you get a syntax error, because JavaScript sees a function declaration, which can’t be anonymous:

```javascript
> function () { return 'abc' }()SyntaxError: function statement requires a name
```
If you add a name, you also get a syntax error, because function declarations can’t be immediately invoked:

```javascript
> function foo() { return 'abc' }()SyntaxError: Unexpected token )
```
#### Invoking Methods on Number Literals
With method invocations, it is important to distinguish between the floating-point dot and the method invocation dot. Thus, you cannot write 1.toString(); you must use one of the following alternatives:

```javascript
1..toString()1 .toString() // space before dot 
(1).toString()1.0.toString()
```
#### Strict Mode
* Variables Must Be Declared in Strict Mode
* Functions in Strict Mode

	Functions must be declared at the top level of a scope

	In strict mode, all functions must be declared at the top level of a scope (global scope or directly inside a function
	
```javascript
	function strictFunc() {
    'use strict'; {
        // SyntaxError:
        function nested() {}
    }
}
```
If you want to work around this limitation, you can create a function inside a block via a variable declaration and a function expression:
```javascript
function strictFunc() {
    'use strict'; 
    {
        // OK:
        var nested = function() {};
    }
}```
* The arguments objects has fewer properties

The arguments object is simpler in strict mode: the properties arguments.callee and arguments.caller have been eliminated, you can’t assign to the variable arguments, and arguments does not track changes to parameters (if a parameter changes, the cor‐ responding array element does not change with it).

* this is undefined in nonmethod functions

In sloppy mode, the value of this in nonmethod functions is the global object (window in browsers;

```javascript
function sloppyFunc() {	console.log(this === window); // true}
```
In strict mode, it is undefined:

```javascript
function strictFunc() { 
	'use strict';	console.log(this === undefined); // true }
```
This is useful for constructors. For example, the following constructor, Point, is in strict mode:

```javascript
function Point(x, y) {
    'use strict';
    this.x = x;
    this.y = y;
}
```
Due to strict mode, you get a warning when you accidentally forget new and call it as a function:

```javascript
 > var pt = Point(3, 1);TypeError: Cannot set property 'x' of undefined
```
#####  Setting and Deleting Immutable Properties Fails with an Exception in Strict Mode
Illegal manipulations of properties throw exceptions in strict mode. For example, at‐ tempting to set the value of a read-only property throws an exception, as does attempting to delete a nonconfigurable property
```javascriptvar str = 'abc';

function sloppyFunc() {
    str.length = 7; // no effect, silent failure
    console.log(str.length); // 3 
}

function strictFunc() {
    'use strict';
    str.length = 7; // TypeError: Cannot assign to // read-only property 'length'
}````
##### Unqualified Identifiers Can’t Be Deleted in Strict Mode
In sloppy mode, you can delete a global variable foo like this:
```javascript
delete foo```
In strict mode, you get a syntax error whenever you try to delete unqualified identifiers. You can still delete global variables like this:

```javascript
delete window.foo; // browsersdelete global.foo; // Node.jsdelete this.foo; // everywhere (in global scope)
```
##### eval() Is Cleaner in Strict Mode
In strict mode, the eval() function becomes less quirky: variables declared in the eval‐ uated string are not added to the scope surrounding eval() anymore.
##### Features That Are Forbidden in Strict Mode
Two more JavaScript features are forbidden in strict mode:

*  The `with` statementisnotallowedanymore(see“ThewithStatement”onpage153). You get a syntax error at compile time (when loading the code).
*  Nomoreoctalnumbers:insloppymode,anintegerwithaleadingzeroisinterpreted as octal (base 8). For example:

```javascript
> 010 === 8true
```
In strict mode, you get a syntax error if you use this kind of literal:

```javascript
> function f() { 'use strict'; return 010 }SyntaxError: Octal literals are not allowed in strict mode.
```
####　JavaScript’s Type System
##### Coercion
In JavaScript, the main way of dealing with a value whose type doesn’t fit is to coerce it to the correct type. Coercion means implicit type conversion. Most operands coerce:

```javascript
> '3' * '4'12
```
##### Primitive Values Versus Objects
In contrast, all primitive values encoding the same value are considered the same:

```javascript
> var prim1 = 123; 
> var prim2 = 123; 
> prim1 === prim2 true
```
##### Primitives have the following characteristics:
* Compared by value

```javascript
> 3 === 3true> 'abc' === 'abc'true
```
* Always immutable

Properties can’t be changed, added, or removed:

```javascript
> var str = 'abc';> str.length = 1; // try to change property `length`> str.length // ⇒ no effect 3> str.foo = 3; // try to create property `foo` 
> str.foo // ⇒ no effect, unknown property undefined
```
* A fixed set of types

You can’t define your own primitive types.

#### Objects
* Mutable by default

```javascript
> var obj = {};> obj.foo = 123; // add property `foo` > obj.foo123
```
#### undefined and null

* `undefined` means “`novalue`”(neitherprimitivenorobject).Uninitialized variables, missing parameters, and missing properties have that nonvalue. And functions `implicitly` return it if nothing has been explicitly returned.
* `null` means “`no object`.” It is used as a nonvalue where an object is expected (as a parameter, as a member in a chain of objects, etc.).

undefined and null are the only values for which any kind of property access results in an exception:

```javascript
 > function returnFoo(x) { return x.foo }
 > returnFoo(true)undefined> returnFoo(0)undefined

> returnFoo(null)TypeError: Cannot read property 'foo' of null> returnFoo(undefined)TypeError: Cannot read property 'foo' of undefined
```
`undefined` is also sometimes used as more of a metavalue that indicates `nonexistence`. In contrast, `null` indicates `emptiness`.

 For example, a JSON node visitor (see “Trans‐ forming Data via Node Visitors” on page 341) returns:
 
* undefined to remove an object property or array element 
* null to set the property or element to null

##### Occurrences of undefined and null

###### Occurrences of undefined
* Uninitialized variables are undefined:

```javascript
> var foo; 
> foo undefined
```
* Missing parameters are undefined:

```javascript
> function f(x) { return x } 
> f()undefined
```
* If you read a nonexistent property, you get undefined:

```javascript
> var obj = {}; // empty object 
> obj.fooundefined
```
And functions implicitly return undefined if nothing has been explicitly returned:

```javascript
> function f() {} 
> f()undefined

> function g() { return; } 
> g()undefined
```
###### Occurrences of null

* null is the last element in the prototype chain(a chain of objects;see“Layer2:The Prototype Relationship Between Objects” on page 211):

```javascript
Object.getPrototypeOf(Object.prototype)null
```
* null is returned byRegExp.prototype.exec()if there was no match for the regular expression in the string:

```javascript
> /x/.exec('aaa')null
```
####  Checking for undefined or null

#### Checking for null
You check for null via strict equality:

```javascript
if (x === null) ...
```
#### Checking for undefined
Strict equality (===) is the canonical way of checking for undefined:

```javascript
if (x === undefined) ...
```
#### Checking for either undefined or null
Most functions allow you to indicate a missing value via either undefined or null. One way of checking for both of them is via an explicit comparison:

```javascript
// Does x have a value?if (x !== undefined && x !== null) { 	...}    // Is x a non-value?if (x === undefined || x === null) { 
	...}
```
Another way is to exploit the fact that both undefined and null are considered false

```javascript
// Does x have a value (is it truthy)?if (x) { ...}// Is x falsy?if (!x) { ...}
```
false, 0, NaN, and '' are `also` considered false.

#### Changing undefined
undefined is a property of the global object (and thus a global variable; see “The Global Object” on page 187). Under ECMAScript 3, you had to take precautions when reading undefined, because it was easy to accidentally change its value. Under ECMAScript 5, that is not necessary, because undefined is read-only.

To protect against a changed undefined, two techniques were popular (they are still relevant for older JavaScript engines):
* Technique 1

Shadow the global undefined (which may have the wrong value):

```javascript
(function (undefined) {	if (x === undefined) ... // safe now}()); // don’t hand in a parameter
````
In the preceding code, undefined is guaranteed to have the right value, because itis a parameter whose value has not been provided by the function call.
* Technique 2
Compare with void 0, which is always (the correct) undefined
```javascript
if (x === void 0) // always safe```
#### Wrapper Objects for Primitives
The three primitive types boolean, number, and string have corresponding constructors: Boolean, Number, String. Their instances (so-called wrapper objects) contain (wrap) primitive values. The constructors can be used in two ways:
* Asconstructors,theycreateobjectsthatarelargelyincompatiblewiththeprimitive values that they wrap:
```javascript
> typeof new String('abc')'object'> new String('abc') === 'abc'false```
* As functions,they convert values to the corresponding primitive types(see“Functions for Converting to Boolean, Number, String, and Object” on page 78). This is the recommended method of conversion:

```javascript
> String(123)'123'
```
It’s considered a best practice to avoid wrapper objects. You normal‐ ly don’t need them, as there is nothing that objects can do that primitives can’t (with the exception of being mutated). 

#### Wrapper Objects Are Different from Primitives
Primitive values such as 'abc' are fundamentally different from wrapper instances such as new String('abc'):

```javascript
 > typeof 'abc'  // a primitive value'string'> typeof new String('abc')  // an object'object'> 'abc' instanceof String  // never true for primitivesfalse> 'abc' === new String('abc')false
```
Wrapper instances are objects, and there is no way of comparing objects in JavaScript, not even via lenient equals == (see “Equality Operators: === Versus ==” on page 83):

```javascript
> var a = new String('abc'); 
> var b = new String('abc'); 
> a == bfalse
```
#### Wrapping and Unwrapping Primitives
There is one use case for wrapper objects: you want to add properties to a primitive value. Then you wrap the primitive and add properties to the wrapper object. You need to unwrap the value before you can work with it.

Wrap a primitive by invoking a wrapper constructor:

```javascript
new Boolean(true) 
new Number(123) 
new String('abc')
```
Unwrap a primitive by invoking the method `valueOf()`. 

```javascript
> new Boolean(true).valueOf()true> new Number(123).valueOf()123> new String('abc').valueOf()'abc'
```
Converting wrapper objects to primitives properly extracts numbers and strings, but not booleans:

```javascript
> Boolean(new Boolean(false))  // does not unwraptrue> Number(new Number(123))  // unwraps123> String(new String('abc'))  // unwraps'abc'
```
##### Primitives Borrow Their Methods from Wrappers 

Primitives don’t have their own methods and borrow them from wrappers:

```javascript
> 'abc'.charAt === String.prototype.charAt 
> true
```
Sloppy mode and strict mode handle this borrowing differently. In sloppy mode, prim‐ itives are `converted to wrappers` on the fly:

```javascript
String.prototype.sloppyMethod = function () { 
	console.log(typeof this); // object 
	console.log(this instanceof String); // true};''.sloppyMethod(); // call the above method
```
In strict mode, methods from the wrapper prototype are used transparently:

```javascript
String.prototype.strictMethod = function () { 
	'use strict';	console.log(typeof this); // string	console.log(this instanceof String); // false };	''.strictMethod(); // call the above method
```
#### Type Coercion

```javascript
> '3' * '4'12
```
As another example, if one of the operands is a string, the plus operator (+) converts the other one to a string:```javascript
> 3 + ' times''3 times'```
##### Type Coercion Can Hide Bugs

```javascript
var formData = { width: '100' };// You think formData.width is a number // and get unexpected resultsvar w = formData.width;var outer = w + 20;// You expect outer to be 120, but it’s not console.log(outer === 120); // false console.log(outer === '10020'); // true
```
In cases such as the preceding one, you should convert to the appropriate type early on:

```javascript
var w = Number(formData.width);
```
##### Functions for Converting to Boolean, Number, String, and Object
The following functions are the preferred way of converting a value to a boolean, num‐ ber, string, or object:

* Boolean()
Converts a value to a boolean. The following values are converted to false; they are the so-called “falsy” values:

undefined,null,false ,0,NaN, ''

*　Number() 

```javascript
• undefined becomes NaN.• null becomes 0.• false becomes 0, true becomes 1.• Strings are parsed.
• Objects are first converted to primitives (discussed shortly), which are then converted to numbers.
```
* String()
Converts a value to a string. It has the obvious results for all primitives. For example:

```javascript
> String(null)'null'> String(123.45)'123.45'> String(false)'false'
```
Objects are first converted to primitives (discussed shortly), which are then con‐ verted to strings.

*　Object()
Converts objects to themselves, undefined and null to empty objects, and primi‐ tives to wrapped primitives. For example:

```javascript
> var obj = { foo: 123 }; 
> Object(obj) === obj true> Object(undefined){}> Object('abc') instanceof Stringtrue
```
#### Algorithm: ToPrimitive()—Converting a Value to a Primitive
To convert a value to either a number or a string, it is first converted to an arbitrary primitive value, which is then converted to the final type

The ECMAScript specification has an internal function, ToPrimitive() (which is not accessible from JavaScript), that performs this conversion. Understanding ToPrimi tive() enables you to configure how objects are converted to numbers and strings. It has the following signature:

```javascript
    ToPrimitive(input, PreferredType?)
```
The optional parameter PreferredType indicates the final type of the conversion: it is either Number or String, depending on whether the result of ToPrimitive() will be converted to a number or a string.

If PreferredType is Number, then you perform the following steps:

1. If input is primitive, return it (there is nothing more to do).
2. Otherwise, input is an object. Call input.valueOf(). If the result is primitive, return it.
3. Otherwise, call input.toString(). If the result is primitive, return it.
4. Otherwise, throw a TypeError (indicating the failure to convert input to aprimitive).
If PreferredType is String, steps 2 and 3 are swapped. The PreferredType can also be omitted; it is then considered to be String for dates and Number for all other values. This is how the operators + and == call ToPrimitive().
##### Examples: ToPrimitive() in action
The default implementation of valueOf() returns this, while the default implementa‐ tion of toString() returns type information:
```javascript
> var empty = {};> empty.valueOf() === empty 
true> empty.toString()'[object Object]'```
Therefore, Number() skips valueOf() and converts the result of toString() to a num‐ ber; that is, it converts '[object Object]' to NaN:
```javascript
> Number({})NaN```
The following object customizes valueOf(), which influences Number(), but doesn’t change anything for String():```javascript
> var n = { valueOf: function () { return 123 } }; > Number(n)123> String(n)'[object Object]'```
The following object customizes toString(). Because the result can be converted to a number, Number() can return a number:
```javascript
> var s = { toString: function () { return '7'; } }; 
> String(s)'7'> Number(s)7```
### Operators#### Operators and Objects
One example where that is unfortunate is the plus operator, which many languages use for array concatenation. That’s not so with JavaScript, however, where this operator converts arrays to strings and appends them:

```javascript
> [1, 2] + [3]'1,23'> String([1, 2])'1,2'> String([3])'3'
```
#### Equality Operators: === Versus ==
JavaScript has two ways of determining whether two values are equal:

* Strict equality (===) and strict inequality (!==) consider only values that have the same type to be equal.
* Normal (or “lenient”) equality (==) and inequality (!=) try to convert values of different types before comparing them as with strict (in)equality.

#### Strict Equality (===, !==)
Values with different types are never strictly equal. If both values have the same type, then the following assertions hold:* undefined === undefined* null === null* Two numbers:
```javascript
x === x // unless x is NaN+0 === -0NaN !== NaN // read explanation that follows```
* Two booleans, two strings: obvious results
* Two objects (including arrays and functions): x === y if and only if x and y are the `same` object; that is, if you want to compare different objects, you have to implement your own comparison algorithm:
```javascript
> var b = {}, c = {}; 
> b === cfalse> b === btrue```
* Everything else: not strictly equal.
#### Pitfall: NaN
The special number value NaN (see “NaN” on page 106) is not equal to itself:
```javascript
> NaN === NaNfalse```
Thus, you need to use other means to check for it, which are described in “Pitfall: checking whether a value is NaN” on page 107.
#### Strict inequality (!==)
#### Normal (Lenient) Equality (==, !=)
The algorithm for comparing via normal equality works as follows. If both operands have the same type (one of the six specification types—Undefined, Null, Boolean, Num‐ ber, String, and Object), then compare them via strict equality.

Otherwise, if the operands are:

1. undefined and null, then they are considered leniently equal:

```javascript
	> undefined == null	true
```

2. A string and a number, then convert the string to a number and compare both operands via strict equality.
3.  A boolean and a nonboolean, then convert the boolean to a number and compare leniently (again).
4.  An object and a number or a string, then try to convert the object to a primitive (via the algorithm described in “Algorithm: ToPrimitive()—Converting a Value to a Primitive” on page 79) and compare leniently (again).
#### Pitfall: lenient equality is different from conversion to boolean
```javascript
> 2 == truefalse> 2 == falsefalse> 1 == truetrue> 0 == falsetrue// 2 === 1// 2 === 0// 1 === 1// 0 === 0```
Similarly, while the empty string is equal to false, not all nonempty strings are equal to true:

```javascript
> '' == falsetrue> '1' == truetrue> '2' == truefalse// 0 === 0// 1 === 1// 2 === 1> 'abc' == true  // NaN === 1false
```
#### Pitfall: lenient equality and strings
Some of the leniency can be useful, depending on what you want:

```javascript
 > 'abc' == new String('abc')  // 'abc' == 'abc'true> '123' == 123  // 123 === 123true
```
Other cases are problematic, due to how JavaScript converts strings to numbers (see “Converting to Number” on page 104):
```
> '\n\t123\r ' == 123  // usually not OKtrue> '' == 0  // 0 === 0true```
#### Pitfall: lenient equality and objects
If you compare an object to a nonobject, it is converted to a primitive, which leads to strange results:
```javascript
 > {} == '[object Object]'true> ['123'] == 123true> [] == 0true```
However, two objects are only equal if they are they same object. That means that you can’t really compare two wrapper objects:

```javascript
> new Boolean(true) === new Boolean(true)false> new Number(123) === new Number(123)false> new String('abc') == new String('abc')false
```
#### There Are No Valid Use Cases for ==

* Use case: checking for undefined or null
The following comparison ensures that x is neither undefined nor null:

```javascript
if (x != null) ...
```
replace the above with 

```javascript
if (x) ...
```
If you want to be more precise, you should perform an explicit check for both values:

```
if (x !== undefined && x !== null) ...
```
* Use case: working with numbers in strings
If you are not sure whether a value x is a number or a number-as-a-string, you can use checks such as the following:
```
if (x == 123) ...```
The preceding checks whether x is either 123 or '123'. Again, this is very compact, andagain, it is better to be explicit:
```javascript
if (Number(x) === 123) ...```
#### Use case: comparing wrapper instances with primitives
Lenient equals lets you compare primitives with wrapped primitives:
```javascript
> 'abc' == new String('abc')true```
There are three reasons against this approach. First, lenient equality does not work between wrapped primitives:

```
> new String('abc') == new String('abc')false
```
Second, you should avoid wrappers anyway. Third, if you do use them, it is better to be explicit:

```javascript
if (wrapped.valueOf() === 'abc') ...
```
#### What is void used for?
Under ECMAScript 5, void is rarely useful. Its main use cases are:

* void 0 as a synonym for undefined

The latter can be changed, while the former will always have the correct value. However, undefined is reasonably safe from being changed under ECMAScript 5, which makes this use case less important

* Discarding the result of an expression
In some situations, it is important to return undefined as opposed to the result of an expression. Then void can be used to discard that result. One such situation involves javascript: URLs, which should be avoided for links, but are useful for bookmarklets. When you visit one of those URLs, many browsers replace the cur‐ rent document with the result of evaluating the URL’s “content,” but only if the result isn’t undefined. Hence, if you want to open a new window without changing the currently displayed content, you can do the following:

```javascript
javascript:void window.open("http://example.com/")
```
* Prefixing an IIFE
An IIFE must be parsed as an expression. One of several ways to ensure that is by prefixing it with void (see “IIFE Variation: Prefix Operators” on page 184).2

#### Categorizing Values via typeof and instanceof
If you want to categorize a value, you unfortunately have to distinguish between prim‐ itives and objects (refer back to Chapter 8) in JavaScript:

* The typeof operator distinguishes primitives from objects and determines the types of primitives.
* The instanceof operator determines whether an object is an instance of a given constructor. 

##### typeof: Categorizing Primitives

```javascript
 > typeof undefined'undefined'> typeof 'abc''string'> typeof {}'object'> typeof []'object'
```
##### Pitfall: typeof null
Unfortunately,typeof nullis'object'.Thisisconsideredabug(nullisnotamember of the internal type Object), but it can’t be fixed, because doing so would break existing code. You thus have to be wary of null

```javascript
function isObject(value) { 
	return (value !== null	&& (typeof value === 'object'	|| typeof value === 'function'));}

> isObject(123)false> isObject(null)false> isObject({})true
```
#### Checking whether a variable exists

```javascript
typeof x === 'undefined'
```

1. It determines whether x is undefined.2. It determines whether the variable x exists.
#### Manually Converting to Boolean
Manually Converting to Boolean
* Boolean(value) (Invoked as a function, not as a constructor)value ? true : false* !!value * A single “not” converts to negated boolean; use twice for the nonnegated conversion.
I prefer Boolean(), because it is more descriptive. 
##### Pattern: providing a default value 
Sometimes there are situations where a value (a parameter, the result of a function, etc.) can be either a nonvalue (undefined, null) or an actual value. If you want to provide a default value for the former case, you can use the Or operator:

```javascript    theValue || defaultValue
```
The preceding expression evaluates to theValue if it is truthy and to defaultValue otherwise. The usual caveat applies: defaultValue will also be returned if theValue has a falsy value other than undefined and null. Let’s look at three examples of using that pattern.

* Example 1: a default for a parameter
The parameter text of the function saveText() is optional and should be the empty string if it has been omitted:```javascript
function saveText(text) { 
	text = text || ''; ...}```
This is the most common use of || as a default operator. Consult “Optional Parame‐ ters” on page 173 for more on optional parameters.
* Example 2: a default for a property
The object options may or may not have the property title. If it is missing, the value 'Untitled' should be used when setting the title:

```javascript    setTitle(options.title || 'Untitled');```
* Example 3: a default for the result of a function

The function countOccurrences counts how often regex matches inside str:

```javascript
function countOccurrences(regex, str) {	// Omitted: check that /g is set for `regex` 	return (str.match(regex) || []).length;}
```
#### Numbers
JavaScript has a single type for all numbers: it treats all of them as floating-point num‐ bers. However, the dot is not displayed if there are no digits after the decimal point:

```javascript> 5.0005
> Number('\t\v\r12.34\n ')  // ignores leading and trailing whitespace12.34```
##### parseFloat()
*  Applying parseFloat() to a nonstring is less efficient, because it coerces its argu‐ ment to a string before parsing it. As a consequence, many values that Number() converts to actual numbers are converted to NaN by parseFloat():

```javascript
> parseFloat(true)  // same as parseFloat('true')NaN> Number(true)1> parseFloat(null)  // same as parseFloat('null')NaN> Number(null)0
```
* parseFloat() parses the empty string as NaN:

```javascript
> parseFloat('')NaN
```
*  parseFloat()ignoresleadingwhitespaceandstopsbeforeillegalcharacters(which include whitespace):

```javascript
 > parseFloat('\t\v\r12.34\n ')12.34
```
#### Special Number Values
JavaScript has several special number values:

* Two error values, NaN and Infinity.
* Two values for zero, +0 and -0. JavaScript has two zeros, a positive zero and a negative zero, because the sign and the magnitude of a number are stored separately. In most of this book, I pretend that there is only a single zero, and you almost never see in JavaScript that there are two of them.

#### Pitfall: checking whether a value is NaN

```javascript
> isNaN(NaN)true> isNaN(33)false```
However, isNaN does not work properly with nonnumbers, because it first converts those to numbers. That conversion can produce NaN and then the function incorrectly returns true:

```javascript
> isNaN('xyz')true
```
Thus, it is best to combine isNaN with a type check:

```javascript
function myIsNaN(value) {	return typeof value === 'number' && isNaN(value);}
```
Alternatively, you can check whether the value is unequal to itself (as NaN is the only value with this trait). But that is less self-explanatory:

```javascript
function myIsNaN(value) { 
	return value !== value;}
```
#### Infinity
Infinity is an error value indicating one of two problems: a number can’t be represented because its magnitude is too large, or a division by zero has happened.

The exponent must be between (and excluding) −1023 and 1024. If the exponent is too small, the number becomes 0. If the exponent is too large, it becomes Infinity. 21023 can still be represented, but pow(2, 1024) can’t:

```javascript
> Math.pow(2, 1023)8.98846567431158e+307> Math.pow(2, 1024)Infinity
```
Error: division by zero

```javascript
>3/ 0Infinity> 3 / -0-Infinity```
##### Computing with Infinity
You get the error result NaN if you try to “neutralize” one Infinity with another one:

```javascript
> Infinity - InfinityNaN> Infinity / InfinityNaN
```
##### Checking for Infinity

```javascript
> var x = Infinity; 
> x === Infinity true

> isFinite(5)true> isFinite(Infinity)> isFinite(NaN)false
```
compare

```javascript
var EPSILON = Math.pow(2, -53); 
function epsEqu(x, y) {	return Math.abs(x - y) < EPSILON; }
```
#### Ranges of Integers
* Safeintegers, thelargestpracticallyusablerangeof integers that JavaScript supports:

```javascript
— 53 bits plus a sign, range (−253, 253)
```
* Array indices

```javascript
— 32 bits, unsigned— Maximum length: 232−1— Range of indices: [0, 232−1) (excluding the maximum length!)
```
* Bitwise operands

— Unsigned right shift operator (>>>): 32 bits, unsigned, range [0, 232) 
— All other bitwise operators: 32 bits, including a sign, range [−231, 231)
#### Definitions in ECMAScript 6
ECMAScript 6 will provide the following constants:

```javascript
Number.MAX_SAFE_INTEGER = Math.pow(2, 53)-1;Number.MIN_SAFE_INTEGER = -Number.MAX_SAFE_INTEGER;
```
It will also provide a function for determining whether an integer is safe:

```javascript
Number.isSafeInteger = function (n) { 
		return (typeof n === 'number' &&            Math.round(n) === n &&            Number.MIN_SAFE_INTEGER <= n &&            n <= Number.MAX_SAFE_INTEGER);}
```
#### Converting to Integer
In JavaScript, all numbers are floating point. Integers are floating-point numbers without a fraction. Converting a number n to an integer means finding the integer that is “`closest`” to n

use TheMathfunctionsMath.floor(),Math.ceil(),andMath.round()
#### 32-bit Integers via Bitwise Operators
Binary bitwise operators (see “Binary Bitwise Operators” on page 126) convert (at least) one of their operands to a 32-bit integer that is then manipulated to produce a result that is also a 32-bit integer. Therefore, if you choose the other operand appropriately, you get a fast way to convert an arbitrary number to a 32-bit integer (that is either signed or unsigned).

##### Bitwise Or (|)
If the mask, the second operand, is 0, you don’t change any bits and the result is the first operand, coerced to a signed 32-bit integer. 

```javascript
 // Convert x to a signed 32-bit integerfunction ToInt32(x) { 	return x | 0;}

> ToInt32(1.001)1> ToInt32(1.999)1> ToInt32(1)1
 > ToInt32(-1)-1> ToInt32(Math.pow(2, 32)+1)1> ToInt32(Math.pow(2, 32)-1)-1
```
##### Shift operators
The same trick that worked for bitwise Or also works for shift operators: if you shift by zero bits, the result of a shift operation is the first operand, coerced to a 32-bit integer.

```javascript
 // Convert x to a signed 32-bit integerfunction ToInt32(x) { return x << 0;}// Convert x to a signed 32-bit integerfunction ToInt32(x) { return x >> 0;}// Convert x to an unsigned 32-bit integerfunction ToUint32(x) { return x >>> 0;}
```
Here is ToUint32() in action:

```javascript
 > ToUint32(-1)4294967295> ToUint32(Math.pow(2, 32)-1)4294967295> ToUint32(Math.pow(2, 32))0
```
##### The radix
parseInt(str, radix?)

```javascript
 > parseInt('0xA')10
```
If radix is already 16, then the hexadecimal prefix is optional:

```javascript
> parseInt('0xA', 16)10> parseInt('A', 16)10
> parseInt('12.34', 10)12> parseInt(12.34, 10)12
> parseInt('110', 2)6```
Don’t use parseInt() to convert a number to an integer. Here is an example where the conversion is incorrect:

```javascript
> parseInt(1000000000000000000000.5, 10)1
```
`Explanation`
The argument is first converted to a string:

```javascript
> String(1000000000000000000000.5)
'1e+21'
```
parseInt doesn’t consider “e” to be an integer digit and thus stops parsing after the 1.
parseInt() shouldn’t be used to convert numbers to integers: coercion to string is an unnecessary detour and even then, the result is not always correct.

* num.toString(2)(see“Number.prototype.toString(radix?)”onpage129)converts the number num to a string in binary notation. For example:

```javascript
> 6..toString(2)
'110'
```
##### Bitwise Shift Operators
JavaScript has three bitwise shift operators:

* number << digitCount (left shift):

```javascript
> (parseInt('1', 2) << 1).toString(2)'10'
```
* number >> digitCount (signed right shift):

```
> (parseInt('11111111111111111111111111111110', 2) >> 1).toString(2)'-1'
```
* number >>> digitCount

```javascript
> (parseInt('11100', 2) >>> 1).toString(2)'1110'
```
#### Number Prototype Methods
* Number.prototype.toFixed(fractionDigits?)

Number.prototype.toFixed(fractionDigits?) returns an exponent-free representa‐ tion of the number, rounded to fractionDigits digits. If the parameter is omitted, the value 0 is used:

```javascript
> 0.0000003.toFixed(10)'0.0000003000'> 0.0000003.toString()'3e-7'
```
If the number is greater than or equal to 1021, then this method works the same as toString(). You get a number in exponential notation:

```javascript
> 1234567890123456789012..toFixed()'1.2345678901234568e+21'> 1234567890123456789012..toString()'1.2345678901234568e+21'
```
* Number.prototype.toPrecision(precision?)

Number.prototype.toPrecision(precision?) prunes the mantissa to precision dig‐ its before using a conversion algorithm similar to toString(). If no precision is given, toString() is used directly:

```javascript
 > 1234..toPrecision(3)'1.23e+3'> 1234..toPrecision(4)'1234'> 1234..toPrecision(5)'1234.0'> 1.234.toPrecision(3)'1.23'
```
* Number.prototype.toString(radix?)

```javascript
 > 15..toString(2)'1111'> 65535..toString(16)'ffff'
```
* Number.prototype.toExponential(fractionDigits?)

```javascript
 > 1234567890123456789012..toString()'1.2345678901234568e+21'> 1234567890123456789012..toExponential(20)'1.23456789012345677414e+21'
> 1234..toString()'1234'> 1234..toExponential(5)'1.23400e+3'> 1234..toExponential()'1.234e+3'
 > 0.003.toString()'0.003'> 0.003.toExponential(4)'3.0000e-3'> 0.003.toExponential()'3e-3'
```

### String

#### Escaping in String Literals

* Line continuations

```javascript
var str = 'written \over \multiple \lines';console.log(str === 'written over multiple lines'); // true
```
* Character escape sequences
	1. Control characters: \b is a backspace, \f is a form feed, \n is a line feed (new‐line), \r is a carriage return, \t is a horizontal tab, and \v is a vertical tab.
	2. Escapedcharactersthatrepresentthemselves:\'isasinglequote,\"isadouble quote,and\\isabackslash.Allcharactersexceptb f n r t v x uanddecimal digits represent themselves, too. Here are two examples:

	```javascript
		> '\"'		'"'		> '\q'		'q'
	```
* NUL character (This character is represented by \0.)
* Hexadecimal escape sequences
	\xHH (HH are two hexadecimal digits) specifies a character via an ASCII code. For example:

	```javascript
		> '\x4D'		'M'
	```
	
#### Manually Converting to String

```javascript
String(value) (Invoked as a function, not as a constructor) 
''+valuevalue.toString() (Does not work for undefined and null!)
> String(false)'false'> String(7.35)'7.35'> String({ first: 'John', last: 'Doe' })'[object Object]'> String([ 'a', 'b', 'c' ])'a,b,c'
```
Note that for displaying data, JSON.stringify() (“JSON.stringify(value, replacer?, space?)” on page 337) often works better than the canonical conversion to string:

```
> console.log(JSON.stringify({ first: 'John', last: 'Doe' })){"first":"John","last":"Doe"}> console.log(JSON.stringify([ 'a', 'b', 'c' ]))["a","b","c"]
```
#### Pitfall: conversion is not invertible
Given how often JavaScript automatically converts, it is a shame that the conversion isn’t always invertible, especially with regard to booleans:

```javascript
> String(false)'false'> Boolean('false')true
```
#### Concatenation: Joining an Array of String Fragments

```javascript
> var arr = [];> arr.push('Say hello ');> arr.push(7);> arr.push(' times fast');
> arr.join('')'Say hello 7 times fast'
```
#### String Constructor Method

```javascript
> String.fromCharCode(97, 98, 99)'abc'> String.fromCharCode.apply(null, [97, 98, 99])'abc'
```
#### String Prototype Methods

```javascript
> 'abc'.split('').map(function (x) { return x.charCodeAt(0) })[ 97, 98, 99 ]
> 'abc'.slice(2)'c'
> 'abc'.slice(1, 2)'b'

> 'abc'.slice(-2)'bc'

> 'a,  b,c, d'.split(',')  // string[ 'a', '  b', 'c', ' d' ]> 'a,  b,c, d'.split(/,/)  // simple regular expression[ 'a', '  b', 'c', ' d' ]> 'a,  b,c, d'.split(/, */)   // more complex regular expression[ 'a', 'b', 'c', 'd' ]> 'a,  b,c, d'.split(/, */, 2)  // setting a limit[ 'a', 'b' ]        > 'test'.split()  // no separator provided[ 'test' ]
// If there is a group, then the matches are also returned as array elements:
 > 'a,  b  ,  '.split(/(,)/)[ 'a', ',', '  b  ', ',', '  ' ]> 'a,  b  ,  '.split(/ *(,) */)[ 'a', ',', 'b', ',', '' ]
 > 'abc'.split('')[ 'a', 'b', 'c' ]
```
##### Transform
1. String.prototype.trim() Removes all whitespace from the beginning and the end of the string:

```javascript
> '\r\nabc \t'.trim()'abc'
```

2. String.prototype.concat(str1?, str2?, ...)

```javascript
> 'hello'.concat(' ', 'world', '!')'hello world!'
```
#### Pitfall: Losing this When Extracting a Method

```javascript
var counter = {
    count: 0,
    inc: function() {
        this.count++;
    }
}

> var func = counter.inc;> func()> counter.count // didn’t work 0
```
Here’s the explanation: we have called the value of counter.inc as a function. Hence, this is the global object and we have performed window.count++. window.count does not exist and is undefined. Applying the ++ operator to it sets it to NaN:```
> count  // global variableNaN```
`How to get a warning`
If method inc() is in strict mode, you get a warning:

```
> counter.inc = function () { 'use strict'; this.count++ }; 
> var func2 = counter.inc;> func2()TypeError: Cannot read property 'count' of undefined
```
##### How to properly extract a method
Thanks to bind(), we can make sure that inc doesn’t lose the connection with counter:

```
> var func3 = counter.inc.bind(counter); 
> func3()> counter.count // it worked!1
```
`Warning`

Each call to bind() creates a new function. That has consequences when you’re registering and unregistering callbacks (e.g., for event handling). You need to store the value you registered somewhere and use it for unregistering, too.
#### Pitfall: Functions Inside Methods Shadow this

```javascript
var obj = {
    name: 'Jane',
    friends: ['Tarzan', 'Cheeta'],
    loop: function() {
        'use strict';
        this.friends.forEach(
            function(friend) { // (1)
                console.log(this.name + ' knows ' + friend); // (2) }
            );
        }
    };
}
```
Obviously, this fails, because the function at (1) has its own this, which is undefined here:

```javascript
> obj.loop();    TypeError: Cannot read property 'name' of undefined
```
There are three ways to work around this problem.

* Workaround 1: that = this

```javascript
loop: function() {
    'use strict';
    var that = this;
    this.friends.forEach(function(friend) {
        console.log(that.name + ' knows ' + friend);
    });
}
```
Here’s the interaction:

```javascript
> obj.loop();    Jane knows Tarzan    Jane knows Cheeta
```

* Workaround 2: bind()
We can use bind() to give the callback a fixed value for this—namely, the method’s this (line (1)):```javascript
loop: function() {
    'use strict';
    this.friends.forEach(function(friend) {
        console.log(this.name + ' knows ' + friend);
    }.bind(this)); // (1) }```
* Workaround 3: a thisValue for forEach()
A workaround that is specific to forEach() (see “Examination Methods” on page 291) is to provide a second parameter after the callback that becomes the this of the callback:

```javascript
loop: function() {
    'use strict';
    this.friends.forEach(function(friend) {
        console.log(this.name + ' knows ' + friend);
    }, this);
}
```
#### Layer 2: The Prototype Relationship Between Objects

{% img /images/2014/10/Figure17-1.png%}

To see how prototype-based (or prototypal) inheritance works, let’s look at an example(with invented syntax for specifying the [[Prototype]] property):
```javascript
var proto = {
    describe: function() {
        return 'name: ' + this.name;
    }
};
var obj = {
    [
        [Prototype]
    ]: proto,
    name: 'obj'
};```
The object obj inherits the property describe from proto. It also has a so-called own (noninherited, direct) property, name.

`Inheritance`

obj inherits the property describe; you can access it as if the object itself had that property:

```javascript
> obj.describe[Function]
```
Whenever you access a property via obj, JavaScript starts the search for it in that object and continues with its prototype, the prototype’s prototype, and so on. That’s why we can access proto.describe via obj.describe. The prototype chain behaves as if it were a single object. That illusion is maintained when you call a method: the value of this is always the object where the search for the method began, not where the method was found. That allows the method to access all of the properties of the prototype chain. For example:
```javascript
 > obj.describe()'name: obj'```
* Overriding
```javascript
> obj.describe = function () { return 'overridden' }; 
> obj.describe()'overridden'```
* Sharing Data Between Objects via a Prototype

The objects jane and tarzan both contain the same method, describe(). That is something that we would like to avoid by using sharing:

```javascript
var jane = {
    name: 'Jane',
    describe: function() {
        return 'Person named ' + this.name;
    }
};
var tarzan = {
    name: 'Tarzan',
    describe: function() {
        return 'Person named ' + this.name;
    }
};
```
The following code creates objects jane and tarzan that share the prototype Person Proto:
```javascript
var PersonProto = {
    describe: function() {
        return 'Person named ' + this.name;
    }
};
var jane = {
    [
        [Prototype]
    ]: PersonProto,
    name: 'Jane'
};
var tarzan = {
    [
        [Prototype]
    ]: PersonProto,
    name: 'Tarzan'
};```
And here is the interaction:

```javascript
> jane.describe()Person named Jane> tarzan.describe()Person named Tarzan
```
#### Getting and Setting the Prototype
So far, we have pretended that you can access the internal property [[Prototype]] from JavaScript. But the language does not let you do that. Instead, there are functions for reading the prototype and for creating a new object with a given prototype.

* Creating a new object with a given prototype
This invocation:

```javascript
    Object.create(proto, propDescObj?)
```
creates an object whose prototype is proto. Optionally, properties can be added via descriptors (which are explained in “Property Descriptors” on page 223). In the following example, object jane gets the prototype PersonProto and a mutable property name whose value is 'Jane' (as specified via a property descriptor):

```javascript
var PersonProto = {
    describe: function() {
        return 'Person named ' + this.name;
    }
};
var jane = Object.create(PersonProto, {
    name: {
        value: 'Jane',
        writable: true
    }
});
```
Here is the interaction:

```
> jane.describe()'Person named Jane'
```
But you frequently just create an empty object and then manually add properties, be‐ cause descriptors are verbose:
```javascript
var jane = Object.create(PersonProto); 
jane.value = 'Jane';```
* Reading the prototype of an object
This method call:
```javascript	Object.getPrototypeOf(obj)```
returns the prototype of obj. Continuing the preceding example:

```javascript
> Object.getPrototypeOf(jane) === PersonPrototrue
```
* Checking whether one object a prototype of another one
This syntax:

```
    Object.prototype.isPrototypeOf(obj)
```
checks whether the receiver of the method is a (direct or indirect) prototype of obj. In other words: are the receiver and obj in the same prototype chain, and does obj come before the receiver? For example:

```javascript
> var A = {};> var B = Object.create(A); 
> var C = Object.create(B); 
> A.isPrototypeOf(C)true> C.isPrototypeOf(A)false
```
* Finding the object where a property is defined
The following function iterates over the property chain of an object obj. It returns the first object that has an own property with the key propKey, or null if there is no such object:

```javascript
function getDefiningObject(obj, propKey) {
    obj = Object(obj); // make sure it’s an object
    while (obj && !{}.hasOwnProperty.call(obj, propKey)) {
        obj = Object.getPrototypeOf(obj);
        // obj is null if we have reached the end
    }
    return obj;
}
```
* The Special Property __proto__
Some JavaScript engines have a special property for getting and setting the prototype of an object: __proto__. It brings direct access to [[Prototype]] to the language:

```javascript
> var obj = {};> obj.__proto__ === Object.prototypetrue> obj.__proto__ = Array.prototype> Object.getPrototypeOf(obj) === Array.prototype true
```

__proto__ is not part of the ECMAScript 5 standard,However, more and more engines are adding support for __proto__ and it will be part of ECMAScript 6.The following expression checks whether an engine supports __proto__ as a special property:

```javascript
Object.getPrototypeOf({ __proto__: null }) === null
```
#### Setting and Deleting Affects Only Own Properties
* Setting a property

```javascript
var proto = { foo: 'a' };var obj = Object.create(proto);

> obj.foo'a'> obj.hasOwnProperty('foo')false
```
Setting foo has the desired result:

```javascript
> obj.foo = 'b'; 
> obj.foo'b'
```
However, we have created an own property and not changed proto.foo:

```javascript
 > obj.hasOwnProperty('foo')true> proto.foo'a'
```
* Deleting an inherited property

You can only delete own properties. Let’s again set up an object, obj, with a prototype, proto:

```javascript
	var proto = { foo: 'a' };	var obj = Object.create(proto);
```
Deleting the inherited property foo has no effect:

```
 > delete obj.footrue> obj.foo'a'
```

* Changing properties anywhere in the prototype chain

If you want to change an inherited property, you first have to find the object that owns it (see “Finding the object where a property is defined” on page 215) and then perform the change on that object. For example, let’s delete the property foo from the previous example:

```
 > delete getDefiningObject(obj, 'foo').foo;true> obj.fooundefined
```
#### Accessors (Getters and Setters)
* Defining Accessors via an Object Literal

The following example uses an object literal to define a setter and a getter for property foo:

```javascript
var obj = {
    get foo() {
        return 'getter';
    },
    set foo(value) {
        console.log('setter: ' + value);
    }
};
```
Here’s the interaction:

```
 > obj.foo = 'bla';setter: bla> obj.foo'getter'
```
#### Defining Accessors via Property Descriptors

```javascript
var obj = Object.create(
    Object.prototype, { // object with property descriptors
        foo: { // property descriptor get: function () {
            return 'getter';
        },
        set: function(value) {
            console.log('setter: ' + value);
        }
    }
});
```
#### Accessors and Inheritance
Getters and setters are inherited from prototypes:

```javascript
> var proto = { get foo() { return 'hello' } };> var obj = Object.create(proto);> obj.foo'hello'
```