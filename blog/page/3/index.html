
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>AllenToFight Blog</title>
	<meta name="author" content="AllenToFight">

	
	<meta name="description" content="Jul 30th, 2014 Ruby Expressions 显而易见的是我们可以chain statements a = b = c = 0 # =&gt; 0 [ 3, 1, 7, 0 ].sort.reverse # =&gt; [7, 3, 1, 0] 比如不明显的是， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="AllenToFight Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://xiekunRonaldo.github.io/blog/page/3/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<img src="http://www.gravatar.com/avatar/27a0140c11f18fab9bf284743d2b2b4c?s=160" alt="Profile Picture" style="width: 160px;" />
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="http://about.me/shashankmehta">About</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-30T09:14:04+08:00" data-updated="true" itemprop="datePublished">Jul 30<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/30/expressions/" itemprop="url">Expressions</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>显而易见的是我们可以chain statements</p>

<pre><code>a = b = c = 0 # =&gt; 0

[ 3, 1, 7, 0 ].sort.reverse # =&gt; [7, 3, 1, 0]
</code></pre>

<p>比如不明显的是，在C或Java中的语句在Ruby中通常是expressions,比如if和case语句都返回了最后一个表达式</p>

<pre><code>song_type = if song.mp3_type == MP3::Jazz

				if song.written &lt; Date.new(1935, 1, 1)

					Song::TradJazz

				else

					Song::Jazz

				end 

			else

				Song::Other

			end

rating = case votes_cast

￼			when 0...10		then Rating::SkipThisOne

			when 10...50 	then Rating::CouldDoBetter 

			else	Rating::Rave

		 end #####Operator Expressions 在Ruby中，许多operations是以方法调用的形式实现的，比如，当你写a*b+c时，实际上你是调用了a的方法`*`传入参数b,然后a`*`b的结果返回一个对象，我们再对其执行`+`的方法,然后将c作为参数传入,实际下相当于以下代码

a, b, c = 1, 2, 3

a * b + c # =&gt; 5

 (a.*(b)).+(c) # =&gt; 5
</code></pre>

<p>我们问题可以定义最基本的运算符操作</p>

<pre><code>class Fixnum

alias old_plus + # We can reference the original '+' as 'old_plus'

def +(other) # Redefine addition of Fixnums. This is a BAD IDEA! 

old_plus(other).succ

end end

1 + 2 # =&gt; 4 a=3

a+=4 #=&gt;8 

a + a + a # =&gt; 26	 
</code></pre>

<h6 id="section">«操作符</h6>

<pre><code>a = [ 1, 2, 3 ]

a&lt;&lt;4 #=&gt;[1,2,3,4]
</code></pre>

<p>我们也可以定义«操作符方法</p>

<pre><code>class ScoreKeeper 

	def initialize

           @total_score = @count = 0

	end

	def &lt;&lt;(score)

	           @total_score += score

	           @count += 1

	           self

	end

	def average

		fail "No scores" if @count.zero?

	    Float(@total_score) / @count

	end 

end
     
scores = ScoreKeeper.new

scores &lt;&lt; 10 &lt;&lt; 20 &lt;&lt; 40

puts "Average = #{scores.average}"

produces:

       Average = 23.333333333333332
</code></pre>

<p>注意«方法中返回了self，这样它就允许<code>scores &lt;&lt; 10 &lt;&lt; 20 &lt;&lt; 40</code>这样的形式</p>

<p><code>[]</code>也能被定义为一个方法调用，你可以这么写</p>

<pre><code>some_obj[1,2,3]
</code></pre>

<p>我们可以这样定义</p>

<pre><code>class SomeClass

	def [](p1, p2, p3)

	# ...

	end

end
</code></pre>

<p>同样地，也可以定义<code>[]=</code>方法</p>

<pre><code>class SomeClass 

	def []=(*params)

		value = params.pop

		puts "Indexed with #{params.join(', ')}" 

		puts "value = #{value.inspect}"

	end

end

s = SomeClass.new

s[1] = 2

s['cat', 'dog'] = 'enemies'

produces:

       Indexed with 1

       value = 2

       Indexed with cat, dog

       value = "enemies" 从上面我们可以看到`[]`里的参数作为params的前n个数，而=右边的值为params的最后一个参数 #####各种各样的表达式 * Command Expression 以\`\`括起来的字符串或以%x开头的字符串被OS解析为一条bash命令,注意换行符还在

	`date` # =&gt; "Mon May 27 12:30:56 CDT 2013\n" 

	`ls`.split[34] # =&gt; "newfile"

	%x{echo "hello there"} # =&gt; "hello there\n"

	
	for i in 0..3

		status = `dbmanager status id=#{i}` # ...

	end
</code></pre>

<p>我们可以通过全局变量$?来查看命令的exit status</p>

<h4 id="section-1">重定义`</h4>

<p>以上我们得知&#8220;里的字符串默认被当作命令来执行，实际上，string是被当作参数传给了方法Object#`,如果你想，可以重写它，</p>

<pre><code>alias old_backquote ` 

	def `(cmd)

	result = old_backquote(cmd) 

	if $? != 0

		puts "*** Command #{cmd} failed: status = #{$?.exitstatus}" 

	end
	result
end

print `ls -l /etc/passwd`

print `ls -l /etc/wibble`

produces:

   -rw-r--r--  1 root  wheel  5086 Jul 20  2011 /etc/passwd

   ls: /etc/wibble: No such file or directory

   *** Command ls -l /etc/wibble failed: status = 1
</code></pre>

<h4 id="section-2">赋值</h4>

<p>Ruby有两种形式的赋值，第一种是将对象的引用赋予一个变量或常量</p>

<pre><code>instrument = "piano" 

MIDDLE_A = 440
</code></pre>

<p>第二种形式涉及到<code>having an object attribute or element reference on the left side.</code>这种形式是很特别的，因为它们通过在左值中调用方法来实现，也就是说你可以重写这些方法</p>

<pre><code> class ProjectList 

	 def initialize

	    @projects = []

	end

	def projects=(list)

		@projects = list.map(&amp;:upcase) # store list of names in uppercase 

	end

	def [](offset) 

		@projects[offset]

	end 

end

list = ProjectList.new

list.projects = %w{ strip sand prime sand paint sand paint rub paint }

list[3] # =&gt; "SAND"

list[4] # =&gt; "PAINT" 来看一段有意思的代码

class Test

	def val=(val)

		@val = val

		return 99 

	end

end

t = Test.new

result = (t.val = 2)

result
</code></pre>

<p>以上的result会是什么值?
在Ruby的过去版本中，赋值方法的返回值<code>总量</code>return的值，而从Ruby1.8开始,返回值总是传入的参数值
所以以上的result值如果在过去的版本中为99，但在1.8版本后则为2</p>

<h6 id="parallel-assignment">Parallel Assignment</h6>

<pre><code>a,b=1,2 #a=1,b=2 

a,b=b,a #b=2,a=1

a=1,2,3,4 # a=[1,2,3,4] 

b=[1,2,3,4] # b=[1,2,3,4]	

a,b=1,2,3,4 # a=1, b=2 

c,=1,2,3,4 # c=1
</code></pre>

<h5 id="splats-and-assignment">Splats and Assignment</h5>

<pre><code>a, b, c, d, e = *(1..2), 3, *[4, 5] # a=1, b=2, c=3, d=4, e=5
 	
a,*b=1,2,3 # a=1, b=[2,3] a,*b=1 # a=1, b=[]

*a,b=1,2,3,4 		# a=[1,2,3], b=4

c,*d,e=1,2,3,4 		# c=1, d=[2,3], e=4

f,*g,h,i,j=1,2,3,4	# f=1, g=[], h=2, i=3, j=4

first, *, last = 1,2,3,4,5,6 # first=1, last=6 #####嵌套赋值

a, (b, c), d = 1,2,3,4			# a=1, b=2, c=nil, d=3

a, (b, c), d = [1,2,3,4] 		# a=1, b=2, c=nil, d=3

a, (b, c), d = 1,[2,3],4 		# a=1, b=2, c=3, d=4

a, (b, c), d = 1,[2,3,4],5 		# a=1, b=2, c=3, d=5

a, (b,*c), d = 1,[2,3,4],5		# a=1, b=2, c=[3, 4], d=5
</code></pre>

<p>Ruby中木有++和–运算符</p>

<h4 id="conditional-execution">Conditional Execution</h4>

<pre><code>var ||= "default value"
</code></pre>

<p>相当于</p>

<pre><code>var = "default value" unless var 
</code></pre>

<h5 id="defined">defined?</h5>

<pre><code>defined? 1			# =&gt; "expression"

defined? dummy		# =&gt; nil

defined? printf		# =&gt; "method"

defined? String		# =&gt; "contant"

defined? $_			# =&gt; "global-variable"

defined? Math::PI # =&gt; "constant"

defined? a = 1 		# =&gt; "assignment"

defined? 42.abs 	# =&gt; "method"

defined? nil		# =&gt; "nil"
</code></pre>

<h5 id="comparing-objects">Comparing Objects</h5>

<p>除了boolean运算符，Ruby对象支持用方法==，===，&lt;=&gt;, =~,eql?和equal?来比较,&lt;=&gt;定义在Object类中,但通常被重写来实现类希望的语义,比如Array类重定义了==所以两个array对象只有在它们的元素个数一样，并且相应的元素也相等的情况下才真正的相等</p>

<p>==和=~都有相应地否定形式,!=和!~,如果调用!=或!~,Ruby首先寻找此类的!=或!~,如果发现就调用它们，如果不发现，就调用==或=~,然后再对结果取反</p>

<pre><code>class T

	def ==(other)

		puts "Comparing self == #{other}"

	other == "value" 

	end

end

t = T.new

p (t == "value") 

p (t != "value")

produces:

Comparing self == value

true

Comparing self == value

false
</code></pre>

<p>以上调用<code>t != "value"</code>时,首先调用t = “value”,然后再对结果取反
各操作符的意义如下</p>

<p><img src="/images/2014/7/operator.png" /></p>

<h5 id="if-and-unless-expressions">if and unless Expressions</h5>
<p>if then语句</p>

<pre><code>if artist == "Gillespie" then handle = "Dizzy"

elsif artist == "Parker" then handle = "Bird"

else

handle = "unknown" 

end
</code></pre>

<p>关键字<code>then</code>是optional的，如果你想将语句多行排列的话</p>

<pre><code>if artist == "Gillespie" 

	handle = "Dizzy"

elsif artist == "Parker" 

	handle = "Bird"

else

handle = "unknown" 

end
</code></pre>

<p>不过如果你想将then后对应的语句与if语句放在同一行，then是必不可少的!</p>

<pre><code>if artist == "Gillespie" then handle = "Dizzy" 

elsif artist == "Parker" then handle = "Bird" 

else handle = "unknown"

end
</code></pre>

<p>与if对应的是unless</p>

<pre><code>unless duration &gt; 180 

	listen_intently

end
</code></pre>

<h5 id="if-and-unless-modifiers">if and unless Modifiers</h5>

<pre><code>mon, day, year = $1, $2, $3 if date =~ /(\d\d)-(\d\d)-(\d\d)/ 

puts "a = #{a}" if $DEBUG

print total unless total.zero?

File.foreach("/etc/passwd") do |line|

next if line =~ /^#/ # Skip comments 

parse(line) unless line =~ /^$/ # Don't parse empty lines

end
</code></pre>

<h5 id="case-expressions">case Expressions</h5>
<ul>
  <li>
    <p>第一种形式</p>

    <pre><code>  case

  when song.name == "Misty"

  puts "Not again!"

  when song.duration &gt; 120

  puts "Too long!"

  when Time.now.hour &gt; 21

  puts "It's too late" 

  else

  song.play

  end
</code></pre>
  </li>
  <li>
    <p>第二种形式	</p>

    <pre><code>  case command 

  when "debug"

    dump_debug_info

    dump_symbols 

  when /p\s+(\w+)/

  dump_variable($1) 

  when "quit", "exit"

  exit

  else

  print "Illegal command: #{command}" 

  end
</code></pre>
  </li>
  <li>
    <p>第三种形式
与then语句结合使用</p>

    <pre><code>  kind = case year

  when 1850..1889 then "Blues"

  when 1890..1909 then "Ragtime"

  when 1910..1929 then "New Orleans Jazz" when 1930..1939 then "Swing"

  else "Jazz"

  end
</code></pre>
  </li>
</ul>

<p>case的比较是用 <code>===</code>来比较的,所以，只要类为<code>===</code>定义了有意义的语义,此类的对象就能用在case语句中</p>

<p>需要<code>注意</code>的是,ruby的类是<code>Class</code>类的对象，===已经在Class类中定义了，可以用来测试相应的argument是否是receiver的instance或它的superclasses之一，所以你可以测试对象的类</p>

<pre><code>case shape

when Square, Rectangle

# ...

when Circle

# ...

when Triangle 

# ...

else

# ...

end
</code></pre>

<h4 id="loops">Loops</h4>

<p>while与until表达的意义相反</p>

<pre><code>while line = gets # ...

end	

until play_list.duration &gt; 60 

play_list.add(song_list.pop)

end

a=1

a*=2 whilea&lt;100 a # =&gt; 128

a -= 10 until a &lt; 100 a # =&gt; 98
</code></pre>

<p>range用作条件语句</p>

<pre><code>file = File.open("ordinal") 

while line = file.gets

	puts(line) if line =~ /third/ .. line =~ /fifth/ 

end

produces:

third

fourth

fifth
</code></pre>

<p>range中的起始位置也可以是表达式</p>

<pre><code>File.foreach("ordinal") do |line|
	if (($. == 1) || line =~ /eig/) .. (($. == 3) || line =~ /nin/)
	print line
	end 

end

produces:

first

second

third

eighth

ninth 如果你用`begin.....end`block，则不论while的条件语句是什么，都会`至少`执行一次

print "Hello\n" while false 

begin

	print "Goodbye\n" 

end while false

produces:

Goodbye
</code></pre>

<h4 id="iterators">Iterators</h4>

<pre><code>3.times do

print "Ho! "

end

produces:

Ho! Ho! Ho!
</code></pre>

<p>upto有使用</p>

<pre><code>0.upto(9) do |x|

print x, " "

end

produces:

0123456789 step

0.step(12, 3) {|x| print x, " " } 

produces:

0 3 6 9 12
</code></pre>

<p>array的遍历</p>

<pre><code>[ 1, 1, 2, 3, 5 ].each {|val| print val, " " } 

produces:

11235 each

File.open("ordinal").grep(/d$/) do |line| 

	puts line

end

produces:

second

third
</code></pre>

<p>loop的使用</p>

<pre><code>loop do
	# block ...
end for...in

for song in playlist

song.play

end
</code></pre>

<p>如果按以上这么写，则Ruby会将它翻译成</p>

<pre><code>playlist.each do |song|

	song.play

end 你可以将for....in用在任何定义了each的方法的类上

for i in File.open("ordinal").find_all {|line| line =~ /d$/} 

	print i.chomp, " "

end



class Periods 

	def each

	yield "Classical" 

	yield "Jazz" 

	yield "Rock"

	end 

end

periods = Periods.new 

for genre in periods

print genre, " " end

produces:

Classical 

Jazz 

Rock
</code></pre>

<h5 id="breakredonext">break,redo,next</h5>
<p>break和next后面可以跟一个value</p>

<pre><code>result = while line = gets

			break(line) if line =~ /answer/

	 	 end process_answer(result) if result
</code></pre>

<h4 id="section-3">作用域</h4>

<p>注意以下代码中,a的赋值语句虽然没有执行，但在之后的语句中a仍然可用</p>

<pre><code>a = "never used" if false 

[99].each do |i|

	a = i # this sets the variable in the outer scope 

end

a # =&gt; 99
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-29T22:17:21+08:00" data-updated="true" itemprop="datePublished">Jul 29<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/29/more-about-methods/" itemprop="url">More About Methods</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h5 id="section">定义一个方法</h5>

<p>一个方法用关键字def来定义，方法名应该以一个小写字母或一个下划线开头，紧跟着字母，数字和下划线,方法名也许以一个?,!或=号结尾，一个返回bool值的方法通常以一个?结果</p>

<pre><code>1.even? # =&gt; false 

2.even? # =&gt; true 

1.instance_of?(Fixnum) # =&gt; true
</code></pre>

<p>危险的方法，或是修改调用者的方法，可以用一个!来结尾,有时这些方法叫做<code>bang methods</code>,比如，类String提供了chop和chop！两种方法，前者返回了一个修改的string，后者则修改了调用此方法的字符串
能出现在赋值运算符<code>=</code>左边的方法以一个<code>=</code>结尾,如</p>

<pre><code>class BookInStock

	attr_reader :isbn, :price

	def initialize(isbn, price) 

	@isbn = isbn

	@price = Float(price)

	end

	def price=(new_price) 

	@price = new_price

	end
	# ...
end

book = BookInStock.new("isbn1", 33.80) 

book.price = book.price * 0.75 有参和无参方法定义如下

def my_new_method(arg1, arg2, arg3) # 3 arguments 

	# Code for the method would go here
end

def my_other_new_method # No arguments 

	# Code for the method would go here

end
</code></pre>

<p>可以为参数指定默认值</p>

<pre><code>def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach") 

	"#{arg1}, #{arg2}, #{arg3}."

end

cool_dude							# =&gt; "Miles, Coltrane, Roach."
		
cool_dude("Bart")					# =&gt; "Bart, Coltrane, Roach."

cool_dude("Bart", "Elwood")			# =&gt; "Bart, Elwood, Roach."

cool_dude("Bart", "Elwood", "Linus") # =&gt; "Bart, Coltrane, Linus."
</code></pre>

<p>后一个参数的默认值也可以指定为与前一个参数相关的表达式</p>

<pre><code>def surround(word, pad_width=word.length/2) 

	"[" * pad_width + word + "]" * pad_width

end

surround("elephant") # =&gt; "[[[[elephant]]]]" 

surround("fox") # =&gt; "[fox]"

surround("fox", 10) # =&gt; "[[[[[[[[[[fox]]]]]]]]]]"
</code></pre>

<h5 id="section-1">可变参数</h5>

<pre><code>def varargs(arg1, *rest)

	"arg1=#{arg1}. rest=#{rest.inspect}"

end

varargs("one")					# =&gt; arg1=one.  rest=[]

varargs("one", "two")			# =&gt; arg1=one.  rest=["two"]

varargs "one", "two", "three"	# =&gt; arg1=one.  rest=["two", "three"]	 有时我们用*来指定不被此类方法但被superclass中的此同名方法调用的参数,注意这种情况下我们直接调用super(无任何参数)，这种特殊的情况下意味着"在superclass中调用此方法，此所有的参数传到此类super的同名方法"

class Child &lt; Parent

def do_something(*not_used)

    # our processing

super end

end
</code></pre>

<p>你也可以只写一个*</p>

<pre><code>class Child &lt; Parent 

	def do_something(*)

	    # our processing

		super 

	end

end
</code></pre>

<p>你可以将带*的参数放在方法参数列表的任意位置</p>

<pre><code>def split_apart(first, *splat, last)

	puts "First: #{first.inspect}, splat: #{splat.inspect}, " +
	"last: #{last.inspect}" 

end

split_apart(1,2)

split_apart(1,2,3)

split_apart(1,2,3,4)

produces:

First: 1, splat: [], last: 2

First: 1, splat: [2], last: 3

First: 1, splat: [2, 3], last: 4
</code></pre>

<p>你也可以只关心起始的参数，这样，你可以像以下这样定义方法</p>

<pre><code>def split_apart(first, *, last)
</code></pre>

<h5 id="methods-and-blocks">Methods and Blocks</h5>

<p>方法可以用yield来调用与它相关联的block</p>

<pre><code>def double(p1) yield(p1*2)

end

double(3) {|val| "I got #{val}" } # =&gt; "I got 6" 

double("tom") {|val| "Then I got #{val}" } # =&gt; "Then I got tomtom"
</code></pre>

<p>如果一个方法的最后一个参数以&amp;开头，任何相关的block都能当作参数传入方法并被转化为一个Proc对象</p>

<pre><code>class TaxCalculator

	def initialize(name, &amp;block)

		@name, @block = name, block

	end

	def get_tax(amount)

		"#@name on #{amount} = #{ @block.call(amount) }" 

	end

end


tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 } 

tc.get_tax(100) # =&gt; "Sales tax on 100 = 7.5"

tc.get_tax(250) # =&gt; "Sales tax on 250 = 18.75"
</code></pre>

<h5 id="section-2">调用方法</h5>

<pre><code>connection.download_mp3("jitterbug") {|p| show_progress(p) } //对象

File.size("testfile") # =&gt; 66 			//类

Math.sin(Math::PI/4) # =&gt; 0.7071067811865475    //Module
</code></pre>

<p>如果省略了receiver,默认是self</p>

<pre><code>class InvoiceWriter

	def initialize(order)

	    @order = order
	    
	end

	def write_on(output)

	    write_header_on(output)

	    write_body_on(output)

	    write_totals_on(output)

	end

private
	def write_header_on(output)

	# ...

	end

	def write_body_on(output)

	# ...

	end

	def write_totals_on(output)

	# ...

	end 

end
</code></pre>

<h5 id="section-3">将参数传给方法</h5>

<p>在不引起歧义的情况下，你可以省略括号，不过通常不推荐这么做</p>

<pre><code># for some suitable value in 

obj: a = obj.hash # Same as

a = obj.hash() # this.

obj.some_method "Arg1", arg2, arg3 # Same thing as //1.8之前

obj.some_method("Arg1", arg2, arg3) # with parentheses.
</code></pre>

<p>如果你将多个参数传给return语句，方法将会以数组的形式返回这些参数</p>

<pre><code>def meth_three 100.times do |num|

   square = num*num

return num, square if square &gt; 1000 end

end

meth_three # =&gt; [32, 1024]
</code></pre>

<p>你可以按以下方式来获取返回的值</p>

<pre><code>num, square = meth_three 

num # =&gt; 32

square # =&gt; 1024	
</code></pre>

<h5 id="collections">*!在方法调用中展开Collections</h5>

<pre><code>def five(a, b, c, d, e)

	"I was passed #{a} #{b} #{c} #{d} #{e}"

end

five(1,2,3,4,5) #=&gt;"Iwaspassed12345" 

five(1, 2, 3, *['a', 'b']) # =&gt; "I was passed 1 2 3 a b" 

five(*['a', 'b'], 1, 2, 3) # =&gt; "I was passed a b 1 2 3" five(*(10..14)) 

#=&gt;"Iwaspassed1011121314" 

five(*[1,2], 3, *(4..5)) #=&gt;"Iwaspassed12345" Ruby 1.9中， 带*参数可以出现参数列表中的任意位置
</code></pre>

<h5 id="block">Block的妙用</h5>

<p>先来看一段代码</p>

<pre><code>print "(t)imes or (p)lus: " operator = gets

print "number: "

number = Integer(gets)

if operator =~ /^t/

puts((1..10).collect {|n| n*number }.join(", "))

else

puts((1..10).collect {|n| n+number }.join(", ")) 

end

produces:

(t)imes or (p)lus: t

number: 2

2, 4, 6, 8, 10, 12, 14, 16, 18, 20
</code></pre>

<p>以上的代码能工作，但是很丑陋，我们注意到if和else的语句几乎一样，可以用block来改进如下</p>

<pre><code>print "(t)imes or (p)lus: " 

operator = gets

print "number: "

number = Integer(gets)

if operator =~ /^t/

calc = lambda {|n| n*number }

else

  calc = lambda {|n| n+number }

end

puts((1..10).collect(&amp;calc).join(", "))

produces:

(t)imes or (p)lus: t

number: 2

2, 4, 6, 8, 10, 12, 14, 16, 18, 20
</code></pre>

<p>如果方法的最后一个参数是以&amp;开头的，则Ruby认为它是一个Proc对象，方法将它移除出参数列表，然后将Proc对象转为block，再与方法关联</p>

<h5 id="hash-and-keyword-arguments">Hash and Keyword Arguments</h5>
<p>先来看一段代码</p>

<pre><code>class SongList

	def search(field, params)

	# ...

	end 

end

list = SongList.new

list.search(:titles, { genre: "jazz", duration_less_than: 270 })
</code></pre>

<p>实际上这种方式不值得推荐，{}很容易让人误认为是一个block，所以Ruby提供了一个捷径，在参数列表中你可以传入key =&gt; value这种形式,只要它们跟在正常的参数之后，在任何的*和block参数之前，所有的这些键值对都将被组装成一个hash参数传入方法中,可以略去{}	</p>

<pre><code>list.search(:titles, genre: "jazz", duration_less_than: 270)
</code></pre>

<h5 id="keyword-argument-lists">Keyword Argument Lists</h5>
<p>我们仔细研究一下search方法，它接受一个field的名字和一个options hash,也许我们想要默认的duration为120s，并且加入验证方法-非法的验证不让它通过</p>

<p>Ruby 2.0之前，代码是这么写的</p>

<pre><code>def search(field, options)

	options = { duration: 120 }.merge(options) 

	if options.has_key?(:duration)

	    duration = options[:duration]

	    options.delete(:duration)

	end

	if options.has_key?(:genre)

	    genre = options[:genre]

	    options.delete(:genre)

	end

	fail "Invalid options: #{options.keys.join(', ')}" unless options.empty? 

	# rest of method

end
</code></pre>

<p>如果是Ruby 2.0，可以简化为以下</p>

<pre><code>def search(field, genre: nil, duration: 120) 

	p [field, genre, duration ]

end

search(:title)

search(:title, duration: 432)

search(:title, duration: 432, genre: "jazz")

produces:

[:title, nil, 120]

[:title, nil, 432]

[:title, "jazz", 432]
</code></pre>

<p>如果传入的是一个非法选项，Ruby将会报错</p>

<pre><code>search(:title, duraton: 432)

produces:
//是duration，不是duraton!
prog.rb:5:in `&lt;main&gt;': unknown keyword: duraton (ArgumentError)
</code></pre>

<p>你也可以将多个hash参数整合为一个hash参数，只要在方法的参数列表里在某参数的前面加<code>两个</code>星号</p>

<pre><code>def search(field, genre: nil, duration: 120, **rest) 

	p [field, genre, duration, rest ]

end

search(:title, duration: 432, stars: 3, genre: "jazz", tempo: "slow") 

produces:

[:title, "jazz", 432, {:stars=&gt;3, :tempo=&gt;"slow"}]
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-29T12:59:58+08:00" data-updated="true" itemprop="datePublished">Jul 29<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/29/regular-expression/" itemprop="url">Regular Expression</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>正则表达式如下	</p>

<pre><code>/cat/

/123/
</code></pre>

<p>正则表达式<code>/.../</code>里的常量和双引号的字符串类似,实际上，你可以在正则里，你也可以用<code>#{...}</code>表达式的替换形式</p>

<h5 id="matching-strings-with-patterns">Matching Strings with Patterns</h5>

<pre><code>/cat/ =~ "dog and cat" # =&gt; 8 

/cat/ =~ "catch" # =&gt; 0 

/cat/ =~ "Cat" # =&gt; nil
</code></pre>

<p>如果你喜欢也可以把字符串放在前面</p>

<pre><code>"dog and cat" =~ /cat/ # =&gt; 8 

"catch" =~ /cat/ # =&gt; 0 

"Cat" =~ /cat/ # =&gt; nil
</code></pre>

<p>模式匹配如果失败，会返回nil、，而nil在条件表达式中相当于false，所以可以把正则表达式的匹配结果作为if和while的条件语句</p>

<pre><code>str = "cat and dog"

if str =~ /cat/

puts "There's a cat here somewhere"

end

produces:

There's a cat here somewhere
</code></pre>

<p>以下的代码打印”testfile”文件中有”on”字符串的行</p>

<pre><code>File.foreach("testfile").with_index do |line, index| 

puts "#{index}: #{line}" if line =~ /on/

end

produces:

0: This is line one

3: And so on...
</code></pre>

<p>你可以用!~来查找<code>不匹配</code>的字符串</p>

<pre><code>File.foreach("testfile").with_index do |line, index| 

	puts "#{index}: #{line}" if line !~ /on/
	
end

produces:

1: This is line two

2: This is line three
</code></pre>

<h5 id="changing-strings-with-patterns">Changing Strings with Patterns</h5>
<p>sub方法用来查找并替换匹配的字符串</p>

<pre><code>str = "Dog and Cat"

new_str = str.sub(/Cat/, "Gerbil")

puts "Let's go to the #{new_str} for a pint."

produces:

Let's go to the Dog and Gerbil for a pint.
</code></pre>

<p>sub只是替换第一个匹配的，要替换全局匹配的，就用gsub</p>

<pre><code>str = "Dog and Cat"

new_str1 = str.sub(/a/, "*") 

new_str2 = str.gsub(/a/, "*") 

puts "Using sub: #{new_str1}" 

puts "Using gsub: #{new_str2}"

produces:

Using sub: Dog *nd Cat

Using gsub: Dog *nd C*t	 需要注意的是，sub和gsub都返回一个全新的string,不论是否替换！如果替换，也返回原string的一个copy 如果你想要修改原始的string，你可以用sub!和gsub!的形式

str = "now is the time" 

str.sub!(/i/, "*") 

str.gsub!(/t/, "T") 

puts str

produces:

now *s The Time
</code></pre>

<p>不过不像sub和gsub，sub!和gsub!只有在匹配正则表达式时才返回string，如果不匹配，则返回nil，这意味着你可以将它放在条件语句中</p>

<h5 id="digging-deeper">Digging Deeper</h5>

<p>未完待续….</p>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-28T08:10:44+08:00" data-updated="true" itemprop="datePublished">Jul 28<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/28/standard-types/" itemprop="url">Standard Types</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>这一章主要介绍Ruby中的几个标准类型:numbers,strings,ranges,regular expressions 
####Numbers
Integers可以是任何长度(内存有多大，长度就有多大),在一定范围内(通常是pow(-2,30)…pow(2,30)-1或是pow(-2,62)…pow(2,62)-1)的Integers是类Fixnum的对象,超出此范围的则是类Bignum的对象,这个转化过程由Ruby自动来处理</p>

<pre><code>num = 10001 4.times do

puts "#{num.class}: #{num}" num *= num

end

produces:

       Fixnum: 10001


       Fixnum: 100020001


       Fixnum: 10004000600040001


       Bignum: 100080028005600700056002800080001 我们可以在数字前添加0x,0b等前缀,或是下划线

123456 =&gt; 123456	# Fixnum

0d123456 =&gt; 123456		# Fixnum

123_456 =&gt; 123456		# Fixnum - underscore ignored

-543 =&gt; -543			# Fixnum - negative number

0xaabb =&gt; 43707			# Fixnum - hexadecimal

0377 =&gt; 255				# Fixnum - octal

-0b10_1010 =&gt; -42		# Fixnum - binary (negated)

123_456_789_123_456_789 =&gt; 123456789123456789 # Bignum
</code></pre>

<p>Ruby支持rational和complex number,Rational numbers是两个整数的比</p>

<pre><code>Rational(3, 4) * Rational(2, 3) # =&gt; (1/2) Rational("3/4") * Rational("2/3") # =&gt; (1/2)

Complex(1, 2) * Complex(3, 4) # =&gt; (-5+10i) Complex("1+2i") * Complex("3+4i") # =&gt; (-5+10i)
</code></pre>

<p>需要注意的是,不像Perl，在表达式计算时，Strings中的数字并不会自动转为数字
假设有一个文字如下，我们需要计算每行两个数字的和</p>

<pre><code>3	4 

5	6 

7	8 以下的代码并不工作

some_file.each do |line| 

v1, v2 = line.split 		# split line on spaces

print v1 + v2, " "

end

produces:

34 56 78
</code></pre>

<p>应该先把strings转为integers</p>

<pre><code>some_file.each do |line|

v1, v2 = line.split

print Integer(v1) + Integer(v2), " "

end


produces:


7 11 15 #####How Number interact

1 + 2					# =&gt; 3
1 + 2.0 				# =&gt; 3.0
1.0+2	 				# =&gt; 3.0

1.0 + Complex(1,2) 		# =&gt; (2.0+2i)

1 + Rational(2,3) 		# =&gt; (5/3)

1.0 + Rational(2,3) 	# =&gt; 1.6666666666666665 如果你需要除法能返回 一个Rational number,则需引入mathn库,这个库能帮我们以最`自然`的方式展示两数运算的结果

22 / 7 # =&gt; 3

Complex::I * Complex::I # =&gt; (-1+0i)

require 'mathn'

22 / 7 # =&gt; (22/7) 

Complex::I * Complex::I # =&gt; -1
</code></pre>

<h5 id="looping-using-numbers">Looping Using Numbers</h5>

<pre><code>3.times { print "X " } 

1.upto(5) {|i| print i, " " } 

99.downto(95) {|i| print i, " " } 

50.step(80, 5) {|i| print i, " " }

produces:

X X X 1 2 3 4 5 99 98 97 96 95 50 55 60 65 70 75 80 同其他迭代器一样，如果其后没有block，则会返回一个Enumerator对象

10.downto(7).with_index {|num, index| puts "#{index}: #{num}"}


produces:


   0: 10


   1: 9


   2: 8


   3: 7 ####Strings String有两种组成方式，单引号和双引号组成的string 单引号

 'escape using "\\"'   # =&gt; escape using "\"
 
 'That\'s right'       # =&gt; That's right 如果是双引号,你可以用#{expr}来替换strings里的值,如果expr是个全局变量，类变量，或是一个类的实例,花括号可以省略

"Seconds/day: #{24*60*60}" 

"#{'Ho! '*3}Merry Christmas!" "Safe level is #$SAFE"

# =&gt; Seconds/day: 86400

# =&gt; Ho! Ho! Ho! Merry Christmas!

# =&gt; Safe level is 0 {}里的代码不一定只是一个表达式，也可以由多条语句构成

puts "now is #{ def the(a)
				 'the ' + a

				end

				the('time')

				} for all bad coders..."
produces:

now is the time for all bad coders... 你还可以用另外三种方式来构建一个string常量:%q,%Q以及here documents 你可以把%q看成是单引号,%Q看成是双引号

%q/general single-quoted string/		# =&gt; general single-quoted string

%Q!general double-quoted string! 		# =&gt; general double-quoted string

%Q{Seconds/day: #{24*60*60}}			# =&gt; Seconds/day: 86400 实际上Q是可有可无的

%!general double-quoted string! # =&gt; general double-quoted string 

%{Seconds/day: #{24*60*60}} # =&gt; Seconds/day: 86400
</code></pre>

<p>实际上紧跟在q或Q后的是分隔符,分隔符可以由任何<code>nonalphanumeric</code> 或 <code>nonmultibyte</code>字符组成
最后,我们来看看如何用<code>here document</code>来创建string</p>

<pre><code>string = &lt;&lt;END_OF_STRING

	The body of the string is the input lines up to
	one starting with the same text that followed the '&lt;&lt;'
END_OF_STRING
</code></pre>

<p>通常terminator从第一行开始，不过，如果你把一个负号放在«后，你可以对terminator进行缩进，创建的string也会进行缩进</p>

<pre><code>string = &lt;&lt;-END_OF_STRING

	The body of the string is the input lines up to
	one starting with the same text that followed the '&lt;&lt;' 
END_OF_STRING 你也可以将多个here documents放在同一行上，每一个代表一个单独的string,here document的bodies从source lines中依次获取

print &lt;&lt;-STRING1, &lt;&lt;-STRING2 
Concat

STRING1

      enate

      STRING2

produces:

Concat 

	enate  注意在此情况下Ruby并不会将enate前的空格给去掉
</code></pre>

<h4 id="strings-and-encodings">Strings and Encodings</h4>
<p>每一个string都有一个对应的encoding,一个string的默认的encoding取决于包含它的源文件的encoding,如果没有指明显式的encoding,一个源文件(和它的string)在Ruby 1.9用的是US-ASCII编码，Ruby 2则是UTF-8</p>

<pre><code>plain_string = "dog"

puts RUBY_VERSION

puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}"


produces:

2.0.0

Encoding of "dog" is UTF-8
</code></pre>

<p>如果你在文件的开头指明用了哪个encoding,文件中所有的string都 会用此encoding</p>

<pre><code>#encoding: utf-8


plain_string = "dog"


puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}" utf_string = "δog"


puts "Encoding of #{utf_string.inspect} is #{utf_string.encoding}"


produces:


Encoding of "dog" is UTF-8


Encoding of "δog" is UTF-8
</code></pre>

<h6 id="working-with-strings">Working with Strings</h6>

<p>假设一个文件有以下格式</p>

<pre><code>/jazz/j00132.mp3  | 3:45 | Fats     Waller     | Ain't Misbehavin'

/jazz/j00319.mp3  | 2:58 | Louis    Armstrong  | Wonderful World

/bgrass/bg0732.mp3| 4:09 | Strength in Numbers | Texas Red
</code></pre>

<p>现在我们要做以下三件事情</p>

<ol>
  <li>将每一行分解成fields</li>
  <li>将时间从mm:ss转为秒</li>
  <li>
    <p>移除artist中名字中的空格
先来看看第一步</p>

    <pre><code> Song = Struct.new(:title, :name, :length)


 File.open("songdata") do |song_file| songs = []


 song_file.each do |line|


 file, length, name, title = line.chomp.split(/\s*\|\s*/) 

 name.squeeze!(" ")

 songs &lt;&lt; Song.new(title, name, length)


 end


   puts songs[1]


 end

 produces:


 #&lt;struct Song title="Wonderful World", name="Louis Armstrong", length="2:58"&gt; 注意上面的line.chomp,因为每一行都有一个换行符，所以必须把它去掉 来看下如何处理时间,用split也可以，但我们用更好的方式scan

 Song = Struct.new(:title, :name, :length) 
	
 File.open("songdata") do |song_file|


 songs = []


 song_file.each do |line|


 file, length, name, title = line.chomp.split(/\s*\|\s*/) 

 name.squeeze!(" ")


 mins, secs = length.scan(/\d+/)


 songs &lt;&lt; Song.new(title, name, mins.to_i*60 + secs.to_i)



 end


 puts songs[1]


 end

 produces:

 #&lt;struct Song title="Wonderful World", name="Louis Armstrong", length=178&gt; ####Ranges
</code></pre>
  </li>
</ol>

<p>ranges主要用在以下三个方面:sequences, conditions和intervals</p>

<p>1.Ranges as Sequences</p>

<pre><code>1..10

'a'..'z' 0..."cat".length 你可以用to_a将一个range转为一个数组,用to_enum将它转为一个Enumberator

(1..10).to_a # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 


('bar'..'bat').to_a # =&gt; ["bar", "bas", "bat"]


enum = ('bar'..'bat').to_enum


enum.next # =&gt; "bar"


enum.next # =&gt; "bas"
</code></pre>

<p>Ranges有很多方法能让你遍历它们并且用很多方法测试它们</p>

<pre><code>digits = 0..9


digits.include?(5) # =&gt; true


digits.max # =&gt; 9


digits.reject {|i| i &lt; 5 } # =&gt; [5, 6, 7, 8, 9]  digits.inject(:+) # =&gt; 45
</code></pre>

<p>目前我们已经看到了numbers和strings的ranges，实际上，ranges也可以基于你定义的对象来创建,惟一的要求是对象必须定义succ方法，这个方法返回了序列中的下一个对象，这个对象还必须实现<code>&lt;=&gt;</code>(有时称为<code>spaceship operator</code>),允许对象之间的比较,返回-1,0, 1</p>

<pre><code>class PowerOfTwo 

	attr_reader :value 

	def initialize(value)


		@value = value


	end


	def &lt;=&gt;(other)


	    @value &lt;=&gt; other.value


	end


	def succ


	    PowerOfTwo.new(@value + @value)


	end


	def to_s


	@value.to_s


	end 


end


p1 = PowerOfTwo.new(4)


p2 = PowerOfTwo.new(32)


puts (p1..p2).to_a


produces:


4 

8 

16 

32 #####Ranges as Conditions

while line = gets


	puts line if line =~ /start/ .. line =~ /end/


end
</code></pre>

<h5 id="ranges-as-intervals">Ranges as Intervals</h5>
<p>可以借此来查看某些值是否在range间,注意必须用<code>===</code></p>

<pre><code>(1..10) === 5 # =&gt; true

(1..10) === 15 # =&gt; false 

(1..10) === 3.14159 # =&gt; true 

('a'..'j') === 'c' # =&gt; true 

('a'..'j') === 'z' # =&gt; false 还可用在case中

car_age = gets.to_f # let's assume it's 9.5 

case car_age


when 0...1


	puts "Mmm.. new car smell" 

when 1...3


puts "Nice and new" 

when 3...10


	puts "Reliable but slightly dinged" 

when 10...30


	puts "Clunker" 

else


	puts "Vintage gem" 


end


produces:


Reliable but slightly dinged
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-27T15:03:31+08:00" data-updated="true" itemprop="datePublished">Jul 27<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/27/sharing-functionality-inheritance/" itemprop="url">Sharing Functionality: Inheritance</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4 id="section">继承和消息</h4>

<pre><code>class Parent 

	def say_hello


	puts "Hello from #{self}" 

	end

end


p = Parent.new


p.say_hello


class Child &lt; Parent # Subclass the parent...

end	

c = Child.new

c.say_hello

produces:


Hello from #&lt;Parent:0x007fb87110fd98&gt;


Hello from #&lt;Child:0x007fb87110fac8&gt; superclass的方法返回了一个类的父类

class Parent

end

class Child &lt; Parent

end

Child.superclass # =&gt; Parent
</code></pre>

<p>那么，Parent的superclass是什么</p>

<pre><code>class Parent

end

Parent.superclass # =&gt; Object 继续探究

Object.superclass # =&gt; BasicObject
BasicObject.superclass.inspect # =&gt; "nil" 我们可以看到在继承体系中BasicObject是root class ####Modules Modules提供了一种将方法，类和常量聚合在同一空间名下的方式,Modules提供了两大优势
</code></pre>

<ol>
  <li>Modules提供了一个命名空间，并且防止了命名冲突</li>
  <li>
    <p>Modules支持mixin的功能</p>

    <pre><code> //trig.rb
 module Trig

     PI = 3.141592654 

     def Trig.sin(x)

     # ..

     end

     def Trig.cos(x) 


     # ..

     end 

 end


 //moral.rb
 module Moral

     VERY_BAD = 0

     BAD =1

     def Moral.sin(badness)

     # ...

     end 

 end
</code></pre>
  </li>
</ol>

<p>来看看如何使用它们</p>

<pre><code>	require_relative 'trig' 

	require_relative 'moral'


	y = Trig.sin(Trig::PI/4)


	wrongdoing = Moral.sin(Moral::VERY_BAD)
</code></pre>

<h4 id="mixins">Mixins</h4>
<p>Modules还有另外一个很好用的功能，它们可以在很大程序上避免继承的使用,这种方式叫mixin.
从以上的module的demo中我们可以看到，如果我们定义modules的方法，这些方法前面加了module的名字,如果你想到了类方法，那么你可能会想”我是否能在module里定义instance方法”!好问题，一个module不能有instances，因为modules不是类，不过你可以将一个module添加到一个类的定义中，这样，所有的modules的instance方法就同类中的instance方法一样可用了，它们mixed in了，实际上 mixed-in 模块有效地充当了superclass的角色
来看下demo</p>

<pre><code>	module Debug 

		def who_am_i?

			"#{self.class.name} (id: #{self.object_id}): #{self.name}" 

		end


	end

	class Phonograph 

		include Debug 

		attr_reader :name 

		def initialize(name)

		@name = name

	end

	# ...
	end


	class EightTrack 

	include Debug 

	attr_reader :name 

	def initialize(name)

		@name = name

	end

	# ...

	end


	ph = Phonograph.new("West End Blues")


	et = EightTrack.new("Surrealistic Pillow")

	ph.who_am_i? # =&gt; "Phonograph (id: 70266478767560): West End Blues" 

	et.who_am_i? # =&gt; "EightTrack (id: 70266478767520): Surrealistic Pillow"
</code></pre>

<p>mixin的真正威力在mixin的代码开始与使用它的类的代码进行交互时才得以体现出现,我们用Ruby的Mixin Comparable来作一个例子,Comparable mixin为类添加了比较方法(&lt;, &lt;=, ==, &gt;=, 和 &gt;)和between?方法，为了让Comparable工作,Comparable假设所有使用它的类定义了操作符<code>&lt;=&gt;</code></p>

<pre><code>class Person

	include Comparable 

	attr_reader :name


	def initialize(name) 


		@name = name


	end


	def to_s


		"#{@name}" 

	end


	def &lt;=&gt;(other)

			self.name &lt;=&gt; other.name

		end 

	end

p1 = Person.new("Matz") 

p2 = Person.new("Guido")

 
p3 = Person.new("Larry") # Compare a couple of names


if p1 &gt; p2


puts "#{p1.name}'s name &gt; #{p2.name}'s name"


end


# Sort an array of Person objects


puts "Sorted list:" 


puts [ p1, p2, p3].sort
</code></pre>

<p>produces:</p>

<pre><code>Matz's name &gt; Guido's name


Sorted list:


Guido


Larry


Matz ####Iterators and the Enumerable Module Ruby的collections类(Array, Hash等)支持许多针对collections的操作:遍历，排序等，你可能会想:"如果我的类也支持这些操作该多好"
</code></pre>

<p>好消息是，由于mixins和module Enumberable的存在,你的类能支持所有的这些特性，你需要做的只是写一个each的迭代器，依次返回你的collection里的元素，然后include Enumerable,这样你的类就支持map,include?,find_all?这些方法了，如果在你的collection里的对象用<code>&lt;=&gt;</code>来实现了一些有意义的排序相关的方法，你也能使用如min,max,sort等的方法
####Composing Modules
Enumerable是一个标准的mixin,实现了针对host class中的each相关的许多方法,其中一个是我们之前提到的inject方法，由于要用inject就得include Enumerable，我们能将它用在任何include Enumerable并且实现了each方法的类里
来看看许多内置类对它的使用</p>

<pre><code>[ 1, 2, 3, 4, 5 ].inject(:+) # =&gt; 15

( 'a'..'m').inject(:+) # =&gt; "abcdefghijklm" 来看看如何定义我们自己的类来使用Enumerable中的inject

//vowel_finder.rb

class VowelFinder 

	include Enumerable

	def initialize(string)

	 @string = string

	end

	def each

		@string.scan(/[aeiou]/) do |vowel| 

		yield vowel

		end 

	end

end
vf = VowelFinder.new("the quick brown fox jumped")
vf.inject(:+) # =&gt; "euiooue" 我们还能将inject的方法封装在module的方法中，如下

module Summable 
	def sum
		inject(:+)
	end end
class Array 
	include Summable
end

class Range 
	include Summable
end


require_relative "vowel_finder" 

class VowelFinder


  include Summable


end


[1,2,3,4,5].sum #=&gt;15 


('a'..'m').sum # =&gt; "abcdefghijklm"


vf = VowelFinder.new("the quick brown fox jumped") 


vf.sum # =&gt; "euiooue" #### Instance Variables in Mixins
</code></pre>

<p>从C++转过来的程序员通常会问”在mixin里的instance variable是如何处理的”
在Ruby中instace variables是这么工作的
以@开头的变量在当前的对象(self)里创建instace variable
对一个mixin而言,如果你在一个类中include了module,你的类对象将创建module里的instance variable并且可以用attr_reader和friends来定义accessors,比如,以下例子中的Observable module为每一个include它的类都添加了@observer_list的instance variable</p>

<pre><code>//observer_impl.rb

module Observable 

	def observers

	    @observer_list ||= []


	end


	def add_observer(obj)


	    observers &lt;&lt; obj


	end


	def notify_observers


	    observers.each {|o| o.update }


	end 


end
</code></pre>

<p>然而这种方式可能会导致一些不可预知的错误,一个mixin的instance variables可能会与inclde它的host class定义的instance variables相冲突,以下的例子显示了一个使用我们的Observer module的类的例子，很不幸的是，它也定义了一个叫做@observer_list的instance variable,在运行时，这个程序可能会导致某些难以调试的错误</p>

<pre><code>require_relative 'observer_impl' 
class TelescopeScheduler

	# other classes can register to get notifications # when the schedule changes


	include Observable


	def initialize


	@observer_list = [] # folks with telescope time


	end


	def add_viewer(viewer)


	    @observer_list &lt;&lt; viewer


	end

	# ...

end
</code></pre>

<p>所以，大部分情况下,mixin modules并不直接使用instance variables,它们用accessors来从client对象获取信息,不过如果你需要创建一个有它自己状态的mixin,你需要确保这些instance variables<code>必须</code>要有惟一的名字，或者也可以创建一个module-level的hash，(key用当前对象的ID表示)来存储instance-specific的data</p>

<pre><code>module Test

	State = {}

	def state=(value)

	    State[object_id] = value

	￼￼end


	def state State[object_id]

	end 

end


class Client 

	include Test

end



c1 = Client.new


c2 = Client.new 


c1.state = 'cat' 

c2.state = 'dog' 

c1.state # =&gt; "cat" 

c2.state # =&gt; "dog"
</code></pre>

<p>使用这种方法的坏处就是，和某个特别的对象关联的数据在此对象被删后并不会马上释放，通常来说，一个需要维护它自己状态的mixin不应该是个mixin，它应该被写成一个类</p>

<h4 id="resolving-ambiguous-method-names">Resolving Ambiguous Method Names</h4>
<p>如果多个被include的mixins，此类，此类的父类中有相同的方法该如何处理
Ruby会首选查看一个对象的类中的方法，然后是被include到mixins,然后是superclass以及其中的mixins,如果一个为类include了多个mixins,最后被include的mixin首先被搜索到</p>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-26T08:51:21+08:00" data-updated="true" itemprop="datePublished">Jul 26<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/26/rong-qi-kuai-die-dai-qi/" itemprop="url">容器-块-迭代器</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4 id="section">数组</h4>
<p>来看看数组是怎么用的</p>

<pre><code>a = [ 3.14159, "pie", 99 ] 
a.class # =&gt; Array 
a.length # =&gt; 3

a[0] # =&gt; 3.14159

a[1] # =&gt; "pie"

a[2] #=&gt;99

a[3] #=&gt;nil

b = Array.new 

b.class # =&gt; Array 

b.length # =&gt; 0 
b[0] = "second"

b[1] = "array"

￼b

a = [ 1, 3, 5, 7, 9 ]

a[-1] # =&gt; 9

a[-2] # =&gt; 7

a[-99] # =&gt; nil

a = [ 1, 3, 5, 7, 9 ] 
a[1,3] #=&gt;[3,5,7] 
a[3, 1] # =&gt; [7] 
a[-3,2] #=&gt;[5,7]

a = [ 1, 3, 5, 7, 9 ] 

a[1..3] #=&gt;[3,5,7] 

a[1...3] # =&gt; [3, 5] 

a[3..3] #=&gt;[7] 

a[-3..-1] # =&gt; [5, 7, 9]

a=[1,3,5,7,9] 		#=&gt;[1,3,5,7,9]
a[1] = 'bat'		#=&gt; [1, "bat", 5, 7, 9]

a[-3] = 'cat'		#=&gt; [1, "bat", "cat", 7, 9]

a[3] =[9,8]			#=&gt; [1, "bat", "cat", [9, 8], 9]

a[6] = 99			#=&gt; [1, "bat", "cat", [9, 8], 9, nil, 99]


a = [ 1, 3, 5, 7, 9 ]		#=&gt;[1,3,5,7,9]

a[2, 2] = 'cat'				#=&gt; [1, 3, "cat", 9]

a[2, 0] = 'dog' 			#=&gt; [1, 3, "dog", "cat", 9] 

a[1,1]=[9,8, 7] 			#=&gt;[1,9,8,7,"dog","cat",9]

a[0..3] = []				#=&gt; ["dog", "cat", 9]

a[5..6] = 99, 98			#=&gt; ["dog", "cat", 9, nil, nil, 99, 98] 数组有许多有用的方法，使用它们，你能将数组作为栈(stacks),集和(sets),队列(queues),[dequeues](http://en.wikipedia.org/wiki/Double-ended_queue),先进先出的queues 比如,push和pop方法从数组的末端添加和删除元素，所以你能将数组作为栈来使用

stack = []


stack.push "red"


stack.push "green"


stack.push "blue"


stack # =&gt; ["red", "green", "blue"]


stack.pop # =&gt; "blue" 


stack.pop # =&gt; "green" 


stack.pop # =&gt; "red" 


stack #=&gt;[]
</code></pre>

<p>同样地,unshift和shift从数组的起始位置添加和删除元素,结合shift和push，你能构建一个FIFO的队列</p>

<pre><code>queue = []


queue.push "red" 

queue.push "green" 

queue.shift # =&gt; "red" 

queue.shift # =&gt; "green"
</code></pre>

<p>first和last方法返回一个数组的头部和尾部的n个元素</p>

<pre><code>array = [ 1, 2, 3, 4, 5, 6, 7 ] 

array.first(4) # =&gt; [1, 2, 3, 4] 

array.last(4) # =&gt; [4, 5, 6, 7]
</code></pre>

<h4 id="section-1">哈希(字典)</h4>
<p>同数组一样,哈希也是针对数组引用的以索引查询的集合,不过与数组不同的是，数组的下标只能为整形，而哈希的key则可为symbols,strings,regular expression等</p>

<pre><code>h = { 'dog' =&gt; 'canine', 'cat' =&gt; 'feline', 'donkey' =&gt; 'asinine' }


h.length # =&gt; 3


h['dog'] # =&gt; "canine"


h['cow'] = 'bovine'


h[12] = 'dodecine'


h['cat'] = 99


h 			# =&gt; {"dog"=&gt;"canine", "cat"=&gt;99, "donkey"=&gt;"asinine", "cow"=&gt;"bovine",
            # .. 12=&gt;"dodecine"}
</code></pre>

<p>从Ruby 1.9开始,如果key是symbols,你可以用以下方式创建hash</p>

<pre><code>h = { :dog =&gt; 'canine', :cat =&gt; 'feline', :donkey =&gt; 'asinine' } 也可以这么写

h = { dog: 'canine', cat: 'feline', donkey: 'asinine' }
</code></pre>

<h4 id="section-2">用哈希和数组来完成单词的计数</h4>
<p>现在我们要完成一个demo,给定一段文字，从中计算出每个单词出现的频率
我们将问题分成两步</p>

<ol>
  <li>
    <p>将这一段文字作为一个字符串，然后返回此字符串里的单词(保存在数组中)</p>

    <pre><code> def words_from_string(string) 
     string.downcase.scan(/[\w']+/)

 end

 p words_from_string("But I didn't inhale, he said (emphatically)")

 结果:

 ["but", "i", "didn't", "inhale", "he", "said", "emphatically"]
</code></pre>
  </li>
  <li>
    <p>为每一个不同的单词都弄一个计数，这个就用hash来实现</p>

    <pre><code>     def count_frequency(word_list) 

     counts = Hash.new(0)

     for word in word_list

         counts[word] += 1

     end

     counts

 end


 p count_frequency(["sparky", "the", "cat", "sat", "on", "the", "mat"]) 


 produces:


 {"sparky"=&gt;1, "the"=&gt;2, "cat"=&gt;1, "sat"=&gt;1, "on"=&gt;1, "mat"=&gt;1} 最后，计算好了hash后，我们要打印出来，这里我们打算按字数出现频率的升序顺序来打印

 sorted = counts.sort_by {|word, count| count} 综上，我们的程序如下

 require_relative "words_from_string.rb" 
 require_relative "count_frequency.rb"

 raw_text = %{The problem breaks down into two parts. First, given some text as a string, return a list of words. That sounds like an array. Then, build a count for each distinct word. That sounds like a use for a hash---we can index it with the word and use the corresponding entry to keep a count.}

 word_list = words_from_string(raw_text)

 counts    = count_frequency(word_list)

 sorted    = counts.sort_by {|word, count| count}

 top_five  = sorted.last(5)
</code></pre>
  </li>
</ol>

<p><code>top_five  = sorted.last(5)</code>是一个数组,每一个元素对应着一个key/value的pair,来看看如何遍历它</p>

<pre><code>for i in 0...5 # (this is ugly code--read on 
	word = top_five[i][0] # for a better version) 
	count = top_five[i][1]

puts "#{word}: #{count}"

end

produces:

that:  2

sounds:  2

like:  2

the:  3

a: 6 ####单元测试 表面上我们对以上的方法进行单元测试 首先是对`words_from_string`

	require_relative 'words_from_string'

	require 'test/unit'

	class TestWordsFromString &lt; Test::Unit::TestCase

		def test_empty_string

			assert_equal([], words_from_string("")) assert_equal([], words_from_string(" "))

		end

		def test_single_word

			assert_equal(["cat"], words_from_string("cat")) 
			assert_equal(["cat"], words_from_string(" cat "))

		end

		def test_many_words

			assert_equal(["the", "cat", "sat", "on", "the", "mat"],

			words_from_string("the cat sat on the mat")) 

		end


		def test_ignores_punctuation 

			assert_equal(["the", "cat's", "mat"],

			words_from_string("&lt;the!&gt; cat's, -mat-")) 


		end

	end


	produces:

	Run options:

	# Running tests:

	....

	Finished tests in 0.006458s, 619.3868 tests/s, 929.0802 assertions/s.
	4 tests, 6 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>在测试框架中，所有以test开头的方法都会自动运行
我们也能测试计算单词出现次数的方法</p>

<pre><code>	require_relative 'count_frequency' 


	require 'test/unit'


	class TestCountFrequency &lt; Test::Unit::TestCase 


		def test_empty_list


		    assert_equal({}, count_frequency([]))


		end


		def test_single_word


			assert_equal({"cat" =&gt; 1}, count_frequency(["cat"])) 


		end


		def test_two_different_words


			assert_equal({"cat" =&gt; 1, "sat" =&gt; 1}, count_frequency(["cat", "sat"]))


		end


		def test_two_words_with_adjacent_repeat


			assert_equal({"cat" =&gt; 2, "sat" =&gt; 1}, count_frequency(["cat", "cat", "sat"])) 


		end


		def test_two_words_with_non_adjacent_repeat


			assert_equal({"cat" =&gt; 2, "sat" =&gt; 1}, count_frequency(["cat", "sat", "cat"]))


		end 


	end


	produces:


	Run options:


	# Running tests:


	.....


	Finished tests in 0.006327s, 790.2639 tests/s, 790.2639 assertions/s.

	5 tests, 5 assertions, 0 failures, 0 errors, 0 skips ####块和迭代器 还记得之前遍历top_five的语句吗,实际上，我们可以按如下方式来遍历数组

top_five.each do |word, count| 
	puts "#{word}: #{count}"

end each方法就是一个迭代器-一个不断调用块的方法,实际上相较于以上的方法，很多程序员更愿意写成如下形式

puts top_five.map { |word, count| "#{word}: #{count}" } 假设有以下程序

square = Shape.new(sides: 4) # 假设 Shape 类在其他地方定义了 # .. lots of code

sum = 0

[1, 2, 3, 4].each do |value| 

	square = value * value

	sum += square

end

puts sum
</code></pre>

<p>现在我们调用</p>

<pre><code>square.draw		//报错 因为在block里square的值被改变了
</code></pre>

<p>我们可以通过将仅作用域仅在块内部的变量放在块的参数列表后面(通过;来分隔)来避免此类现象的发生,如下</p>

<pre><code>[1, 2, 3, 4].each do |value; square| 

	square = value * value

	sum += square

end
</code></pre>

<h5 id="yield">yield的使用</h5>

<pre><code>def fib_up_to(max) 

	i1, i2 = 1, 1 

	while i1 &lt;= max

	yield i1

	    i1, i2 = i2, i1+i2

	end 

end
# parallel assignment (i1 = 1 and i2 = 1)


fib_up_to(1000) {|f| print f, " " }

puts

produces:

1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</code></pre>

<p>注意以下这行的使用</p>

<pre><code>print f, " "
</code></pre>

<p>一个块也能返回一个值，块最后一个表达式的值为yield执行后的值
这就是Array中的find方法工作的原理</p>

<pre><code>class Array 

	def find

		each do |value|

			return value if yield(value)

		end

	nil

	end 

end

[1, 3, 5, 7, 9].find {|v| v*v &gt; 30 } # =&gt; 7 迭代器collect的使用

["H", "A", "L"].collect {|x| x.succ } # =&gt; ["I", "B", "M"]
</code></pre>

<p>迭代器并不限于访问array和hash中已存在的元素，如我们之前在Fibonacci中看到的,一个迭代器能返回推导后的值,</p>

<pre><code>	yield i1

	    i1, i2 = i2, i1+i2

	end 
</code></pre>

<p>同样的，这种特性也被Ruby用在输入输出类中,这些类返回了一个迭代器接口，这些接口在I/O流中返回了连续的行(或bytes),如下</p>

<pre><code>f = File.open("testfile") 

f.each do |line|

	puts "The line is: #{line}" end

f.close


produces:


The line is: This is line one


The line is: This is line two


The line is: This is line three


The line is: And so on... 有时你想跟踪block被调用了多少次，这时你可以试试with_index方法,此方法一般是跟在一个迭代器(如each之后)

f = File.open("testfile") 

f.each.with_index do |line, index|

	puts "Line #{index} is: #{line}" 

end


f.close


produces:


Line 0 is: This is line one


Line 1 is: This is line two
</code></pre>

<p>再看一个有用的迭代器</p>

<pre><code>[1,3,5,7].inject(0) {|sum, element| sum+element} # =&gt; 16 
[1,3,5,7].inject(1) {|product, element| product*element} # =&gt; 105 等价于

[1,3,5,7].inject {|sum, element| sum+element} # =&gt; 16 
[1,3,5,7].inject {|product, element| product*element} # =&gt; 105 等价于

[1,3,5,7].inject(:+) # =&gt; 16 
[1,3,5,7].inject(:*) # =&gt; 105 ####Enumberators-外在迭代器 尽管以上的迭代器有许多好处,不过如果遇到以下情况，你会发现内部迭代器帮不上什么忙
</code></pre>

<ol>
  <li>
    <p>如果你要将迭代器当作一个对象时(比如代要将迭代器传给一个方法，这个方法需要访问这个迭代器里的每个元素)</p>
  </li>
  <li>
    <p>同时访问两个Collections的元素
幸运的是，Ruby中有一个内置的Enumerator类，实现了外在的迭代器，可以处理以上说的两种情况
你可以对array或hash来调用to_enum方法来创建一个Enumberator对象</p>

    <pre><code> a = [ 1, 3, "cat" ]


 h = { dog: "canine", fox: "vulpine" }



 # Create Enumerators


 enum_a = a.to_enum


 enum_h = h.to_enum


 enum_a.next # =&gt; 1


 enum_h.next # =&gt; [:dog, "canine"] 


 enum_a.next # =&gt; 3


 enum_h.next # =&gt; [:fox, "vulpine"]
</code></pre>
  </li>
</ol>

<p>许多内在迭代器方法(产生连接的值传给block，如each) 如果不结合block使用的话将返回一个Enumerator对象</p>

<pre><code>	a = [ 1, 3, "cat" ]


	enum_a = a.each # create an Enumerator using an internal iterator


	enum_a.next # =&gt; 1 enum_a.next # =&gt; 3
</code></pre>

<p>Ruby有一个叫做loop的方法，不做任何事情,主要工作就是不断地调用block,通常来说，如果某些条件发生了，block中的代码将跳出循环,但是当你用Enumerator时，loop可以足够聪明地分辨出一个enumerator对象是否遍历了所有的值，如果遍历完了，loop将终止</p>

<pre><code>short_enum = [1, 2, 3].to_enum 


long_enum = ('a'..'z').to_enum


loop do


	puts "#{short_enum.next} - #{long_enum.next}"


end


produces:


1-a 2-b 3-c
</code></pre>

<h4 id="enumerators">Enumerators是对象</h4>

<p>Enumberators将某些可执行的代码(迭代的行为)转化成一个对象，这意味着你可以用enumerator来做一些普通的循环无法轻易做到的事情,比如Enumerable模块定义了一个each_with_index方法，这个方法触发了原先的each方法，同时也返回了一个index</p>

<pre><code>result = []


[ 'a', 'b', 'c' ].each_with_index {|item, index| result &lt;&lt; [item, index] } 

result # =&gt; [["a", 0], ["b", 1], ["c", 2]]
</code></pre>

<p>如果你想迭代并获取index但又不想用each而想用其他方法来控制迭代又该怎么做呢？比如你想循环string里的每个character,Enumerator派上用场了,如果你不给string的each_char方法一个block,它会返回一个enumerator,然后再调用enumetor的each_with_index方法</p>

<pre><code>result = []

"cat".each_char.each_with_index {|item, index| result &lt;&lt; [item, index] } 


result # =&gt; [["c", 0], ["a", 1], ["t", 2]]
</code></pre>

<p>实际上这是一个很普遍的方法，所以Mats给我们提供了一个方法with_index</p>

<pre><code>result = []


"cat".each_char.with_index {|item, index| result &lt;&lt; [item, index] } 


result # =&gt; [["c", 0], ["a", 1], ["t", 2]]
</code></pre>

<p>我们也可以显式地创建Enumerator对象，这里我们通过调用string的each_char方法来创建，然后我们对enumerator来调用to_s遍历它</p>

<pre><code>enum = "cat".enum_for(:each_char) enum.to_a # =&gt; ["c", "a", "t"]
</code></pre>

<p>如果我们用来构建enumerator的方法中有参数，我们可以将它们传入enum_for</p>

<pre><code>enum_in_threes = (1..10).enum_for(:each_slice, 3) 

enum_in_threes.to_a # =&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]] Enumerator对象也是可enumerable的(也就是说，适应于可enumerable对象的方法也是适用于enumerator的),比如我们可以用Enumerable的first方法


	triangular_numbers = Enumerator.new do |yielder| 


		number = 0


		count = 1


		loop do


		    number += count


		    count  += 1


		    yielder.yield number


		end 


	end


	p triangular_numbers.first(5)


	produces:


	[1, 3, 6, 10, 15] ####Enumberators Are Generators and Filters
</code></pre>

<p>Generators</p>

<pre><code>triangular_numbers = Enumerator.new do |yielder| number = 0


	count = 1


	loop do


	    number += count


	    count += 1


	    yielder.yield number


	end

end


5.times { print triangular_numbers.next, " " } 

puts


produces:


1 3 6 10 15 Filters

triangular_numbers = Enumerator.new do |yielder| # ...

# as before...

# ...

end

def infinite_select(enum, &amp;block) 

Enumerator.new do |yielder|

enum.each do |value|

yielder.yield(value) if block.call(value)

end

end

end

p infinite_select(triangular_numbers) {|val| val % 10 == 0}.first(5)

produces:

[10, 120, 190, 210, 300]
</code></pre>

<p>等价于</p>

<pre><code>triangular_numbers = Enumerator.new do |yielder|


 # ... as before


end


class Enumerator

	def infinite_select(&amp;block)

		Enumerator.new do |yielder| 


			self.each do |value|


				yielder.yield(value) if block.call(value) 

			end

		end 


	end

end


p triangular_numbers

   .infinite_select {|val| val % 10 == 0}

   .infinite_select {|val| val.to_s =~ /3/ }

   .first(5)

produces:
[300, 630, 1830, 3160, 3240] ####Blocks可以是对象 block被转化成了Proc类的对象并将它存储在类的属性中

class ProcExample


def pass_in_block(&amp;action)


    @stored_proc = action


end


def use_proc(parameter)


    @stored_proc.call(parameter)


end 

end

eg = ProcExample.new

eg.pass_in_block { |param| puts "The parameter is #{param}" } 

eg.use_proc(99) 如果一个方法返回了一个block对象又如何调用?

def create_block_object(&amp;block) 

block

end


bo = create_block_object { |param| puts "You called me with #{param}" } 

bo.call 99

bo.call "cat"

produces:

You called me with 99

You called me with cat 实际上这种方式是很有用的，所以Ruby提供了两个方法将一个block转化为一个对象,lambda和Proc.new都接受了一个block来创建一个Proc类的对象

bo = lambda { |param| puts "You called me with #{param}" } 

bo.call 99

bo.call "cat"


produces:


You called me with 99


You called me with cat
</code></pre>

<h4 id="blocks-can-be-closures">Blocks Can Be Closures</h4>

<pre><code>def n_times(thing) 


	lambda {|n| thing * n }


end


p1 = n_times(23)


p1.call(3) # =&gt; 69


p1.call(4) # =&gt; 92


p2 = n_times("Hello ")


p2.call(3) # =&gt; "Hello Hello Hello "


Blocks and Iterators • 65
</code></pre>

<p>n_times方法返回了一个Proc对象并且引用了方法的参数，thing,尽管到block被调用时，参数已经超出范围了，参数仍然能被block访问，这叫做closure(上下文的参数在block或Proc的生命周期中仍能被访问)，两看另外一个例子</p>

<pre><code>def power_proc_generator 

	value = 1
	lambda { value += value }
end

power_proc = power_proc_generator

puts power_proc.call

puts power_proc.call

puts power_proc.call

produces:

2 4 8
</code></pre>

<p>我们可以看到vaue值是一直变化的</p>

<h4 id="proc">另一种创建Proc对象的方式</h4>

<p>之前我们用以下方式来创建Proc</p>

<pre><code>lambda { |params| ... } 你也可以用以下方式来创建

-&gt; params { ... }


proc1 = -&gt; arg { puts "In proc1 with #{arg}" }


proc2 = -&gt; arg1, arg2 { puts "In proc2 with #{arg1} and #{arg2}" } 


proc3 = -&gt;(arg1, arg2) { puts "In proc3 with #{arg1} and #{arg2}" }


proc1.call "ant" 


proc2.call "bee", "cat" 


proc3.call "dog", "elk"


produces:


In proc1 with ant


In proc2 with bee and cat


In proc3 with dog and elk
</code></pre>

<p>比起lambda,-&gt;的形式看紧凑，特别是当你要传多个Proc对象给一个方法的时候</p>

<pre><code>def my_if(condition, then_clause, else_clause) 

	if condition

	    then_clause.call

	else

	    else_clause.call

	end 

end


5.times do |val| 

	my_if val &lt; 2,

		  -&gt; { puts "#{val} is small" }, 

		  -&gt; { puts "#{val} is big" }

end

produces:


0 is small

1 is small

2 is big

3 is big

4 is big
</code></pre>

<h4 id="block-parameter-lists">Block Parameter Lists</h4>

<pre><code>proc1 = lambda do |a, *b, &amp;block| 

	puts "a = #{a.inspect}"
	
	puts "b = #{b.inspect}" 

	block.call

end

proc1.call(1, 2, 3, 4) { puts "in block1" }

produces:

a=1

b = [2, 3, 4] 

in block1 另一种形式

proc2 = -&gt; a, *b, &amp;block do 

	puts "a = #{a.inspect}" 

	puts "b = #{b.inspect}" 

	block.call


end


proc2.call(1, 2, 3, 4) { puts "in block2" }


produces:


a=1


b = [2, 3, 4] in block2




￼
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-23T21:41:14+08:00" data-updated="true" itemprop="datePublished">Jul 23<span>rd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/23/lei-dui-xiang-bian-liang/" itemprop="url">类-对象-变量</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>假设有以下文件</p>

<pre><code>		//data.csv
		
		"Date","ISBN","Price"
	
"2013-04-12","978-1-9343561-0-4",39.45

		"2013-04-13","978-1-9343561-6-6",45.67
	
"2013-04-14","978-1-9343560-7-4",36.95 现在我们的任务就是从这个CSV文件中计算出有相同title的书各有多少本，以及书的总价 我们设计了一个BookInStock的类

class BookInStock
 
end 用new来创建对象

a_book = BookInStock.new 以此创建的类无任何信息，我们可以为此类提供一个initialize的方法，此方法能让我们在每个对象都创建好后就设置对象的状态，我们将此状态存储在实例变量中(以@开头),现在我们更新如下

class BookInStock

	def initialize(isbn, price)

		@isbn = isbn

	    @price = Float(price)

	end 

end initialize是一个特别的方法，当你调用BookInStore.new去创建一个对象的时候,Ruby分配了一些内存给此未初始化的对象，然后调用了initialize的方法，传递了任何传递给new方法的参数，这样就给了你一次设置对象状态的机会


b1 = BookInStock.new("isbn1", 3) 

p b1

produces:

#&lt;BookInStock:0x007fac4910f3e0 @isbn="isbn1", @price=3.0&gt;
</code></pre>

<p>p方法能打印出一个对象的内部表示形式(如@isbn, @price)而puts方法只是简单地将字符串输出到标准输出上，当你将一个对象传给puts时，由于puts不知道如何处理，所以它作了一个简单地处理:对象类的名字+:+对象的内存地址,我们可以改变puts的这种输出形式，只要重写to_s即可</p>

<pre><code>class BookInStock

	def initialize(isbn, price)

			@isbn = isbn

	        @price = Float(price)

	end

	def to_s

	"ISBN: #{@isbn}, price: #{@price}" 

	end

end
	
b1 = BookInStock.new("isbn1", 3)

puts b1
</code></pre>

<p>结果</p>

<pre><code>ISBN: isbn1, price: 3.0 #####对象和属性 以上的@isbn, @price不能访问，无任何意义，可以为它添加get方法

class BookInStock

	def initialize(isbn, price)

		@isbn = isbn

	    @price = Float(price)

	end

	def isbn

		@isbn

	end


	def price 

		@price

	end

# ..

end


book = BookInStock.new("isbn1", 12.34) 

puts "ISBN = #{book.isbn}"

puts "Price = #{book.price}"
</code></pre>

<p>结果</p>

<pre><code>ISBN   = isbn1

Price  = 12.34 由于get方法的使用是如此频繁,Ruby提供了一个简便的方法，attr_reader能为你创建这些属性的get方法

class BookInStock

  attr_reader :isbn, :price


	def initialize(isbn, price) 


		@isbn = isbn


		@price = Float(price)


	end
	# ..
end

book = BookInStock.new("isbn1", 12.34) 

puts "ISBN = #{book.isbn}"

puts "Price = #{book.price}"
</code></pre>

<p>结果:</p>

<pre><code>ISBN   = isbn1

Price  = 12.34
</code></pre>

<p>对应,attr_reader后面跟的是symbols
这里通常有一个误解，特别是那些学过Java和C#的人,他们认为attr_reader在某种程序上声明了实例变量，实际上是没有的，它只是生成了访问方法，但无声明任何变量，这些变量只有在你使用它们的时候才出现，Ruby是完全让实例变量与访问方法解藕的
####可写属性
以上我们只是设置了只读方法,现在我看看如何设置可写方法</p>

<pre><code>class BookInStock

	attr_writer :isbn, :price

	def initialize(isbn, price) 

		@isbn = isbn

		@price = Float(price)

	end

	def price=(new_price) 

		@price = new_price

	end

# ...

end



book = BookInStock.new("isbn1", 33.80) 

puts "ISBN = #{book.isbn}"

puts "Price = #{book.price}" 

book.price = book.price * 0.75

puts "New price = #{book.price}"
</code></pre>

<p>结果:</p>

<pre><code>ISBN      = isbn1

Price     = 33.8

New price = 25.349999999999998
</code></pre>

<p>同样的,Ruby也提供了一个创建属性设置方法的捷径，如果你想有一个只写不可读的方法，可以使用attr_writer,不过这种情况极其罕见，如果你想为某个属性设置可读可写的方法，你可以用attr_accessor</p>

<pre><code>class BookInStock 

	attr_reader :isbn 

	attr_accessor :price

	def initialize(isbn, price) 

		@isbn = isbn

		@price = Float(price)

	end

# ...
end

book = BookInStock.new("isbn1", 33.80) 

puts "ISBN = #{book.isbn}"

puts "Price = #{book.price}" 

book.price = book.price * 0.75

puts "New price = #{book.price}"

结果:
ISBN      = isbn1

Price     = 33.8

New price = 25.349999999999998 ####虚属性

class BookInStock 

	attr_reader :isbn

	attr_accessor :price

	def initialize(isbn, price) 

		@isbn = isbn

		@price = Float(price)

	end

	def price_in_cents 

		Integer(price*100 + 0.5)

	end

# ...

end
</code></pre>

<p>我们看看以下会输出什么</p>

<pre><code>puts "Price in cents = #{book.price_in_cents}"
</code></pre>

<p>结果</p>

<pre><code>rice in cents = 3380
</code></pre>

<p><code>book.price_in_cents</code>表示的就是虚属性，由于<code>price_in_cents</code>不对应任何对象的属性，但我们却提供了访问方法，依然可以通过.的形式访问它,同样的，我们也可以提供一个它的写方法</p>

<pre><code>def price_in_cents=(cents) 

	@price = cents / 100.0

end

book = BookInStock.new("isbn1", 33.80)

puts "Price = #{book.price}"

puts "Price in cents = #{book.price_in_cents}" 


book.price_in_cents = 1234


puts "Price = #{book.price}"


puts "Price in cents = #{book.price_in_cents}"


produces:


Price          = 33.8


Price in cents = 3380


Price          = 12.34


Price in cents = 1234
</code></pre>

<h4 id="section">类与其他类的协同工作</h4>
<p>已知BookInStock定义如上,现在不少csv文件，我们需要将csv文件的每一行转为一个BookInStock,并将每一个BookInStock保存到一个数组中，然后计算所有书的总价,所计算的几个csv文件我们通过命令行传入,现在我们将这个程序分成三个rb文件来操作(假设这三个文件在同一目录下)</p>

<ol>
  <li>
    <p>book_in_stock.rb</p>

    <pre><code> class BookInStock 

     attr_reader :isbn, :price

     def initialize(isbn, price) 

         @isbn = isbn

         @price = Float(price)

     end 

 end
</code></pre>
  </li>
</ol>

<p>2.csv_reader.rb
此文件有两个外部信赖，它需要标准的CSV的库，也需要存储在book_in_stock.rb中的BookInStock的类,我们用require来加载Ruby的CSV库，用require_relative来加载book_in_stock文件</p>

<pre><code>require 'csv'

require_relative 'book_in_stock'

class CsvReader 

	def initialize

	    @books_in_stock = []

	end

	def read_in_csv_data(csv_file_name) 

		CSV.foreach(csv_file_name, headers: true) do |row|

			@books_in_stock &lt;&lt; BookInStock.new(row["ISBN"], row["Price"]) 

		end

	end 

end 3.stock_stats.rb 这是我们的主程序

require_relative 'csv_reader'

reader = CsvReader.new

ARGV.each do |csv_file_name|

	STDERR.puts "Processing #{csv_file_name}" 

	reader.read_in_csv_data(csv_file_name)

end

￼￼￼puts "Total value = #{reader.total_value_in_stock}"
</code></pre>

<p>运行程序如下</p>

<pre><code>$ ruby stock_stats.rb data.csv

Processing data.csv

Total value = 122.07000000000001
</code></pre>

<h5 id="section-1">访问控制</h5>
<p>Ruby给你三种访问控制权限</p>

<ul>
  <li>Public</li>
  <li>Protected</li>
  <li>
    <p>Private
三种访问控制权限与其他语言的一样，不过有一点与其他面向对象的语言很不一样，那就是，Ruby中的访问控制是程序运行后才被确定的，是动态的，而不是静态的，只有当代码执行了访问受限的代码才能知道是否有访问不合法的错误发生
######如何指定访问控制
有以下两种方法</p>

    <pre><code>  class MyClass

      def method1		# 默认是 'public'

      #...

      end

  protected

      def method2

      #....

      end

  private 

      def method3

      #...

      end

  end
</code></pre>
  </li>
</ul>

<p>或</p>

<pre><code>	class MyClass 

		def method1 

		end

		def method2 

		end

# ... and so on

	  public    :method1, :method4

	  protected :method2

	  private   :method3
end ####变量 

	person = "Tim"

	puts "The object in 'person' is a #{person.class}" 

	puts "The object has an id of #{person.object_id}" 

	puts "and a value of '#{person}'"

	produces:

       The object in 'person' is a String

       The object has an id of 70230663692980

       and a value of 'Tim'
</code></pre>

<p>那么，变量是否是一个对象呢，答案是否定的，一个变量只是一个对象的引用,来看以下例子，一目了然</p>

<pre><code>	person1 = "Tim"

	person2 = person1 

	person1[0] = 'J'

	puts "person1 is #{person1}" 

	puts "person2 is #{person2}"

	produces:
	  
	       person1 is Jim

	       person2 is Jim
</code></pre>

<p>你可以用String的
dup方法来创建一个全新的对象</p>

<pre><code>	person1 = "Tim"

	person2 = person1.dup person1[0] = "J"

	puts "person1 is #{person1}" puts "person2 is #{person2}"

	produces:

	person1 is Jim

	person2 is Tim 我们也可以冻结一个对象来避免对它作出修改

	person1 = "Tim"


	person2 = person1


	person1.freeze # prevent modifications to the object person2[0] = "J"


	produces:

	        from prog.rb:4:in `&lt;main&gt;'

	prog.rb:4:in `[]=': can't modify frozen String (RuntimeError)
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-23T20:11:08+08:00" data-updated="true" itemprop="datePublished">Jul 23<span>rd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/23/ruby-new/" itemprop="url">Ruby-new</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4 id="ruby">Ruby中一切皆对象</h4>
<p>创建对象，假设有一个Song的类，按如下方式创建实例</p>

<pre><code>song1 = Song.new("Ruby Tuesday")

song2 = Song.new("Enveloped in Python")
</code></pre>

<p>如何理解一切皆对象，看以下demo	</p>

<pre><code>puts "gin joint".length 
puts "Rick".index("c") 
puts 42.even?			//42是否是偶数

puts sam.play(song)
</code></pre>

<p>在java中，如果要算一个值的绝对值，可按如下方式</p>

<pre><code>num = Math.abs(num) 但在Ruby中，由于一切皆对象，可按如下方式

um = -1234 			# =&gt; -1234 
positive = num.abs	# =&gt; 1234 同样的规则适用于所有的Ruby对象，在C中，你可以写strlen(name)，但在ruby中，你可以写name.length,无比轻松
</code></pre>

<h5 id="ruby-1">Ruby中的方法</h5>
<p>形式如下</p>

<pre><code>def say_goodnight(name)

	result = "Good night, " + name

	return result

end


# Time for bed...

puts say_goodnight("John-Boy") 

puts say_goodnight("Mary-Ellen")
</code></pre>

<p>无需分号表示每个语句的结尾，只要你把每一条语句都放在一单独的行上</p>

<pre><code>puts say_goodnight("Mary-Ellen") 相当于

puts(say_goodnight("Mary-Ellen")) #####字符串 创建字符串有两种方法，一种是单引号括起来的，一种是双引号括起来的,双引号括起来的字符串，ruby需要做更多的工作，首先，ruby会寻找以反斜杠开头的序列，并将它替换为一个二进制的值,如"\n",另外，双引号形式的字符串还需要做的将#{expression}序列替换成expression的值,我们能用它来替换之前我们写的程序

def say_goodnight(name)

	result = "Good night, #{name}" 

	return result

end

puts say_goodnight('Pa') 

produces:
Good night, Pa 任意的复杂的表达式都能放在#{...}里，如下

def say_goodnight(name)

	result = "Good night, #{name.capitalize}" 

	return result

end

puts say_goodnight('uncle') 

produces:

Good night, Uncle
</code></pre>

<p>我们还能对以上方法进行简化，ruby方法返回的值是最一个表达式对应的值，所以我们可以不必写临时变量和return语句</p>

<pre><code>def say_goodnight(name)

	"Good night, #{name.capitalize}"

end

puts say_goodnight('ma') 

produces:

Good night, Ma
</code></pre>

<h4 id="ruby-2">Ruby的名字</h4>
<p>ruby的命名遵循以下惯例,第一个名字的首字符表示这个名字的使用场合</p>

<ul>
  <li>局部变量，方法参数，方法名都 以一个小写字母或下划线开头</li>
  <li>全局变量以一个$符开头，对象实例变量以@开头</li>
  <li>类变量以两个@@开头</li>
  <li>
    <p>类名，模块名，常量必须以大写字母开头
使用的demo如下</p>

    <pre><code>  Local Variable:		name fish_and_chips x_axis thx1138 _x _26
  Instance Variable:	@name @point_1 @X @_ @plan9
  Class Variable:		@@total @@symtab @@N @@x_pos @@SINGLE
  Global Variable:   $debug $CUSTOMER $_ $plan9 $Global
  Class Name:			String ActiveRecord MyClass
  Constant Name:		FEET_PER_MILE DEBUG ####数组和哈希字典 数组

  a = [ 1, 'cat', 3.14 ] # array with three elements 
  puts "The first element is #{a[0]}"

  # set the third element

  a[2] = nil

  puts "The array is now #{a.inspect}"

  produces:

  The first element is 1

  The array is now [1, "cat", nil] 简便地创建数组的方法

  a = %w{ ant bee cat dog elk } 
  a[0] # =&gt; "ant"

  a[3] # =&gt; "dog"
</code></pre>
  </li>
</ul>

<p>哈希字典</p>

<pre><code>	inst_section = {

	'cello' =&gt; 'string', 

	'clarinet' =&gt; 'woodwind', 

	'drum' =&gt; 'percussion', 

	'oboe' =&gt; 'woodwind', 

	'trumpet' =&gt; 'brass', 

	'violin' =&gt; 'string'
}
</code></pre>

<p><code>=&gt;</code>符号的左为key，右为value
在控制台上我们用p而不是puts，因为p可以更显式地打印nil值</p>

<pre><code>	p inst_section['oboe']

	p inst_section['cello']

	p inst_section['bassoon']
</code></pre>

<p>produces:</p>

<pre><code>    "woodwind"

    "string"

    nil 默认情况下hash的key如果对应的value不存在，则value的值为nil，我们可以改变这个默认傎


histogram = Hash.new(0)
histogram['ruby'] # =&gt; 0

histogram['ruby'] = histogram['ruby'] + 1 

histogram['ruby'] # =&gt; 1 ####符号(Symbols) 通常在编程的时候，你需要为某些重要的东西指定一个名字，比如，你也许想要用名字来指示指南针的方向，所以，你可以像以下这么写

NORTH = 1 
EAST =2 
SOUTH = 3 
WEST =4
</code></pre>

<p>定义好之后，你就可以用这些名字而不是数字了</p>

<pre><code>walk(NORTH)

look(EAST) 然而，很多时候，这些名字对应的数值是不相关的(只要它们是唯一的)你所要做的只是区分这四个方向而已 Ruby提供了一个很简单的替代方案:符号(Symbols).Symbols只是常量名字，不过你无需定义它，并且它们也保证是唯一的，一个符号常量以:开头，紧跟着字符串 walk(:north) look(:east) 无须为一个symbol赋任何值,Ruby已经为你考虑好了.Ruby保证不管符号出现在你，一个特定和符号总量有相同的值，因此，你可以按如下方式使用symbol

def walk(direction)

	if direction == :north

	# ...

	end
 end symbols通常被用来当作hash的key，我们可以将我们之前写的hash写为以下形式

inst_section = {

	:cello =&gt; 'string', 

	:clarinet =&gt; 'woodwind', 

	:drum =&gt; 'percussion', 

	:oboe =&gt; 'woodwind', 

	:trumpet =&gt; 'brass', 

	:violin =&gt; 'string'

}
</code></pre>

<p>事实上，symbols是如此频繁地被当作hash的键，ruby提供了一个更简洁的语法，你可以用name:value的形式来创建hash，如果key是symbols的话</p>

<pre><code>inst_section = {

	cello: 'string', 

	clarinet: 'woodwind', 

	drum: 'percussion', 

	oboe: 'woodwind', 

	trumpet: 'brass', 

	violin: 'string'

}

puts "An oboe is a #{inst_section[:oboe]} instrument"

produces:

An oboe is a woodwind instrument ####条件语句 if语句 

today = Time.now

if today.saturday?

	puts "Do chores around the house"

elsif today.sunday?

	 puts "Relax"

else

	 puts "Go to work" 
end
</code></pre>

<p>produces:</p>

<pre><code>Go to work 较短的if语句也可以这么写

puts "Danger, Will Robinson" if radiation &gt; 3000 while语句

while weight &lt; 100 and num_pallets &lt;= 5

         pallet  = next_pallet()

         weight += pallet.weight

         num_pallets += 1

end 较短的while语句也可以这么写

	square = 4

	square = square*square while square &lt; 1000
</code></pre>

<p>ruby中的许多语句返回一个值，这意味着你可以用它们作为条件判断，比如,内核方法gets从标准输入流中返回下一行或者当到达文件的末尾时会返回nil，由于Ruby有条件语句中将nil视为假的，你可以用以下代码来处理文件对应的行</p>

<pre><code>while line = gets 
	puts line.downcase

end
</code></pre>

<h4 id="section">正则表达式</h4>

<pre><code>/\d\d:\d\d:\d\d/	# a time such as 12:34:56

/Perl.*Python/		# Perl, zero or more other chars, then Python

/Perl Python/		# Perl, a space, and Python

/Perl *Python/     # Perl, zero or more spaces, and Python

/Perl +Python/	   # Perl, one or more spaces, and Python

/Perl\s+Python/   # Perl, whitespace characters, then Python

/Ruby (Perl|Python)/ # Ruby, a space, and either Perl or Python
</code></pre>

<p>结果if语句使用</p>

<pre><code>line = gets

if line =~ /Perl|Python/

	puts "Scripting language mentioned: #{line}" 
end
</code></pre>

<p>正则表达式的替代方法</p>

<pre><code>line = gets

newline = line.sub(/Perl/, 'Ruby') # replace first 'Perl' with 'Ruby' 	newerline = 	newline.gsub(/Python/, 'Ruby') # replace every 'Python' with 'Ruby' ####Blocks和迭代器 我们首先看看代码块(code blocks),code blocks是一串代码，你能将它与方法调用结合起来,就当它们是参数一样,这是难以置信的强大特性 你用代码块来实现回调(但比java中的匿名内部类简单),把它们像C中的函数指针那样来传递(比C函数指针更简单)，或者实现迭代器的功能 代码块的形式如下

{ puts "Hello" } 或

do

  club.enroll(person)

  person.socialize

end "{}"block主要用在单行中,"do....end"主要用在多行中 你可以将block放在一个调用方法的尾部

greet { puts "Hi" }	//greet是方法 如果方法有参数，则将block放在这些参数的最后

verbose_greet("Dave", "loyal customer") { puts "Hi" } 方法可以用Ruby提供的yield来调用block多次

def call_block


	puts "Start of method" 

	yield

	yield

	puts "End of method"

end


call_block { puts "In the block" }
</code></pre>

<p>打印结果</p>

<pre><code>	Start of method

	In the block

	In the block

	End of method
</code></pre>

<table>
  <tbody>
    <tr>
      <td>调用yield的时候可以带参数,这些参数将被传到block中去，在block中，你将这些被接收的参数用</td>
      <td>params…</td>
      <td>的形式列出来,如下</td>
    </tr>
  </tbody>
</table>

<pre><code>def who_says_what yield("Dave", "hello") 
	yield("Andy", "goodbye")


end

who_says_what {|person, phrase| puts "#{person} says #{phrase}"} 打印结果

Dave says hello
Andy says goodbye Code blocks广泛用在ruby的库中用来实现迭代器


animals = %w( ant bee cat dog ) # create an array

animals.each {|animal| puts animal } 	# iterate over the contents
</code></pre>

<p>produces:</p>

<pre><code>ant

bee

cat

dog
</code></pre>

<p>再来看几个例子</p>

<pre><code>[ 'cat', 'dog', 'horse' ].each {|name| print name, " " } 

5.times { print "*" }

3.upto(6) {|i| print i }

('a'..'e').each {|char| print char }

puts
</code></pre>

<p>produces:</p>

<pre><code>cat dog horse *****3456abcde ####读写

printf("Number: %5.2f,\nString: %s\n", 1.23, "hello")
</code></pre>

<p>produces:</p>

<pre><code>Number:  1.23,
String: hello 有很多方法可以将输入读入程序中，最常见的gets方法，它返回标准输入流的下一行

line = gets
print line
</code></pre>

<h4 id="section-1">命令行参数</h4>
<p>当你从命令行运行一个Ruby程序时，你能传送一些参数给它，你能用两种不同的参数来访问这些参数
首先，ARGV就是这些参数组成的数组，假设有一个叫cmd_line.rb的程序如下</p>

<pre><code>puts "You gave #{ARGV.size} arguments" 
p ARGV 当我们向此程序传入这些参数时，我们参看到输出结果

$ ruby cmd_line.rb ant bee cat dog 
You gave 4 arguments

["ant", "bee", "cat", "dog"] 通常，传入的参数是你要处理的文件的名字，这种情况下，你应该用第二种技巧,`ARGF`,它是一种特别的I/O对象，代表了通过命令行传入的文件名的所有内容, 我们之后再学习它
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-21T22:23:15+08:00" data-updated="true" itemprop="datePublished">Jul 21<span>st</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ruby/'>Ruby</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/21/chu-shi-ruby/" itemprop="url">初识Ruby</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>在终端中输入irb与ruby交互</p>

<pre><code>	2.1.2 :002 &gt; def sum(n1, n2)
	2.1.2 :003?&gt;   n1+n2
	2.1.2 :004?&gt;   end
	 =&gt; :sum
	2.1.2 :005 &gt; sum(3, 4)
	 =&gt; 7 通常我们将ruby程序写在文件里，假设现在有一个myprog.rb的程序如下

	gettingstarted/myprog.rb
	puts "Hello, Ruby Programmer" 
	puts "It is now #{Time.now}" 现在我们可以敲入以下命令来运行程序

	$ ruby myprog.rb
	Hello, Ruby Programmer)
	It is noew 2014-07-21 22:27:47 +0800 在Unix中，我们可以在程序的第一行添加"shebang"的符号，如下

	#! /usr/bin/ruby
	puts "Hello, Ruby Programmer" 
	puts "It is now #{Time.now}" 如果你用`chmod+x myprog.rb`命令让此文件成为可执行程序，Unix能让你将此文件作为一个程序来运行

	$ ./myprog.rb
	Hello, Ruby Programmer
	It is now 2013-05-27 12:30:36 -0500 ####Ruby文档:RDoc和ri
</code></pre>

<p>Ruby库越来越大，已经不可能将有关它们的文档写进一本书中了，ruby的标准库有9000多个！幸运的是，一种为这些方法(类，模块)提供文档的方法是存在的，许多在它们内部写文档的方法是采用一个RDoc的工具</p>

<p>如果一个源文件用RDoc来文档注释，那么它的文档是可以被提取出来并被转化成HTML和ri的形式的</p>

<p>ri是一个浏览本地RDoc的，命令行浏览器，许多ruby的发行版现在用ri程序来安装文档资源</p>

<p>要发现针对某个类的文档，我们可以在命令行敲入<code>ri ClassName</code>的形式来查看,如以下</p>

<pre><code>$ ri GC
----------------------------------------------------------------------------------- 
The GC module provides an interface to Ruby's garbage collection mechanism. Some of the underlying 	methods are also available via the ObjectSpace module.
   
You may obtain information about the operation of the GC through GC::Profiler.
-----------------------------------------------------------------------------------
Class methods:
  count, disable, enable, malloc_allocated_size, malloc_allocations,
  start, stat, stress, stress=
Instance methods:
  garbage_collect
</code></pre>

<p>查看某个指定类的方法</p>

<pre><code>ri GC::enable
--------------------------------------------------------------- GC::enable GC.enable =&gt; true or false 	--------------------------------------------------------------------------- Enables garbage collection, returning true if garbage collection was 	disabled.
GC.disable
GC.enable
GC.enable
#=&gt; false
#=&gt; true
#=&gt; false
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-16T21:54:55+08:00" data-updated="true" itemprop="datePublished">Jul 16<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/07/16/head-first-cdi-ba-zhang-jing-tai-ku-he-dong-tai-ku/" itemprop="url">Head First C第八章-静态库和动态库</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>这一章中，我们将学习如何创建自己的动态库，并在多个程序中用到同样的代码
来看下以下代码
加密代码</p>

<pre><code>//encyrpt.h
void encrypt(char *message)

//encrypt.c
#include "encrypt.h"
void encrypt(char *message) {
	while (*message) { 
		*message = *message ^ 31; message++;
	}
 } 校验代码

//checksum.h
int checksum(char *message);

//checksum.c
#include "checksum.h"
int checksum(char *message) {
	int c = 0;
	while (*message) {
	c += c ^ (int)(*message);
	message++; }
	return c; 
} 加密和校验两段代码构成了我们接下来将要进行的密码库的基础 假设我们已经将以上的代码编译成了目标代码

gcc -c encrypt.c -o encrypt.o
gcc -c checksum.c -o checksum.o 现在我们写一段测试程序

#include &lt;stdio.h&gt; 
#include &lt;encrypt.h&gt; 
#include &lt;checksum.h&gt;
int main() {
	char s[] = "Speak friend and enter"; encrypt(s);
	printf("Encrypted to '%s'\n", s); printf("Checksum is %i\n", checksum(s)); encrypt(s);
	printf("Decrypted back to '%s'\n", s); printf("Checksum is %i\n", checksum(s));
	return 0;
} 当我们编译时，会出现以下错误

gcc test_code.c encrypt.o checksum.o -o test_code 
test_code.c:2:21: error: encrypt.h: No such file or directory 
test_code.c:3:22: error: checksum.h: No such file or directory
</code></pre>

<p>错误在以下两行</p>

<pre><code>#include &lt;encrypt.h&gt; 
#include &lt;checksum.h&gt; 尖括号将在标准头文件目录中寻找，在Mac或Linux系统中，编译器在以下目录中寻找这些文件

/user/local/include		//此目录下通常存放一些第三方库
/user/include			//此目录通常存放一些操作系统相关的头文件 ####该如何共享代码 有时你想写一些代码用在很多程序中，无论它们是在不同的文件夹下，还是在整个电脑中，你该如何做呢? 一般来说我们想在多个程序中共享两种文件,头文件(.h)和目标文件(.o),让我们看看如何操作
</code></pre>

<h5 id="h">共享.h头文件,有以下几种文件</h5>

<ol>
  <li>
    <p>将它们存储在标准目录中
如果你将你的头文件拷贝到标准目标如/usr/local/include中，你可以用尖括号来引用它们</p>

    <pre><code> #include&lt;encrypt.h&gt;
</code></pre>
  </li>
  <li>
    <p>在include中写下此文件所在的完整路径
假设你的文件存储在/my_header_files目录下,你可以按以下方式来引用代码</p>

    <pre><code> #include "/my_header_files/encrypt.h"
</code></pre>
  </li>
  <li>
    <p>你可以告诉编译器去哪来搜寻它们
用gcc编译时加上-I选项</p>

    <pre><code> gcc -I /my_header_files test_code.c ... -o test_code -I选项告诉gcc编译器在/my_header_files这个目录下你能找到所需要的头文件，`注意`，gcc仍将在标准目录中寻找头文件，但是`首先`它将在-I选项对应的目录中寻找此文件 #####通过写完整路径的方式来共享.o目标文件

 gcc -I/my_header_files test_code.c /my_object_files/encrypt.o /my_object_files/checksum.o -o test_code /my_object_files目录就像是存储目标文件的中枢,用目标文件的完整路径意味着你不需要为每一个程序拷贝一份单独的目标文件 如果只有一两个需要共享的目标文件还好，如果有许多目标文件呢，不是要在所有的目标文件前都加上它们的完整路径了? `解决方法`:你可以将许多目标文件打包成一个.a文件,这样你一次就能告诉编译器所有目标文件的所在了(都在.a文件里) ######让我们看下如何打包 我们用过.zip和.tar文件，这些文件包含了多个文件,.a文件与此类似，一个文件包含了多个.o文件 打开命令行，切换到库目录下，比如/usr/lib里。在此目录上，你将看到许多.a文件,有一个nm的命令可以用来查看.a文件里有哪些.o文件 &lt;img src="/images/2014/7/libl.png"&gt; &lt;img src="/images/2014/7/nm.png"&gt; 在我们用.a文件编译程序之前,先看看如何将encrypt.o和checksum.o文件存储到一个.a文件里吧 用ar命令来创建一个.a文件

 ar -rcs libhfsecurity.a encrypt.o checksum.o rcs三个选项的解释如下 -r表示如果(.a)文件已经存在,文件将被更新 -c表示.a创建成功与否都无任何反馈信息 -s告诉ar在文件的开头创建一个索引 注意到了吗，所有的.a文件都有lib&lt;something&gt;.a形式的命名,名字以lib开头，因为它们是静态库，我们将很快学习到什么是静态库
</code></pre>
  </li>
</ol>

<p>创建好了标准库文件后，该如何使用呢</p>

<ul>
  <li>
    <p>将它放到一个标准目录如/user/local/lib里
一些码农在确认.a文件能工作后喜欢将.a文件放在一标准库里，在Linux和Mac里/usr/local/lib目录是一个很好的选择，因为这个目录就是专门用来放置你自己的库文件的</p>
  </li>
  <li>
    <p>将.a文件放到你自己喜欢放置的库文件目录下,如/my_lib中
既然库创建好了，那我们来看看怎么利用这些库来编译用到这些库的程序</p>
    <ol>
      <li>如果你将.a文件放到标准库目录中,你可以按以下方式来编译代码
<img src="/images/2014/7/nm.png" />	</li>
      <li>
        <p>如果你是将.a文件放在你自己的库文件目录下，可按以下方式来编译代码</p>

        <p>gcc test_code.c -L/my_lib -lhfsecurity -o test_code
-L选项告诉编译器去哪个目录寻找库文件</p>
      </li>
    </ol>
  </li>
</ul>

<p>现在有一个搞安全的哥们在用最新的加密库编译一个银行相关的程序时遇到了一点麻烦，他把源码和 ecnrypt，checksum 的源码放在了同一个目录下，他想要在同一个目录下创建一个libhfsecurity.a库并用它去编译程序，你能帮助它修改它的makefile文件吗
这个程序叫band_vault，它用了以下的include语句 </p>

<pre><code>#include&lt;encrypt.h&gt;
#include&lt;checksum.h&gt; 由于用到了尖括号，编译器需要使用用-I选项告知头文件在哪 makefile文件如下 &lt;img src="/images/2014/7/bank_vault_makefile.png"&gt;	 -L选项必须出现在源文件后面才行 从.a文件中提取中某个目标文件

ar -x libhfsecurity.a encrypt.o 再来看一个例子

//hfcal.c
#include &lt;stdio.h&gt; 
#include &lt;hfcal.h&gt;

void display_calories(float weight, float distance, float coeff) {
	printf("Weight: %3.2f lbs\n", weight);
	printf("Distance: %3.2f miles\n", distance);
	printf("Calories burned: %4.2f cal\n", coeff * weight * distance);
}

//elliptical.c
#include &lt;stdio.h&gt;
#include &lt;hfcal.h&gt;
int main() {
	display_calories(115.2, 11.3, 0.79);
	return 0; 
} 下面我们来看看如何编译代码
</code></pre>

<ol>
  <li>
    <p>首先，创建hfcal.o文件,hfcal.h头文件存储在./includes</p>

    <pre><code> gcc -I./includes -c hfcal.c -o hfcal.o -c选项表示只是创建目标文件，不链接
</code></pre>
  </li>
  <li>
    <p>创建elliptical.o文件</p>

    <pre><code> gcc -I./includes -c elliptical.c -o elliptical.o 同样的，你需要告诉编译器头文件在./includes下的
</code></pre>
  </li>
  <li>
    <p>你需要从hfcal.o中创建一个.a文件，并将它存储在./libs中</p>

    <pre><code> ar -rcs ./libs/libhfcal.a hfcal.o
</code></pre>
  </li>
</ol>

<p>被打包的libhfcal.a文件将被放在./libs目录下</p>

<ol>
  <li>
    <p>最后，用elliptical.o和libhfcal.a创建elliptical可执行文件</p>

    <pre><code> gcc elliptical.o -L./libs -lhfcal -o elliptical
</code></pre>
  </li>
</ol>

<p>现在你能执行elliptical可执行文件了</p>

<pre><code>&gt; ./elliptical
Weight: 115.20 lbs 
Distance: 11.30 miles 
Calories burned: 1028.39 cal 
&gt;
</code></pre>


		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/blog/page/2/" class="prev">Prev</a>
    
    
        <a href="/blog/page/4/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    AllenToFight


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	<script src="/javascripts/slash.js"></script>
	

<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>
