
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Swift - AllenToFight Blog</title>
	<meta name="author" content="AllenToFight">

	
	<meta name="description" content="Swift å˜é‡å®šä¹‰ å¸¸é‡ç”¨let,å˜é‡ç”¨var 1
2
3
4
var myVariable = 42
myVariable = 50
let myConstant = 42
let explicitDouble: Double = 70 å˜é‡çš„å€¼ä¸ä¼šè‡ªåŠ¨è½¬åŒ–ä¸ºå…¶ä»–ç±»å‹çš„ 1
2
3
let &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="AllenToFight Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://xiekunRonaldo.github.io/blog/2014/08/12/swift/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<img src="http://www.gravatar.com/avatar/27a0140c11f18fab9bf284743d2b2b4c?s=160" alt="Profile Picture" style="width: 160px;" />
	
</div>
<hgroup>
  <h1><a href="/">AllenToFight Blog</a></h1>
  
    <h2>Life To Code.</h2>
  
</hgroup>

<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="weibo" href="http://www.weibo.com/1876496750" title="Weibo">Facebook</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">Swift</h1>
	<div class="entry-content" itemprop="articleBody"><h4>å˜é‡å®šä¹‰</h4>

<p>å¸¸é‡ç”¨let,å˜é‡ç”¨var</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var myVariable = 42
</span><span class='line'>myVariable = 50
</span><span class='line'>let myConstant = 42
</span><span class='line'>let explicitDouble: Double = 70
</span></code></pre></td></tr></table></div></figure>


<p>å˜é‡çš„å€¼ä¸ä¼šè‡ªåŠ¨è½¬åŒ–ä¸ºå…¶ä»–ç±»å‹çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let label = "The width is "
</span><span class='line'>let width = 94
</span><span class='line'>let widthLabel = label+String(width)</span></code></pre></td></tr></table></div></figure>


<p>Stringå†…çš„å€¼æ›¿æ¢</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let apples = 3
</span><span class='line'>let oranges = 5
</span><span class='line'>let appleSummary = "I have \(apples) apples.â€</span></code></pre></td></tr></table></div></figure>


<p>æ•°ç»„å’Œå­—å…¸</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var shoppingList = ["catfish", "water", "tulips", "blue paint"]
</span><span class='line'>
</span><span class='line'>shoppingList[1] = "bottle of water"
</span><span class='line'> 
</span><span class='line'>var occupations = [
</span><span class='line'>
</span><span class='line'>    "Malcolm": "Captain",
</span><span class='line'>
</span><span class='line'>    "Kaylee": "Mechanic",
</span><span class='line'>]
</span><span class='line'>occupations["Jayne"] = "Public Relationsâ€
</span><span class='line'>
</span><span class='line'>let emptyArray = String[]()
</span><span class='line'>let emptyDictionary = Dictionary&lt;String, Float&gt;()
</span></code></pre></td></tr></table></div></figure>


<p>å¦‚æœç±»å‹æ˜¯èƒ½æ¨æ–­çš„ï¼Œå¯ä»¥ç”¨[]åˆ›å»ºä¸€ä¸ªç©ºæ•°ç»„ï¼Œç”¨[:]åˆ›å»ºä¸€ä¸ªç©ºå­—å…¸</p>

<h4>æ¡ä»¶è¯­å¥</h4>

<p>if&hellip;else&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let individualScores = [75, 43, 103, 87, 12]
</span><span class='line'>var teamScore = 0
</span><span class='line'>for score in individualScores {
</span><span class='line'>    if score &gt; 50 {
</span><span class='line'>        teamScore += 3
</span><span class='line'>    } else {
</span><span class='line'>        teamScore += 1
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>teamScore</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„ï¼Œåœ¨ifæ¡ä»¶è¯­å¥ä¸­ï¼Œconditionå¿…é¡»æ˜¯boolè¡¨è¾¾å¼ï¼Œæ‰€ä»¥ç±»ä¼¼<code>if score {...}</code>è¿™æ ·çš„ä»£ç æ˜¯é”™è¯¯çš„
ifå’Œoptional valueç»„æˆçš„æ¡ä»¶è¡¨è¾¾å¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var optionalString: String? = "Hello"
</span><span class='line'>optionalString == nil
</span><span class='line'> 
</span><span class='line'>var optionalName: String? = "John Appleseed"
</span><span class='line'>var greeting = "Hello!"
</span><span class='line'>if let name = optionalName {
</span><span class='line'>    greeting = "Hello, \(name)"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>switchå’Œcaseè¯­å¥æ”¯æŒå¤šç§ç±»å‹çš„æ¯”è¾ƒ,ä¸é™äºinteger</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vegetable = "red pepper"
</span><span class='line'>switch vegetable {
</span><span class='line'>case "celery":
</span><span class='line'>    let vegetableComment = "Add some raisins and make ants on a log."
</span><span class='line'>case "cucumber", "watercress":
</span><span class='line'>    let vegetableComment = "That would make a good tea sandwich."
</span><span class='line'>case let x where x.hasSuffix("pepper"):
</span><span class='line'>    let vegetableComment = "Is it a spicy \(x)?"
</span><span class='line'>default:
</span><span class='line'>    let vegetableComment = "Everything tastes good in soup."
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„:æ‰§è¡Œå®Œcaseè¯­å¥ï¼Œç¨‹åºå°±ä»switchè¯­å¥é‡Œç»ˆæ­¢äº†ï¼Œæ‰€ä»¥æ— éœ€break!</p>

<p>éå†dictionary</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let interestingNumbers = [
</span><span class='line'>    "Prime": [2, 3, 5, 7, 11, 13],
</span><span class='line'>    "Fibonacci": [1, 1, 2, 3, 5, 8],
</span><span class='line'>    "Square": [1, 4, 9, 16, 25],
</span><span class='line'>]
</span><span class='line'>var largest = 0
</span><span class='line'>for (kind, numbers) in interestingNumbers {
</span><span class='line'>    for number in numbers {
</span><span class='line'>        if number &gt; largest {
</span><span class='line'>            largest = number
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>largest</span></code></pre></td></tr></table></div></figure>


<p>whileè¯­å¥</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var n = 2
</span><span class='line'>while n &lt; 100 {
</span><span class='line'>    n = n * 2
</span><span class='line'>}
</span><span class='line'>n
</span><span class='line'> 
</span><span class='line'>var m = 2
</span><span class='line'>do {
</span><span class='line'>    m = m * 2
</span><span class='line'>} while m &lt; 100
</span><span class='line'>m</span></code></pre></td></tr></table></div></figure>


<p><code>..</code>çš„å¦™ç”¨,ä»¥ä¸‹ä¸¤ä¸ªå¾ªç¯æ˜¯ç­‰ä»·çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var firstForLoop = 0
</span><span class='line'>for i in 0..3 {
</span><span class='line'>    firstForLoop += i
</span><span class='line'>}
</span><span class='line'>firstForLoop
</span><span class='line'> 
</span><span class='line'>var secondForLoop = 0
</span><span class='line'>for var i = 0; i &lt; 3; ++i {
</span><span class='line'>    secondForLoop += 1
</span><span class='line'>}
</span><span class='line'>secondForLoop</span></code></pre></td></tr></table></div></figure>


<h4>å‡½æ•°å’Œé—­åŒ…</h4>

<p>å‡½æ•°çš„å£°æ˜
ç”¨->å°†å‚æ•°ä¸è¿”å›å€¼åŒºåˆ†å¼€æ¥</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func greet(name: String, day: String) -&gt; String {
</span><span class='line'>    return "Hello \(name), today is \(day)."
</span><span class='line'>}
</span><span class='line'>greet("Bob", "Tuesday")</span></code></pre></td></tr></table></div></figure>


<p>ç”¨tupleä»å‡½æ•°ä¸­è¿”å›å¤šä¸ªå€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func getGasPrices() -&gt; (Double, Double, Double) {
</span><span class='line'>    return (3.59, 3.69, 3.79)
</span><span class='line'>}
</span><span class='line'>getGasPrices()</span></code></pre></td></tr></table></div></figure>


<p>å‡½æ•°ä¹Ÿèƒ½æ¥æ”¶ä¸å®šæ•°é‡çš„å‚æ•°ï¼Œå°†å®ƒä»¬å°æˆåˆ°ä¸€ä¸ªæ•°ç»„é‡Œ</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sumOf(numbers: Int...) -&gt; Int {
</span><span class='line'>    var sum = 0
</span><span class='line'>    for number in numbers {
</span><span class='line'>        sum += number
</span><span class='line'>    }
</span><span class='line'>    return sum
</span><span class='line'>}
</span><span class='line'>sumOf()
</span><span class='line'>sumOf(42, 597, 12)</span></code></pre></td></tr></table></div></figure>


<p>å‡½æ•°ä¹Ÿèƒ½åµŒå¥—ï¼Œå†…åµŒçš„å‡½æ•°èƒ½è®¿é—®å£°æ˜åœ¨å¤–éƒ¨å‡½æ•°çš„å˜é‡</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func returnFifteen() -&gt; Int {
</span><span class='line'>    var y = 10
</span><span class='line'>    func add() {
</span><span class='line'>        y += 5
</span><span class='line'>    }
</span><span class='line'>    add()
</span><span class='line'>    return y
</span><span class='line'>}
</span><span class='line'>returnFifteen()</span></code></pre></td></tr></table></div></figure>


<p>å‡½æ•°æ˜¯first-classç±»å‹ï¼Œè¿™æ„å‘³ç€å‡½æ•°ä¹Ÿèƒ½è¿”å›å¦ä¸€ä¸ªå‡½æ•°</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func makeIncrementer() -&gt; (Int -&gt; Int) {
</span><span class='line'>    func addOne(number: Int) -&gt; Int {
</span><span class='line'>        return 1 + number
</span><span class='line'>    }
</span><span class='line'>    return addOne
</span><span class='line'>}
</span><span class='line'>var increment = makeIncrementer()
</span><span class='line'>increment(7)</span></code></pre></td></tr></table></div></figure>


<p>å‡½æ•°çš„å‚æ•°ä¹Ÿèƒ½æ˜¯å‡½æ•°</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool {
</span><span class='line'>    for item in list {
</span><span class='line'>        if condition(item) {
</span><span class='line'>            return true
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>}
</span><span class='line'>func lessThanTen(number: Int) -&gt; Bool {
</span><span class='line'>    return number &lt; 10
</span><span class='line'>}
</span><span class='line'>var numbers = [20, 19, 7, 12]
</span><span class='line'>hasAnyMatches(numbers, lessThanTen)</span></code></pre></td></tr></table></div></figure>


<p>å‡½æ•°å®é™…ä¸Šæ˜¯é—­åŒ…çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨{}æ¥å†™ä¸€ä¸ªåŒ¿åçš„é—­åŒ…,ç”¨inæ¥å°†å‚æ•°å’Œè¿”å›ç±»å‹åŒºåˆ†å¼€æ¥</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numbers.map({
</span><span class='line'>    (number: Int) -&gt; Int in
</span><span class='line'>    let result = 3 * number
</span><span class='line'>    return result
</span><span class='line'>    })</span></code></pre></td></tr></table></div></figure>


<p>å¦‚æœä¸€ä¸ªclosureçš„ç±»å‹æ˜¯å·²çŸ¥çš„ï¼Œæ¯”å¦‚å·²çŸ¥ä¸€ä¸ªdelegateçš„å›è°ƒï¼Œæˆ‘ä»¬å¯ä»¥çœç•¥å‚æ•°çš„ç±»å‹ï¼Œè¿”å›ç±»å‹æˆ–ä¸¤è€…éƒ½çœç•¥,ä»¥ä¸Šå¯ä»¥æ”¹å†™æˆä»¥ä¸‹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numbers.map({ number in 3 * number })</span></code></pre></td></tr></table></div></figure>


<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨æ•°å­—è€Œä¸æ˜¯åå­—æ¥è¡¨ç¤ºå‚æ•°</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sort([1, 5, 3, 12, 2]) { $0 &gt; $1 }</span></code></pre></td></tr></table></div></figure>


<h4>å¯¹è±¡å’Œç±»</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Shape {
</span><span class='line'>    var numberOfSides = 0
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        return "A shape with \(numberOfSides) sides."
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var shape = Shape()
</span><span class='line'>shape.numberOfSides = 7
</span><span class='line'>var shapeDescription = shape.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p><code>init</code>çš„ä½¿ç”¨</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class NamedShape {
</span><span class='line'>    var numberOfSides: Int = 0
</span><span class='line'>    var name: String
</span><span class='line'>    
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        return "A shape with \(numberOfSides) sides."
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>æ¯ä¸€ä¸ªpropertyéƒ½éœ€è¦èµ‹å€¼ï¼Œå¯ä»¥åœ¨å®ƒå£°æ˜çš„æ—¶å€™(å¦‚numberOfSlides)ä¹Ÿå¯ä»¥åœ¨initializeré‡Œ(å¦‚name)
å®šä¹‰deinitæ¥åˆ›å»ºä¸€ä¸ªdeinitializerå¦‚æœä½ éœ€è¦åœ¨å¯¹è±¡è¢«é‡Šæ”¾å‰åšä¸€äº›æ¸…ç†å·¥ä½œçš„è¯
ç»§æ‰¿æ—¶ï¼Œå¦‚æœè¦é‡å†™superclassçš„æ–¹æ³•ï¼Œå¿…é¡»è¦åœ¨é‡å†™çš„æ–¹æ³•å‰åŠ override</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Square: NamedShape {
</span><span class='line'>    var sideLength: Double
</span><span class='line'>    
</span><span class='line'>    init(sideLength: Double, name: String) {
</span><span class='line'>        self.sideLength = sideLength
</span><span class='line'>        super.init(name: name)
</span><span class='line'>        numberOfSides = 4
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    func area() -&gt;  Double {
</span><span class='line'>        return sideLength * sideLength
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    override func simpleDescription() -&gt; String {
</span><span class='line'>        return "A square with sides of length \(sideLength)."
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let test = Square(sideLength: 5.2, name: "my test square")
</span><span class='line'>test.area()
</span><span class='line'>test.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p>ä¸ºpropertyå®šä¹‰getterå’Œsetter</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class EquilateralTriangle: NamedShape {
</span><span class='line'>    var sideLength: Double = 0.0
</span><span class='line'>    
</span><span class='line'>    init(sideLength: Double, name: String) {
</span><span class='line'>        self.sideLength = sideLength
</span><span class='line'>        super.init(name: name)
</span><span class='line'>        numberOfSides = 3
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    var perimeter: Double {
</span><span class='line'>    get {
</span><span class='line'>        return 3.0 * sideLength
</span><span class='line'>    }
</span><span class='line'>    set {
</span><span class='line'>        sideLength = newValue / 3.0
</span><span class='line'>    }
</span><span class='line'> }
</span><span class='line'> 
</span><span class='line'> override func simpleDescription() -&gt; String {
</span><span class='line'>          return "An equilateral triagle with sides of length \(sideLength)."
</span><span class='line'>      }
</span><span class='line'> }
</span><span class='line'>var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
</span><span class='line'>triangle.perimeter
</span><span class='line'>triangle.perimeter = 9.9
</span><span class='line'>triangle.sideLength</span></code></pre></td></tr></table></div></figure>


<p>åœ¨perimeterçš„setteræ–¹æ³•ä¸­ï¼Œæ–°å€¼æœ‰ä¸€ä¸ªé»˜è®¤çš„åå­—newValue,æˆ‘ä»¬å¯ä»¥åœ¨setåçš„æ‹¬å·é‡Œä¸ºè¿™ä¸ªå€¼æŒ‡å®šä¸€ä¸ªåå­—
å¦‚æœä½ æ— éœ€è®¡ç®—propertyçš„å€¼ï¼Œä½†éœ€è¦åœ¨è®¾ç½®æ–°å€¼çš„å‰ååšä¸€äº›æ“ä½œï¼Œå¯ä»¥ç”¨<code>willSet</code>å’Œ<code>didSet</code>,æ¯”å¦‚</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class TriangleAndSquare {
</span><span class='line'>    var triangle: EquilateralTriangle {
</span><span class='line'>      willSet {
</span><span class='line'>          square.sideLength = newValue.sideLength
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    var square: Square {
</span><span class='line'>      willSet {
</span><span class='line'>          triangle.sideLength = newValue.sideLength
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    init(size: Double, name: String) {
</span><span class='line'>        square = Square(sideLength: size, name: name)
</span><span class='line'>        triangle = EquilateralTriangle(sideLength: size, name: name)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
</span><span class='line'>triangleAndSquare.square.sideLength
</span><span class='line'>triangleAndSquare.triangle.sideLength
</span><span class='line'>triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
</span><span class='line'>triangleAndSquare.triangle.sideLength</span></code></pre></td></tr></table></div></figure>


<p>ç±»æ–¹æ³•ä¸å‡½æ•°æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„åŒºåˆ«ï¼Œç±»æ–¹æ³•é‡Œå¯ä»¥ä¸ºå‚æ•°æŒ‡å®šä¸€ä¸ªåˆ«å,è€Œå‡½æ•°ä¸è¡Œï¼Œå¦‚ä¸‹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Counter {
</span><span class='line'>    var count: Int = 0
</span><span class='line'>    func incrementBy(amount: Int, numberOfTimes times: Int) {
</span><span class='line'>        count += amount * times
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var counter = Counter()
</span><span class='line'>counter.incrementBy(2, numberOfTimes: 7)</span></code></pre></td></tr></table></div></figure>


<p>å½“ä¸optional valueså·¥ä½œæ—¶ï¼Œä½ å¯ä»¥åœ¨æœ‰å…³æ–¹æ³•ï¼Œå±æ€§å’Œ[]æ“ä½œå‰å†™ä¸€ä¸ª<code>?</code>å¦‚æœåœ¨?å‰çš„å€¼ä¸ºnil,åˆ™ä¸€åˆ‡åœ¨ï¼Ÿåçš„æ“ä½œéƒ½è¢«å¿½ç•¥äº†ï¼Œæ•´ä¸ªè¡¨è¾¾å¼çš„å€¼ä¹Ÿå°±æ˜¯niläº†ï¼Œå¦åˆ™optional value unwrapped,æ‰€æœ‰?åè¡¨è¾¾å¼å¯¹åº”çš„å€¼ä¸ºoptional value,æ— è®ºå¦‚ä½•ï¼Œæ•´ä¸ªè¡¨è¾¾å¼çš„å€¼éƒ½æ˜¯optional value</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
</span><span class='line'>let sideLength = optionalSquare?.sideLength</span></code></pre></td></tr></table></div></figure>


<h4>Enumerations and Structures</h4>

<p>åƒç±»å’Œå…¶ä»–ç±»å‹ä¸€æ ·,enumerationså¯ä»¥æœ‰æ–¹æ³•</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Rank: Int {
</span><span class='line'>    case Ace = 1  //ä¹Ÿå¯ä»¥ç”¨å­—ç¬¦ä¸²æˆ–ç¬¦ç‚¹å‹æ¥æŒ‡å®šæšä¸¾çš„ç±»å‹
</span><span class='line'>    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
</span><span class='line'>    case Jack, Queen, King
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        switch self {
</span><span class='line'>        case .Ace:
</span><span class='line'>            return "ace"
</span><span class='line'>        case .Jack:
</span><span class='line'>            return "jack"
</span><span class='line'>        case .Queen:
</span><span class='line'>            return "queen"
</span><span class='line'>        case .King:
</span><span class='line'>            return "king"
</span><span class='line'>        default:
</span><span class='line'>            return String(self.toRaw())
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let ace = Rank.Ace
</span><span class='line'>let aceRawValue = ace.toRaw() //1</span></code></pre></td></tr></table></div></figure>


<p>ç”¨<code>toRaw</code>å’Œ<code>fromRaw</code>å‡½æ•°æ¥å¯¹raw valueå’Œæšä¸¾å€¼è¿›è¡Œç›¸äº’è½¬æ¢</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let convertedRank = Rank.fromRaw(3) {
</span><span class='line'>    let threeDescription = convertedRank.simpleDescription()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The member values of an enumeration are actual values, not just another way of writing their raw values.å¦‚æœæ²¡æœ‰ä¸€ä¸ªæœ‰æ„ä¹‰çš„raw valueï¼Œä½ ä¸éœ€è¦å†æŒ‡å®šå®ƒ</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Suit {
</span><span class='line'>    case Spades, Hearts, Diamonds, Clubs
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        switch self {
</span><span class='line'>        case .Spades:
</span><span class='line'>            return "spades"
</span><span class='line'>        case .Hearts:
</span><span class='line'>            return "hearts"
</span><span class='line'>        case .Diamonds:
</span><span class='line'>            return "diamonds"
</span><span class='line'>        case .Clubs:
</span><span class='line'>            return "clubs"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let hearts = Suit.Hearts
</span><span class='line'>let heartsDescription = hearts.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p>ç”¨structæ¥åˆ›å»ºä¸€ä¸ªç»“æ„,structæ”¯æŒç±»çš„å¾ˆå¤šæ–¹é¢ï¼Œå¦‚æ–¹æ³•å’Œåˆå§‹åŒ–ï¼Œå’Œç±»çš„æœ€å¤§åŒºåˆ«æ˜¯structuresæ€»é‡ä»¥copyçš„å½¢å¼ä¼ é€’ï¼Œè€Œclassåˆ™ä»¥å¼•ç”¨çš„å½¢å¼ä¼ é€’</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Card {
</span><span class='line'>    var rank: Rank
</span><span class='line'>    var suit: Suit
</span><span class='line'>    func simpleDescription() -&gt; String {
</span><span class='line'>        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let threeOfSpades = Card(rank: .Three, suit: .Spades)
</span><span class='line'>let threeOfSpadesDescription = threeOfSpades.simpleDescription()</span></code></pre></td></tr></table></div></figure>


<p>Instances of the same enumeration member can have different values associated with them.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum ServerResponse {
</span><span class='line'>    case Result(String, String)
</span><span class='line'>    case Error(String)
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>let success = ServerResponse.Result("6:00 am", "8:09 pm")
</span><span class='line'>let failure = ServerResponse.Error("Out of cheese.")
</span><span class='line'> 
</span><span class='line'>switch success {
</span><span class='line'>case let .Result(sunrise, sunset):
</span><span class='line'>    let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)."
</span><span class='line'>case let .Error(error):
</span><span class='line'>    let serverResponse = "Failure...  \(error)"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„sunriseå’Œsunsetå¦‚ä½•åŒ¹é…switchä¸­caseçš„æ¡ä»¶è€Œä»ServerResponseé‡Œå€¼å–å‡ºæ¥çš„</p>

<h4>åè®®å’ŒExtensions</h4>

<p>ç”¨<code>protocol</code>æ¥å£°æ˜ä¸€ä¸ªåè®®</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol ExampleProtocol {
</span><span class='line'>    var simpleDescription: String { get }
</span><span class='line'>    mutating func adjust()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>class SimpleClass: ExampleProtocol {
</span><span class='line'>    var simpleDescription: String = "A very simple class."
</span><span class='line'>    var anotherProperty: Int = 69105
</span><span class='line'>    func adjust() {
</span><span class='line'>        simpleDescription += "  Now 100% adjusted."
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var a = SimpleClass()
</span><span class='line'>a.adjust()
</span><span class='line'>let aDescription = a.simpleDescription
</span><span class='line'> 
</span><span class='line'>struct SimpleStructure: ExampleProtocol {
</span><span class='line'>    var simpleDescription: String = "A simple structure"
</span><span class='line'>    mutating func adjust() {
</span><span class='line'>        simpleDescription += " (adjusted)"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var b = SimpleStructure()
</span><span class='line'>b.adjust()
</span><span class='line'>let bDescription = b.simpleDescription</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„åœ¨structä¸­mutatingçš„ä½¿ç”¨,classä¸­çš„æ–¹æ³•æ— éœ€æ ‡è®°ä¸ºmutating,å› ä¸ºç±»ä¸­çš„æ–¹æ³•æ€»æ˜¯å¯ä»¥æ”¹å˜ç±»çš„
ç”¨extensionsæ¥ä¸ºä¸€ä¸ªå·²çŸ¥çš„ç±»å‹æ·»åŠ åŠŸèƒ½ï¼Œæ¯”å¦‚æ–°çš„æ–¹æ³•å’Œcomputed properties</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Int: ExampleProtocol {
</span><span class='line'>    var simpleDescription: String {
</span><span class='line'>    return "The number \(self)"
</span><span class='line'>    }
</span><span class='line'>    mutating func adjust() {
</span><span class='line'>        self += 42
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>7.simpleDescription</span></code></pre></td></tr></table></div></figure>


<p>You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let protocolValue: ExampleProtocol = a
</span><span class='line'>protocolValue.simpleDescription
</span><span class='line'>// protocolValue.anotherProperty  // Uncomment to see the errorâ€</span></code></pre></td></tr></table></div></figure>


<p>å°½ç®¡protocolValueæœ‰ä¸€ä¸ªè¿è¡Œæ—¶çš„ç±»å‹SimpleClass,ä½†ç¼–è¯‘å™¨ä»æŠŠå®ƒå½“ä½œExampleProtocolçš„ä¸€ç§ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è¯´è¯´äº†å®šä¹‰æ—¶åè®®å¯¹åº”çš„æ–¹æ³•ï¼Œä½ ä¸èƒ½è°ƒç”¨å®ƒå®é™…æ‰€å±ç±»çš„æ–¹æ³•ï¼Œå±æ€§</p>

<h4>Generics</h4>

<p>åœ¨å°–æ‹¬å·é‡Œå†™ä¸€ä¸ªåå­—æ¥åˆ›å»ºä¸€ä¸ªgenericå‡½æ•°æˆ–ç±»å‹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; ItemType[] {
</span><span class='line'>    var result = ItemType[]()
</span><span class='line'>    for i in 0..times {
</span><span class='line'>        result += item
</span><span class='line'>    }
</span><span class='line'>    return result
</span><span class='line'>}
</span><span class='line'>repeat("knock", 4)</span></code></pre></td></tr></table></div></figure>


<p>æˆ‘ä»¬æ—¢å¯ä»¥å°†è¿™ç§å½¢å¼ç”¨åœ¨å‡½æ•°å’Œæ–¹æ³•ä¸Šï¼Œä¹Ÿå¯ä»¥ç”¨åœ¨ç±»ï¼Œæšä¸¾ï¼Œç»“æ„ä½“çš„å®šä¹‰ä¸Š</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Reimplement the Swift standard library's optional type
</span><span class='line'>enum OptionalValue&lt;T&gt; {
</span><span class='line'>    case None
</span><span class='line'>    case Some(T)
</span><span class='line'>}
</span><span class='line'>var possibleInteger: OptionalValue&lt;Int&gt; = .None
</span><span class='line'>possibleInteger = .Some(100)</span></code></pre></td></tr></table></div></figure>


<p>åœ¨ç±»å‹åååŠ ä¸€ä¸ªwhereæ¥æŒ‡å®šä¸€äº›å¿…é¡»æ¡ä»¶</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Bool {
</span><span class='line'>    for lhsItem in lhs {
</span><span class='line'>        for rhsItem in rhs {
</span><span class='line'>            if lhsItem == rhsItem {
</span><span class='line'>                return true
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>}
</span><span class='line'>anyCommonElements([1, 2, 3], [3])</span></code></pre></td></tr></table></div></figure>


<p>ç»ƒä¹ 
Modify the anyCommonElements function to make a function that returns an array of the elements that any two sequences have in common.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element:     Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Array&lt;T.GeneratorType.Element&gt; {
</span><span class='line'>    var toReturn = Array&lt;T.GeneratorType.Element&gt;()
</span><span class='line'>    for lhsItem in lhs {
</span><span class='line'>        for rhsItem in rhs {
</span><span class='line'>            if lhsItem == rhsItem {
</span><span class='line'>                toReturn.append(lhsItem)
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return toReturn
</span><span class='line'>}
</span><span class='line'>anyCommonElements([1, 2, 3], [3])</span></code></pre></td></tr></table></div></figure>


<p>åœ¨ä¸€äº›ç®€å•çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥çœç•¥whereï¼Œåªåœ¨åˆ†å·åå†™ä¸€ä¸ªprotocolæˆ–æ˜¯ç±»åï¼Œ&lt;T: Equatable>å’Œ<T where T: Equatable>æ˜¯ä¸€æ ·çš„
Swiftæ˜¯ç±»å‹å®‰å…¨çš„è¯­è¨€,å¦‚æœä½ çš„ä»£ç å¸Œæœ›çš„æ˜¯Stringç±»å‹ï¼Œç±»å‹å®‰å…¨å°†é˜»æ­¢ä½ èµ‹Intå€¼ç»™å®ƒ</p>

<h4>å¸¸é‡å’Œå˜é‡çš„å‘½å</h4>

<p>æˆ‘ä»¬å‡ ä¹å¯ä»¥ç”¨ä»»ä½•å­—ç¬¦æ¥å‘½åå¸¸é‡å’Œå˜é‡ï¼ŒåŒ…æ‹¬Unicodeå­—ç¬¦</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let Ï€ = 3.14159
</span><span class='line'>let ä½ å¥½ = "ä½ å¥½ä¸–ç•Œ"
</span><span class='line'>let ğŸ¶ğŸ® = "dogcowâ€</span></code></pre></td></tr></table></div></figure>


<p>ä¸€æ—¦ä½ å£°æ˜äº†æŸç§ç±»å‹çš„å¸¸é‡å’Œå˜é‡ï¼Œä½ å°±ä¸èƒ½ä¸ºå®ƒèµ‹äºˆå…¶ä»–ç±»å‹çš„å˜é‡</p>

<h4>æ‰“å°</h4>

<p>æ‰“å°å˜é‡</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println(friendlyWelcome)</span></code></pre></td></tr></table></div></figure>


<p>æ‰“å°ä¸­åŒ…å«å­—ç¬¦æ›¿æ¢</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The current value of friendlyWelcome is \(friendlyWelcome)")</span></code></pre></td></tr></table></div></figure>


<h4>æ³¨é‡Š</h4>

<p>ä¸åƒCè¯­è¨€ä¸­çš„å¤šè¡Œæ³¨é‡Šï¼ŒSwiftçš„å¤šè¡Œæ³¨é‡Šæ˜¯å¯ä»¥åµŒå¥—çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* this is the start of the first multiline comment
</span><span class='line'>/* this is the second, nested multiline comment */
</span><span class='line'>this is the end of the first multiline comment */</span></code></pre></td></tr></table></div></figure>


<h4>åˆ†å·çš„ä½¿ç”¨</h4>

<p>å¦‚æœä¸€è¡Œä¸­åŒ…å«å¤šæ¡è¯­å¥ï¼Œå°±å¾—ç”¨åˆ†å·</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let cat = "ğŸ±"; println(cat)
</span><span class='line'>// prints "ğŸ±â€</span></code></pre></td></tr></table></div></figure>


<h4>æ•´å‹</h4>

<ul>
<li>æ•´å‹èŒƒå›´</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
</span><span class='line'>let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8â€</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Intå‹å’ŒUInt
åœ¨32ä½OSä¸Šï¼Œ(U)Intå’Œ(U)Int32çš„å¤§å°ä¸€æ ·
åœ¨64ä½OSä¸Šï¼Œ(U)Intå’Œ(U)Int64çš„å¤§å°ä¸€æ ·
åªæœ‰åœ¨ä½ ç¡®å®éœ€è¦å’ŒOSæœ¬èº«çš„å­—å¤§å°ä¸€æ ·çš„éæ•´å½¢ç±»å‹æ—¶æ‰ç”¨UIntï¼Œå¦åˆ™å°½é‡ç”¨Int

<h4>æµ®ç‚¹å‹</h4></li>
<li>Doubleä»£è¡¨äº†64ä½çš„æµ®ç‚¹æ•°ï¼Œæœ‰è‡³å°‘15ä½å°æ•°çš„ç²¾åº¦</li>
<li>Floatä»£è¡¨äº†32ä½ï¼Œåªæœ‰6ä½å°æ•°çš„ç²¾åº¦

<h4>Numeric Literals</h4>

<p>æ•´å‹å­—é¢é‡å¯ä»¥å†™æˆä»¥ä¸‹å½¢å¼</p></li>
<li>10è¿›åˆ¶ï¼Œæ— å‰ç¼€</li>
<li>äºŒè¿›åº¦ï¼Œ0bå‰ç¼€</li>
<li>å…«è¿›åˆ¶ï¼Œ0oå‰ç¼€</li>
<li>åå…­è¿›åˆ¶ï¼Œ0xå‰ç¼€</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let decimalInteger = 17
</span><span class='line'>let binaryInteger = 0b10001       // 17 in binary notation
</span><span class='line'>let octalInteger = 0o21           // 17 in octal notation
</span><span class='line'>let hexadecimalInteger = 0x11     // 17 in hexadecimal notationâ€</span></code></pre></td></tr></table></div></figure>


<p>æµ®ç‚¹å‹å¯ä»¥æ˜¯ååˆ¶çš„(æ— å‰ç¼€),ä¹Ÿå¯ä»¥æ˜¯åå…­è¿›åˆ¶çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.25e2 means 1.25 Ã— 102, or 125.0.
</span><span class='line'>1.25e-2 means 1.25 Ã— 10-2, or 0.0125.
</span><span class='line'>0xFp2 means 15 Ã— 2*2, or 60.0.
</span><span class='line'>0xFp-2 means 15 Ã— (2çš„-2æ¬¡æ–¹), or 3.75.</span></code></pre></td></tr></table></div></figure>


<h4>æ•´å‹è½¬æ¢</h4>

<p>æº¢å‡ºä¼šæŠ¥é”™</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let cannotBeNegative: UInt8 = -1
</span><span class='line'>// UInt8 cannot store negative numbers, and so this will report an error
</span><span class='line'>let tooBig: Int8 = Int8.max + 1
</span><span class='line'>// Int8 cannot store a number larger than its maximum value,
</span><span class='line'>// and so this will also report an error</span></code></pre></td></tr></table></div></figure>


<p>æ¥çœ‹ä»¥ä¸‹ä¾‹å­</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let twoThousand: UInt16 = 2_000
</span><span class='line'>let one: UInt8 = 1
</span><span class='line'>let twoThousandAndOne = twoThousand + UInt16(one)</span></code></pre></td></tr></table></div></figure>


<p>ä»¥ä¸Šçš„UInt16æ˜¯å¿…é¡»çš„,å› ä¸ºä¸¤ä¸ªå˜é‡çš„ç±»å‹ä¸åŒ</p>

<h4>æ•´å½¢å’Œæµ®ç‚¹å‹çš„è½¬æ¢</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let three = 3
</span><span class='line'>let pointOneFourOneFiveNine = 0.14159
</span><span class='line'>let pi = Double(three) + pointOneFourOneFiveNine</span></code></pre></td></tr></table></div></figure>


<p>æµ®ç‚¹å‹è½¬ä¸ºæ•´å‹ï¼Œåªä¿ç•™æ•´æ•°,ä¸ä¼šå‡ºç°å››èˆäº”å…¥è¿™ç§æƒ…å†µ</p>

<h4>Type Aliases</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typealias AudioSample = UInt16
</span><span class='line'>var maxAmplitudeFound = AudioSample.min</span></code></pre></td></tr></table></div></figure>


<h4>Boolå‹</h4>

<p>Swiftçš„ç±»å‹å®‰å…¨é˜»æ­¢äº†ä»»ä½•éboolå‹çš„å€¼è‡ªåŠ¨æ›¿æ¢æˆBoolå‹çš„å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let i = 1
</span><span class='line'>if i {
</span><span class='line'>    // this example will not compile, and will report an error
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ä¸è¿‡ï¼Œä»¥ä¸‹ä½¿ç”¨æ–¹å¼å´æ˜¯å¯¹çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let i = 1
</span><span class='line'>if i == 1 {
</span><span class='line'>    // this example will compile successfully
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Tuples</h4>

<p>tupleå°†å¤šä¸ªå€¼ç»„åˆä¸€ä¸ªå¤åˆçš„å€¼ï¼Œå¹¶ä¸”è¿™äº›å€¼å¯ä»¥æ˜¯ä¸åŒç±»å‹çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let http404Error = (404, "Not Found")
</span><span class='line'>
</span><span class='line'>let (statusCode, statusMessage) = http404Error
</span><span class='line'>println("The status code is \(statusCode)")
</span><span class='line'>// prints "The status code is 404"
</span><span class='line'>println("The status message is \(statusMessage)")
</span><span class='line'>// prints "The status message is Not Found</span></code></pre></td></tr></table></div></figure>


<p>å¦‚æœä½ åªéœ€è¦ä¸€éƒ¨åˆ†tupleçš„å€¼ ï¼Œä½ å¯ä»¥ç”¨_æ¥å¿½ç•¥ä½ ä¸éœ€è¦çš„å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let (justTheStatusCode, _) = http404Error
</span><span class='line'>println("The status code is \(justTheStatusCode)")
</span><span class='line'>// prints "The status code is 404</span></code></pre></td></tr></table></div></figure>


<p>ä¹Ÿå¯ä»¥ç”¨ä»¥ä¸‹æ–¹å¼æ¥è·å–tupleé‡Œçš„å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The status code is \(http404Error.0)")
</span><span class='line'>// prints "The status code is 404"
</span><span class='line'>println("The status message is \(http404Error.1)")
</span><span class='line'>// prints "The status message is Not Found</span></code></pre></td></tr></table></div></figure>


<p>åœ¨å®šä¹‰tupleçš„æ—¶å€™å¯ä»¥ä¸ºæ¯ä¸ªelementèµ‹å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let http200Status = (statusCode: 200, description: "OK")
</span><span class='line'>println("The status code is \(http200Status.statusCode)")
</span><span class='line'>// prints "The status code is 200"
</span><span class='line'>println("The status message is \(http200Status.description)")
</span><span class='line'>// prints "The status message is OK"</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„:Tuplesä»…ä»…é€‚ç”¨äºä¸´æ—¶çš„ä¸€ç»„ç›¸å…³çš„æ•°æ®,å®ƒå¹¶ä¸é€‚ç”¨äºå¤æ‚æ•°æ®ç±»å‹çš„åˆ›å»º</p>

<h4>Optionals</h4>

<p>Swiftâ€™s optionals let you indicate the absence of a value for any type at all, without the need for special constants.</p>

<h4>Forced Unwrapping</h4>

<p>å½“æˆ‘ä»¬ç¡®å®šoptional<code>ç¡®å®š</code>å«æœ‰ä¸€ä¸ªå€¼æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™ä¸ªoptionalçš„åå­—åé¢åŠ ä¸€ä¸ª!æ¥è·å–å®ƒçš„å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if convertedNumber {
</span><span class='line'>    println("\(possibleNumber) has an integer value of \(convertedNumber!)")
</span><span class='line'>} else {
</span><span class='line'>    println("\(possibleNumber) could not be converted to an integer")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Optional Binding</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let constantName = someOptional {
</span><span class='line'>    statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>æˆ‘ä»¬å¯ä»¥æŒ‰å¦‚ä¸‹æ–¹å¼é‡å†™ä¹‹å‰çš„<code>possibleNumber</code>çš„ä¾‹å­</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let actualNumber = possibleNumber.toInt() {
</span><span class='line'>    println("\(possibleNumber) has an integer value of \(actualNumber)")
</span><span class='line'>} else {
</span><span class='line'>    println("\(possibleNumber) could not be converted to an integer")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ä½ å¯ä»¥èµ‹äºˆä¸€ä¸ªoptional å€¼ä¸ºnil,éoptionalçš„åˆ™ä¸è¡Œ</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var serverResponseCode: Int? = 404
</span><span class='line'>// serverResponseCode contains an actual Int value of 404
</span><span class='line'>serverResponseCode = nil</span></code></pre></td></tr></table></div></figure>


<p>å¦‚æœåœ¨å®šä¹‰ä¸€ä¸ªoptional valueæ—¶ä¸æä¾›ä¸€ä¸ªé»˜è®¤å€¼ï¼Œåˆ™å®ƒä¸ºnil</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var surveyAnswer: String?
</span><span class='line'>// surveyAnswer is automatically set to nilâ€</span></code></pre></td></tr></table></div></figure>


<p>éœ€è¦æ³¨æ„çš„æ˜¯swiftçš„nilä¸ocä¸­çš„nilä¸åŒ,ocä¸­çš„nilæ˜¯ä¸€ä¸ªæŒ‡å®šä¸å­˜åœ¨çš„å¯¹è±¡çš„æŒ‡é’ˆï¼Œè€Œswiftä¸­çš„nilåˆ™ä¸æ˜¯æŒ‡é’ˆï¼Œå®ƒåªæ˜¯è¡¨ç¤ºæŸç§ç±»å‹çš„å€¼ä¸å­˜åœ¨ï¼Œä»»ä½•ç±»å‹çš„optionaléƒ½èƒ½è®¾ç½®ä¸ºnilï¼Œè€Œä¸ä»…ä»…æ˜¯å¯¹è±¡</p>

<h4>Implicitly Unwrapped Optional</h4>

<p>ä¹Ÿå°±æ˜¯ç±»å‹ååŠ !,ä»”ç»†çœ‹ä»¥ä¸‹çš„åŒºåˆ«</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let possibleString: String? = "An optional string."
</span><span class='line'>println(possibleString!) // requires an exclamation mark to access its value
</span><span class='line'>// prints "An optional string."
</span><span class='line'> 
</span><span class='line'>let assumedString: String! = "An implicitly unwrapped optional string."
</span><span class='line'>println(assumedString)  // no exclamation mark is needed to access its value
</span><span class='line'>// prints "An implicitly unwrapped optional string.
</span><span class='line'>
</span><span class='line'>if assumedString {
</span><span class='line'>    println(assumedString)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>æ–­è¨€</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let age = -3
</span><span class='line'>assert(age &gt;= 0, "A person's age cannot be less than zero")
</span><span class='line'>// this causes the assertion to trigger, because age is not &gt;= 0</span></code></pre></td></tr></table></div></figure>


<p>ä¹Ÿå¯ä»¥ä¸å†™string</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>assert(age &gt;= 0)</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„asserté‡Œçš„stringä¸æ”¯æŒ<code>\()</code>å½¢å¼çš„æ›¿æ¢</p>

<h4>åŸºæœ¬æ“ä½œ</h4>

<p>Swiftå…è®¸ä½ å¯¹æµ®ç‚¹å€¼è¿›è¡Œ%çš„è¿ç®—
èµ‹å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let b = 10
</span><span class='line'>var a = 5
</span><span class='line'>a = b</span></code></pre></td></tr></table></div></figure>


<p>ä¸è¿‡ä¸åƒCï¼Œèµ‹å€¼æœ¬èº«ä¸è¿”å›å€¼ï¼Œæ‰€ä»¥ä»¥ä¸‹æ˜¯éæ³•çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if x = y {
</span><span class='line'>    // this is not valid, because x = y does not return a value
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ä¸åƒCï¼ŒSwifté»˜è®¤æƒ…å†µä¸‹ä¸å…è®¸è¿›è¡Œç®—æœ¯è¿ç®—æ—¶çš„å€¼æº¢å‡º
ä¸¤ä¸ªCharacterçš„å€¼ï¼Œæˆ–è€…ä¸€ä¸ªCharacterå’Œä¸€ä¸ªStringçš„å€¼ï¼Œèƒ½ç›¸åŠ ç»„æˆä¸€ä¸ªæ–°çš„Stringçš„å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let dog: Character = "ğŸ¶"
</span><span class='line'>let cow: Character = "ğŸ®"
</span><span class='line'>let dogCow = dog + cow
</span><span class='line'>// dogCow is equal to "ğŸ¶ğŸ®â€</span></code></pre></td></tr></table></div></figure>


<h4>æ±‚ä½™è¿ç®—ç¬¦%</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-9 % 4   // equals -1</span></code></pre></td></tr></table></div></figure>


<p>é™¤æ•°çš„ç¬¦å·æ˜¯è¢«å¿½ç•¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´a % bå’Œa % -bçš„å€¼æ˜¯ä¸€æ ·çš„
æµ®ç‚¹æ•°çš„æ±‚ä½™æ“ä½œ</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>8 % 2.5   // equals 0.5</span></code></pre></td></tr></table></div></figure>


<h4>æ¯”è¾ƒæ“ä½œç¬¦</h4>

<p><code>===</code>å¯ä»¥ç”¨æ¥æµ‹è¯•ä¸¤ä¸ªå¯¹è±¡çš„å¼•ç”¨æ˜¯å¦æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let name = "world"
</span><span class='line'>if name == "world" {
</span><span class='line'>    println("hello, world")
</span><span class='line'>} else {
</span><span class='line'>    println("I'm sorry \(name), but I don't recognize you")
</span><span class='line'>}
</span><span class='line'>// prints "hello, world", because name is indeed equal to "world"</span></code></pre></td></tr></table></div></figure>


<h4>Rangeæ“ä½œ</h4>

<p>é—­åŒºé—´</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for index in 1...5 {
</span><span class='line'>    println("\(index) times 5 is \(index * 5)")
</span><span class='line'>}
</span><span class='line'>// 1 times 5 is 5
</span><span class='line'>// 2 times 5 is 10
</span><span class='line'>// 3 times 5 is 15
</span><span class='line'>// 4 times 5 is 20
</span><span class='line'>// 5 times 5 is 25â€</span></code></pre></td></tr></table></div></figure>


<p>å¼€åŒºé—´</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Anna", "Alex", "Brian", "Jack"]
</span><span class='line'>let count = names.count
</span><span class='line'>for i in 0..count {
</span><span class='line'>    println("Person \(i + 1) is called \(names[i])")
</span><span class='line'>}
</span><span class='line'>// Person 1 is called Anna
</span><span class='line'>// Person 2 is called Alex
</span><span class='line'>// Person 3 is called Brian
</span><span class='line'>// Person 4 is called Jack</span></code></pre></td></tr></table></div></figure>


<h4>å­—ç¬¦ä¸²å’Œå­—ç¬¦</h4>

<p>Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.
æ³¨æ„OCä¸­çš„stringç›¸å…³çš„APIï¼ŒSwiftéƒ½çš„Stringéƒ½èƒ½ä½¿ç”¨</p>

<h5>String Literals</h5>

<ul>
<li>è½¬ä¹‰å­—ç¬¦\0(ç©ºå­—ç¬¦),\(è¿”æ–œæ†),\t,\n,\r,\&ldquo;,`</li>
<li>å•å­—èŠ‚çš„Unicode scalars,\xnn,nnæ˜¯ä¸¤ä½åå…­è¿›åˆ¶çš„æ•°å­—</li>
<li>ä¸¤ä¸ªå­—èŠ‚çš„Unicode scalars,\unnnn,nnnnæ˜¯ä¸€ä¸ªå››ä½åå…­è¿›åˆ¶çš„æ•°å­—</li>
<li>å››ä¸ªå­—èŠ‚çš„Unicode scalars,\Unnnnnnnn,nnnnnnnnæ˜¯å…«ä½çš„åå…­è¿›åˆ¶çš„æ•°å­—</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"
</span><span class='line'>// "Imagination is more important than knowledge" - Einstein
</span><span class='line'>let dollarSign = "\x24"        // $,  Unicode scalar U+0024
</span><span class='line'>let blackHeart = "\u2665"      // â™¥,  Unicode scalar U+2665
</span><span class='line'>let sparklingHeart = "\U0001F496"  // ğŸ’–, Unicode scalar U+1F496â€</span></code></pre></td></tr></table></div></figure>


<h4>åˆå§‹åŒ–ä¸€ä¸ªç©ºå­—ç¬¦ä¸²</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var emptyString = ""               // empty string literal
</span><span class='line'>var anotherEmptyString = String()  // initializer syntax
</span><span class='line'>// these two strings are both empty, and are equivalent to each other</span></code></pre></td></tr></table></div></figure>


<p>åˆ¤æ–­ä¸€ä¸ªStringçš„å€¼æ˜¯å¦æ˜¯ç©ºçš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if emptyString.isEmpty {
</span><span class='line'>    println("Nothing to see here")
</span><span class='line'>}
</span><span class='line'>// prints "Nothing to see here</span></code></pre></td></tr></table></div></figure>


<p>ä½ å¯ä»¥åœ¨å®šä¹‰ä¸€ä¸ªå­—ç¬¦ä¸²æ—¶ç”¨varå’Œletæ¥è¡¨ç¤ºå­—ç¬¦ä¸²æ˜¯å¦å¯å˜</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var variableString = "Horse"
</span><span class='line'>variableString += " and carriage"
</span><span class='line'>// variableString is now "Horse and carriage"
</span><span class='line'> 
</span><span class='line'>let constantString = "Highlander"
</span><span class='line'>constantString += " and another Highlander"
</span><span class='line'>// this reports a compile-time error - a constant string cannot be modified</span></code></pre></td></tr></table></div></figure>


<h4>Stringsæ˜¯å€¼ç±»å‹</h4>

<p>ä¹Ÿå°±æ˜¯è¯´å¦‚æœstringçš„å€¼è¢«ä¼ å…¥å‡½æ•°æˆ–æ–¹æ³•ï¼Œæˆ–è¢«èµ‹å€¼æ—¶ï¼Œå®ƒæ˜¯è¢«copyçš„ï¼å¹•åï¼ŒSwiftçš„ç¼–è¯‘å™¨ä¼˜åŒ–äº†stringçš„ä½¿ç”¨ï¼Œæ‰€ä»¥copyåªæœ‰åœ¨çœŸæ­£éœ€è¦çš„æ—¶å€™æ‰å‘ç”Ÿ,è¿™æ„å‘³ç€ä½ æ— éœ€æ‹…å¿ƒæ€§èƒ½æ€»é‡</p>

<h5>éå†stringä¸­çš„å­—ç¬¦</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for character in "Dog!ğŸ¶" {
</span><span class='line'>    println(character)
</span><span class='line'>}
</span><span class='line'>// D
</span><span class='line'>// o
</span><span class='line'>// g
</span><span class='line'>// !
</span><span class='line'>// ğŸ¶â€</span></code></pre></td></tr></table></div></figure>


<p>åˆ›å»ºä¸€ä¸ªcharacter</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let yenSign: Character = "Â¥"</span></code></pre></td></tr></table></div></figure>


<h4>è®¡ç®—Charactersçš„ä¸ªæ•°</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let unusualMenagerie = "Koala ğŸ¨, Snail ğŸŒ, Penguin ğŸ§, Dromedary ğŸª"
</span><span class='line'>println("unusualMenagerie has \(countElements(unusualMenagerie)) characters")
</span><span class='line'>// prints "unusualMenagerie has 40 charactersâ€</span></code></pre></td></tr></table></div></figure>


<p>ä¸åŒçš„Unicodeå­—ç¬¦æˆ–åŒä¸€Unicodeå­—ç¬¦çš„ä¸åŒè¡¨ç¤ºå½¢å¼åœ¨å†…å­˜ä¸­å çš„ç©ºé—´ä¸ä¸€æ ·ï¼ŒåŸºäºæ­¤ï¼Œswiftä¸­çš„å­—ç¬¦å¹¶ä¸å ç”¨åŒæ ·çš„å†…å­˜ï¼Œæ‰€ä»¥è¦è®¡ç®—ä¸€ä¸ªstringçš„é•¿åº¦ï¼Œæˆ‘ä»¬å¿…é¡»é€ä¸ªéå†å­—ç¬¦</p>

<p><code>Note</code> also that the character count returned by countElements is not always the same as the length property of an NSString that contains the same characters. The length of an NSString is based on the number of 16-bit code units within the stringâ€™s UTF-16 representation and not the number of Unicode characters within the string. To reflect this fact, the length property from NSString is called utf16count when it is accessed on a Swift String value.</p>

<h4>è¿æ¥å­—ç¬¦ä¸²å’Œå­—ç¬¦</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let string1 = "hello"
</span><span class='line'>let string2 = " there"
</span><span class='line'>let character1: Character = "!"
</span><span class='line'>let character2: Character = "?"
</span><span class='line'> 
</span><span class='line'>let stringPlusCharacter = string1 + character1        // equals "hello!"
</span><span class='line'>let stringPlusString = string1 + string2              // equals "hello there"
</span><span class='line'>let characterPlusString = character1 + string1        // equals "!hello"
</span><span class='line'>let characterPlusCharacter = character1 + character2  // equals "!?â€</span></code></pre></td></tr></table></div></figure>


<h4>æ¯”è¾ƒå­—ç¬¦ä¸²</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let quotation = "We're a lot alike, you and I."
</span><span class='line'>let sameQuotation = "We're a lot alike, you and I."
</span><span class='line'>if quotation == sameQuotation {
</span><span class='line'>    println("These two strings are considered equal")
</span><span class='line'>}
</span><span class='line'>// prints "These two strings are considered equal</span></code></pre></td></tr></table></div></figure>


<h5>å‰ç¼€å’Œåç¼€çš„æ¯”è¾ƒ</h5>

<p>hasPrefixå’ŒhasSuffix
å‰ç¼€</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let romeoAndJuliet = [
</span><span class='line'>    "Act 1 Scene 1: Verona, A public place",
</span><span class='line'>    "Act 1 Scene 2: Capulet's mansion",
</span><span class='line'>    "Act 1 Scene 3: A room in Capulet's mansion",
</span><span class='line'>    "Act 1 Scene 4: A street outside Capulet's mansion",
</span><span class='line'>    "Act 1 Scene 5: The Great Hall in Capulet's mansion",
</span><span class='line'>    "Act 2 Scene 1: Outside Capulet's mansion",
</span><span class='line'>    "Act 2 Scene 2: Capulet's orchard",
</span><span class='line'>    "Act 2 Scene 3: Outside Friar Lawrence's cell",
</span><span class='line'>    "Act 2 Scene 4: A street in Verona",
</span><span class='line'>    "Act 2 Scene 5: Capulet's mansion",
</span><span class='line'>    "Act 2 Scene 6: Friar Lawrence's cell"
</span><span class='line'>]
</span><span class='line'>
</span><span class='line'>var act1SceneCount = 0
</span><span class='line'>for scene in romeoAndJuliet {
</span><span class='line'>    if scene.hasPrefix("Act 1 ") {
</span><span class='line'>        ++act1SceneCount
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println("There are \(act1SceneCount) scenes in Act 1")
</span><span class='line'>// prints "There are 5 scenes in Act 1</span></code></pre></td></tr></table></div></figure>


<p>åç¼€</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var mansionCount = 0
</span><span class='line'>var cellCount = 0
</span><span class='line'>for scene in romeoAndJuliet {
</span><span class='line'>    if scene.hasSuffix("Capulet's mansion") {
</span><span class='line'>        ++mansionCount
</span><span class='line'>    } else if scene.hasSuffix("Friar Lawrence's cell") {
</span><span class='line'>        ++cellCount
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
</span><span class='line'>// prints "6 mansion scenes; 2 cell scenesâ€</span></code></pre></td></tr></table></div></figure>


<h5>å¤§å°å†™è½¬æ¢</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let normal = "Could you help me, please?""
</span><span class='line'>let shouty = normal.uppercaseString
</span><span class='line'>// shouty is equal to "COULD YOU HELP ME, PLEASE?"
</span><span class='line'>let whispered = normal.lowercaseString
</span><span class='line'>// whispered is equal to "could you help me, please?â€</span></code></pre></td></tr></table></div></figure>


<h4>Unicode p118</h4>

<h4>Collection ç±»å‹</h4>

<h5>Array</h5>

<p>ä¸åŒäºOCä¸­çš„array(å¯å­˜å‚¨ä¸åŒç±»å‹çš„å¯¹è±¡)ï¼Œarrayå­˜å‚¨äº†åŒç±»å‹çš„å¯¹è±¡ï¼Œæ— éœ€ä¸€å®šè¦å­˜å‚¨å¯¹è±¡ï¼Œä¹Ÿå¯å­˜å‚¨Intç­‰ç±»å‹
ä»¥ä¸‹ä¸¤ä¸ªå®šä¹‰ç­‰ä»·</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var shoppingList: String[] = ["Eggs", "Milk"]
</span><span class='line'>var shoppingList = ["Eggs", "Milk"]</span></code></pre></td></tr></table></div></figure>


<h5>è®¿é—®æˆ–ä¿®æ”¹array</h5>

<p>è®¡ç®—arrayçš„å¤§å°</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>â€œprintln("The shopping list contains \(shoppingList.count) items.")
</span><span class='line'>// prints "The shopping list contains 2 items.â€</span></code></pre></td></tr></table></div></figure>


<p>ç”¨isEmptyæ¥åˆ¤æ–­counå¾—å¦ä¸º0</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if shoppingList.isEmpty {
</span><span class='line'>    println("The shopping list is empty.")
</span><span class='line'>} else {
</span><span class='line'>    println("The shopping list is not empty.")
</span><span class='line'>}
</span><span class='line'>// prints "The shopping list is not empty."</span></code></pre></td></tr></table></div></figure>


<p>æ·»åŠ å…ƒç´ </p>

<ul>
<li>ç”¨append</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList.append("Flour")
</span><span class='line'>// shoppingList now contains 3 items, and someone is making pancakesâ€</span></code></pre></td></tr></table></div></figure>


<ul>
<li>ç”¨+=</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList += "Baking Powder"
</span><span class='line'>// shoppingList now contains 4 itemsâ€
</span><span class='line'>
</span><span class='line'>shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
</span><span class='line'>// shoppingList now contains 7 itemsâ€</span></code></pre></td></tr></table></div></figure>


<p>ç”¨Rangeæ¥æ”¹å˜æ•°ç»„é‡Œä¸€äº›å…ƒç´ çš„å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList[4...6] = ["Bananas", "Apples"]
</span><span class='line'>// shoppingList now contains 6 itemsâ€</span></code></pre></td></tr></table></div></figure>


<p>åœ¨æŸä½ç½®æ’å…¥å…ƒç´ </p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shoppingList.insert("Maple Syrup", atIndex: 0)
</span><span class='line'>// shoppingList now contains 7 items
</span><span class='line'>// "Maple Syrup" is now the first item in the listâ€</span></code></pre></td></tr></table></div></figure>


<p>ç§»é™¤å…ƒç´ </p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let mapleSyrup = shoppingList.removeAtIndex(0)
</span><span class='line'>let apples = shoppingList.removeLast()</span></code></pre></td></tr></table></div></figure>


<p>éå†</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for item in shoppingList {
</span><span class='line'>    println(item)
</span><span class='line'>}
</span><span class='line'>// Six eggs
</span><span class='line'>// Milk
</span><span class='line'>// Flour
</span><span class='line'>// Baking Powder
</span><span class='line'>// Bananasâ€</span></code></pre></td></tr></table></div></figure>


<p>å¦‚æœä½ åœ¨éå†æ—¶éœ€è¦çŸ¥é“å¯¹åº”çš„indexï¼Œå¯ä»¥ç”¨ä»¥ä¸‹æ–¹å¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (index, value) in enumerate(shoppingList) {
</span><span class='line'>    println("Item \(index + 1): \(value)")
</span><span class='line'>}
</span><span class='line'>// Item 1: Six eggs
</span><span class='line'>// Item 2: Milk
</span><span class='line'>// Item 3: Flour
</span><span class='line'>// Item 4: Baking Powder
</span><span class='line'>// Item 5: Bananas</span></code></pre></td></tr></table></div></figure>


<h4>åˆ›å»ºå’Œåˆå§‹åŒ–Array</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someInts = Int[]()
</span><span class='line'>println("someInts is of type Int[] with \(someInts.count) items.")
</span><span class='line'>// prints "someInts is of type Int[] with 0 items.</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„ä»¥ä¸‹ä¾‹å­ï¼Œè™½ç„¶someInt=[]ä¸æŒ‡å®šä»»ä½•ç±»å‹ï¼Œä½†ä»å‰æ®µä»£ç å¯çŸ¥å®ƒçš„å…ƒç´ æ˜¯Intç±»å‹çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>someInts.append(3)
</span><span class='line'>// someInts now contains 1 value of type Int
</span><span class='line'>someInts = []
</span><span class='line'>// someInts is now an empty array, but is still of type Int[]</span></code></pre></td></tr></table></div></figure>


<p>æŒ‡å®šdefaultå€¼å’Œæ•°ç›®çš„åˆå§‹åŒ–</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var threeDoubles = Double[](count: 3, repeatedValue: 0.0)
</span><span class='line'>// threeDoubles is of type Double[], and equals [0.0, 0.0, 0.0]
</span><span class='line'>
</span><span class='line'>var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)
</span><span class='line'>// anotherThreeDoubles is inferred as Double[], and equals [2.5, 2.5, 2.5]</span></code></pre></td></tr></table></div></figure>


<p>æœ€åæˆ‘ä»¬èƒ½é€šè¿‡+æ¥å°†ä¸¤ä¸ªæ•°ç»„è¿æˆä¸€ä¸ª</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var sixDoubles = threeDoubles + anotherThreeDoubles
</span><span class='line'>// sixDoubles is inferred as Double[], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]â€</span></code></pre></td></tr></table></div></figure>


<h4>å­—å…¸</h4>

<p>å¯¹keyçš„å”¯ä¸€è¦æ±‚æ˜¯hashable,Enumeration member values without associated values (as described in Enumerations) are also hashable by default.
ä»¥ä¸‹ä¸¤ä¸ªå®šä¹‰æ˜¯ç­‰ä»·çš„ï¼Œswiftèƒ½æ¨æµ‹å‡ºå®ƒçš„ç±»å‹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]â€
</span><span class='line'>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]
</span></code></pre></td></tr></table></div></figure>


<h4>è®¿é—®å’Œä¿®æ”¹å­—å…¸</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The dictionary of airports contains \(airports.count) items.")
</span><span class='line'>// prints "The dictionary of airports contains 2 items.</span></code></pre></td></tr></table></div></figure>


<p>æ–¹æ³•updateValue(forKey:)çš„ä½¿ç”¨</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let oldValue = airports.updateValue("Dublin International", forKey: "DUB") {
</span><span class='line'>    println("The old value for DUB was \(oldValue).")
</span><span class='line'>}
</span><span class='line'>// prints "The old value for DUB was Dublin.</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„ï¼Œæ­¤æ–¹æ³•å¯¹åº”çš„æ˜¯keyå¯¹åº”çš„æ—§å€¼ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªoptional value
ç”¨[]è·å–çš„å€¼ä¹Ÿæ˜¯optional vlaue</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let airportName = airports["DUB"] {
</span><span class='line'>    println("The name of the airport is \(airportName).")
</span><span class='line'>} else {
</span><span class='line'>    println("That airport is not in the airports dictionary.")
</span><span class='line'>}
</span><span class='line'>// prints "The name of the airport is Dublin International.</span></code></pre></td></tr></table></div></figure>


<p>æˆ‘ä»¬å¯ä»¥å°†nilèµ‹äºˆkeyå¯¹åº”çš„å€¼æ¥ç§»é™¤æ­¤key</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>airports["APL"] = "Apple International"
</span><span class='line'>// "Apple International" is not the real airport for APL, so delete it
</span><span class='line'>airports["APL"] = nil
</span><span class='line'>// APL has now been removed from the dictionary</span></code></pre></td></tr></table></div></figure>


<p>ä¹Ÿå¯ä»¥ç”¨<code>removeValueForKey</code>æ–¹æ³•
æ­¤æ–¹æ³•è¿”å›çš„æ˜¯keyå¯¹åº”çš„æ—§å€¼,æˆ–è€…nil(å¦‚æœä¸å­˜åœ¨çš„è¯)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let removedValue = airports.removeValueForKey("DUB") {
</span><span class='line'>    println("The removed airport's name is \(removedValue).")
</span><span class='line'>} else {
</span><span class='line'>    println("The airports dictionary does not contain a value for DUB.")
</span><span class='line'>}
</span><span class='line'>// prints "The removed airport's name is Dublin International.â€</span></code></pre></td></tr></table></div></figure>


<h5>éå†å­—å…¸</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (airportCode, airportName) in airports {
</span><span class='line'>    println("\(airportCode): \(airportName)")
</span><span class='line'>}
</span><span class='line'>// TYO: Tokyo
</span><span class='line'>// LHR: London Heathrow
</span><span class='line'>
</span><span class='line'>for airportCode in airports.keys {
</span><span class='line'>    println("Airport code: \(airportCode)")
</span><span class='line'>}
</span><span class='line'>// Airport code: TYO
</span><span class='line'>// Airport code: LHR
</span><span class='line'> 
</span><span class='line'>for airportName in airports.values {
</span><span class='line'>    println("Airport name: \(airportName)")
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//ç”¨keysæˆ–valuesåˆ›å»ºä¸€ä¸ªæ•°ç»„
</span><span class='line'>let airportCodes = Array(airports.keys)
</span><span class='line'>// airportCodes is ["TYO", "LHR"]
</span><span class='line'> 
</span><span class='line'>let airportNames = Array(airports.values)
</span><span class='line'>// airportNames is ["Tokyo", "London Heathrow"]</span></code></pre></td></tr></table></div></figure>


<h4>åˆ›å»ºä¸€ä¸ªç©ºçš„å­—å…¸</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var namesOfIntegers = Dictionary&lt;Int, String&gt;()</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„ä»¥ä¸‹,namesIntegersèƒ½è¢«æ¨æ–­å‡ºæ˜¯&lt;Int,String></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>namesOfIntegers[16] = "sixteen"
</span><span class='line'>// namesOfIntegers now contains 1 key-value pair
</span><span class='line'>namesOfIntegers = [:]</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code>Behind the scenes, Swiftâ€™s array and dictionary types are implemented as generic collections</p>

<h4>Mutability Of Collections</h4>

<p>å¯¹å­—å…¸æ¥è¯´,immutabilityæ„å‘³ç€ä½ ä¸èƒ½æ”¹å˜ä¸€ä¸ªkeyå¯¹åº”çš„å€¼ï¼Œè€Œå¯¹æ•°ç»„æ¥è¯´ï¼Œä½ åªæ˜¯ä¸èƒ½æ”¹å˜å®ƒçš„å¤§å°ï¼Œä½†ä»ç„¶èƒ½æ”¹å˜æŸä¸ªindexå¯¹åº”çš„å€¼</p>

<h4>æ¡ä»¶è¯­å¥</h4>

<p>æ³¨æ„,swiftçš„switchä¸­çš„caseåæ— éœ€è·Ÿç€breakï¼Œå› ä¸ºæ‰§è¡Œå®Œcaseé‡Œçš„è¯­å¥å°±è‡ªåŠ¨breakäº†ï¼Œcasesä¹Ÿèƒ½åŒ¹é…ä¸åŒçš„ç±»å‹ï¼ŒåŒ…æ‹¬range,tuplesæˆ–è½¬æ¢ä¸ºæŸä¸€å…·ä½“çš„ç±»å‹</p>

<h5>For Loops</h5>

<ul>
<li>For-In</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for index in 1...5 {
</span><span class='line'>    println("\(index) times 5 is \(index * 5)")
</span><span class='line'>}
</span><span class='line'>// 1 times 5 is 5
</span><span class='line'>// 2 times 5 is 10
</span><span class='line'>// 3 times 5 is 15
</span><span class='line'>// 4 times 5 is 20
</span><span class='line'>// 5 times 5 is 25â€</span></code></pre></td></tr></table></div></figure>


<p>å¦‚æœä½ ä¸éœ€è¦indexï¼Œå¯ä»¥ç”¨<code>_</code>æ¥å¿½ç•¥å®ƒ</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let base = 3
</span><span class='line'>let power = 10
</span><span class='line'>var answer = 1
</span><span class='line'>for _ in 1...power {
</span><span class='line'>    answer *= base
</span><span class='line'>}
</span><span class='line'>println("\(base) to the power of \(power) is \(answer)")
</span><span class='line'>// prints "3 to the power of 10 is 59049</span></code></pre></td></tr></table></div></figure>


<p>array,dictionary,charactersçš„for-in</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Anna", "Alex", "Brian", "Jack"]
</span><span class='line'>for name in names {
</span><span class='line'>    println("Hello, \(name)!")
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
</span><span class='line'>for (animalName, legCount) in numberOfLegs {
</span><span class='line'>    println("\(animalName)s have \(legCount) legs")
</span><span class='line'>}
</span><span class='line'>// spiders have 8 legs
</span><span class='line'>// ants have 6 legs
</span><span class='line'>// cats have 4 legs
</span><span class='line'>
</span><span class='line'>for character in "Hello" {
</span><span class='line'>    println(character)
</span><span class='line'>}
</span><span class='line'>// H
</span><span class='line'>// e
</span><span class='line'>// l
</span><span class='line'>// l
</span><span class='line'>// o</span></code></pre></td></tr></table></div></figure>


<h5>For-Condition-Increment</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for var index = 0; index &lt; 3; ++index {
</span><span class='line'>    println("index is \(index)")
</span><span class='line'>}
</span><span class='line'>// index is 0
</span><span class='line'>// index is 1
</span><span class='line'>// index is 2</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„foråæ— éœ€æ‹¬å·</p>

<h5>æ¡ä»¶è¯­å¥</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var temperatureInFahrenheit = 30
</span><span class='line'>if temperatureInFahrenheit &lt;= 32 {
</span><span class='line'>    println("It's very cold. Consider wearing a scarf.")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>switchè¯­å¥</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someCharacter: Character = "e"
</span><span class='line'>switch someCharacter {
</span><span class='line'>case "a", "e", "i", "o", "u":
</span><span class='line'>    println("\(someCharacter) is a vowel")
</span><span class='line'>case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
</span><span class='line'>"n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
</span><span class='line'>    println("\(someCharacter) is a consonant")
</span><span class='line'>default:
</span><span class='line'>    println("\(someCharacter) is not a vowel or a consonant")
</span><span class='line'>}
</span><span class='line'>// prints "e is a vowelâ€</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„ï¼Œä»¥ä¸‹æ–¹å¼ä¸è¡Œ</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anotherCharacter: Character = "a"
</span><span class='line'>switch anotherCharacter {
</span><span class='line'>case "a":
</span><span class='line'>case "A":
</span><span class='line'>    println("The letter A")
</span><span class='line'>default:
</span><span class='line'>    println("Not the letter A")
</span><span class='line'>}
</span><span class='line'>// this will report a compile-time error</span></code></pre></td></tr></table></div></figure>


<p>æ¯ä¸ªcaseé‡Œå¿…é¡»å¯¹åº”ç›¸åº”çš„è¯­å¥</p>

<h5>Range Matching</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let count = 3_000_000_000_000
</span><span class='line'>let countedThings = "stars in the Milky Way"
</span><span class='line'>var naturalCount: String
</span><span class='line'>switch count {
</span><span class='line'>case 0:
</span><span class='line'>    naturalCount = "no"
</span><span class='line'>case 1...3:
</span><span class='line'>    naturalCount = "a few"
</span><span class='line'>case 4...9:
</span><span class='line'>    naturalCount = "several"
</span><span class='line'>case 10...99:
</span><span class='line'>    naturalCount = "tens of"
</span><span class='line'>case 100...999:
</span><span class='line'>    naturalCount = "hundreds of"
</span><span class='line'>case 1000...999_999:
</span><span class='line'>    naturalCount = "thousands of"
</span><span class='line'>default:
</span><span class='line'>    naturalCount = "millions and millions of"
</span><span class='line'>}
</span><span class='line'>println("There are \(naturalCount) \(countedThings).")
</span><span class='line'>// prints "There are millions and millions of stars in the Milky Way.â€</span></code></pre></td></tr></table></div></figure>


<h5>Tuples</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let somePoint = (1, 1)
</span><span class='line'>switch somePoint {
</span><span class='line'>case (0, 0):
</span><span class='line'>    println("(0, 0) is at the origin")
</span><span class='line'>case (_, 0):
</span><span class='line'>    println("(\(somePoint.0), 0) is on the x-axis")
</span><span class='line'>case (0, _):
</span><span class='line'>    println("(0, \(somePoint.1)) is on the y-axis")
</span><span class='line'>case (-2...2, -2...2):
</span><span class='line'>    println("(\(somePoint.0), \(somePoint.1)) is inside the box")
</span><span class='line'>default:
</span><span class='line'>    println("(\(somePoint.0), \(somePoint.1)) is outside of the box")
</span><span class='line'>}
</span><span class='line'>// prints "(1, 1) is inside the boxâ€</span></code></pre></td></tr></table></div></figure>


<h4>Value Bindings</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anotherPoint = (2, 0)
</span><span class='line'>switch anotherPoint {
</span><span class='line'>case (let x, 0):
</span><span class='line'>    println("on the x-axis with an x value of \(x)")
</span><span class='line'>case (0, let y):
</span><span class='line'>    println("on the y-axis with a y value of \(y)")
</span><span class='line'>case let (x, y):
</span><span class='line'>    println("somewhere else at (\(x), \(y))")
</span><span class='line'>}
</span><span class='line'>// prints "on the x-axis with an x value of 2â€</span></code></pre></td></tr></table></div></figure>


<h5>whereçš„ä½¿ç”¨</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let yetAnotherPoint = (1, -1)
</span><span class='line'>switch yetAnotherPoint {
</span><span class='line'>case let (x, y) where x == y:
</span><span class='line'>    println("(\(x), \(y)) is on the line x == y")
</span><span class='line'>case let (x, y) where x == -y:
</span><span class='line'>    println("(\(x), \(y)) is on the line x == -y")
</span><span class='line'>case let (x, y):
</span><span class='line'>    println("(\(x), \(y)) is just some arbitrary point")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Control Transferè¯­å¥</h5>

<p>æ³¨æ„FallThroughçš„ä½¿ç”¨,æ¥çœ‹ä»¥ä¸‹ä¾‹å­</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let integerToDescribe = 5
</span><span class='line'>var description = "The number \(integerToDescribe) is"
</span><span class='line'>switch integerToDescribe {
</span><span class='line'>case 2, 3, 5, 7, 11, 13, 17, 19:
</span><span class='line'>    description += " a prime number, and also"
</span><span class='line'>    fallthrough
</span><span class='line'>default:
</span><span class='line'>    description += " an integer."
</span><span class='line'>}
</span><span class='line'>println(description)
</span><span class='line'>// prints "The number 5 is a prime number, and also an integer.â€</span></code></pre></td></tr></table></div></figure>


<h4>Labeledè¯­å¥</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gameLoop: while square != finalSquare {
</span><span class='line'>    if ++diceRoll == 7 { diceRoll = 1 }
</span><span class='line'>    switch square + diceRoll {
</span><span class='line'>    case finalSquare:
</span><span class='line'>        // diceRoll will move us to the final square, so the game is over
</span><span class='line'>        break gameLoop
</span><span class='line'>    case let newSquare where newSquare &gt; finalSquare:
</span><span class='line'>        // diceRoll will move us beyond the final square, so roll again
</span><span class='line'>        continue gameLoop
</span><span class='line'>    default:
</span><span class='line'>        // this is a valid move, so find out its effect
</span><span class='line'>        square += diceRoll
</span><span class='line'>        square += board[square]
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println("Game over!")â€</span></code></pre></td></tr></table></div></figure>


<h4>å‡½æ•°</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayHello(personName: String) -&gt; String {
</span><span class='line'>    let greeting = "Hello, " + personName + "!"
</span><span class='line'>    return greeting
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>println(sayHello("Anna"))
</span><span class='line'>// prints "Hello, Anna!"
</span><span class='line'>println(sayHello("Brian"))
</span><span class='line'>// prints "Hello, Brian!â€
</span><span class='line'>
</span><span class='line'>func sayHelloWorld() -&gt; String {
</span><span class='line'>    return "hello, world"
</span><span class='line'>}
</span><span class='line'>println(sayHelloWorld())
</span><span class='line'>// prints "hello, worldâ€</span></code></pre></td></tr></table></div></figure>


<p>æ— è¿”å›å€¼çš„å‡½æ•°</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayGoodbye(personName: String) {
</span><span class='line'>    println("Goodbye, \(personName)!")
</span><span class='line'>}
</span><span class='line'>sayGoodbye("Dave")
</span><span class='line'>// prints "Goodbye, Dave!"</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„ï¼Œå®é™…ä¸Šï¼Œè™½ç„¶å‡½æ•°æ²¡å†™è¿”å›å€¼ï¼Œä½†å®ƒè¿”å›çš„æ˜¯ä¸€ä¸ªç©ºçš„tuple<code>()</code></p>

<h5>è¿”å›å¤šä¸ªå€¼</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func count(string: String) -&gt; (vowels: Int, consonants: Int, others: Int) {
</span><span class='line'>    var vowels = 0, consonants = 0, others = 0
</span><span class='line'>    for character in string {
</span><span class='line'>        switch String(character).lowercaseString {
</span><span class='line'>        case "a", "e", "i", "o", "u":
</span><span class='line'>            ++vowels
</span><span class='line'>        case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
</span><span class='line'>        "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
</span><span class='line'>            ++consonants
</span><span class='line'>        default:
</span><span class='line'>            ++others
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return (vowels, consonants, others)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let total = count("some arbitrary string!")
</span><span class='line'>println("\(total.vowels) vowels and \(total.consonants) consonants")
</span><span class='line'>// prints "6 vowels and 13 consonantsâ€</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code>,.vowerlså’Œ.consonantsä¾ç„¶å¯ç”¨!!!</p>

<h5>External Parameter Names</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunction(externalParameterName localParameterName: Int) {
</span><span class='line'>    // function body goes here, and can use localParameterName
</span><span class='line'>    // to refer to the argument value for that parameter
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func join(string s1: String, toString s2: String, withJoiner joiner: String)
</span><span class='line'>    -&gt; String {
</span><span class='line'>        return s1 + joiner + s2
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>join(string: "hello", toString: "world", withJoiner: ", ")</span></code></pre></td></tr></table></div></figure>


<h5>Shorthand External Parameter Names</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool {
</span><span class='line'>    for character in string {
</span><span class='line'>        if character == characterToFind {
</span><span class='line'>            return true
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return false
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let containsAVee = containsCharacter(string: "aardvark", characterToFind: "v")
</span><span class='line'>// containsAVee equals true, because "aardvark" contains a "vâ€</span></code></pre></td></tr></table></div></figure>


<h4>å‚æ•°çš„é»˜è®¤å€¼</h4>

<p>å°†æœ‰é»˜è®¤å€¼çš„å‚æ•°æ”¾åœ¨æœ€å</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func join(string s1: String, toString s2: String,
</span><span class='line'>    withJoiner joiner: String = " ") -&gt; String {
</span><span class='line'>        return s1 + joiner + s2
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>join(string: "hello", toString: "world", withJoiner: "-")
</span><span class='line'>// returns "hello-world"
</span><span class='line'>
</span><span class='line'>join(string: "hello", toString: "world")
</span><span class='line'>// returns "hello world"</span></code></pre></td></tr></table></div></figure>


<h5>External Names for Parameters with Default Values</h5>

<p>Swift provides an automatic external name for any defaulted parameter you define
æ•…å¯ä»¥åƒå¦‚ä¸‹è°ƒç”¨</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>join("hello", "world", joiner: "-")</span></code></pre></td></tr></table></div></figure>


<h5>Variadic Parameters</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func arithmeticMean(numbers: Double...) -&gt; Double {
</span><span class='line'>    var total: Double = 0
</span><span class='line'>    for number in numbers {
</span><span class='line'>        total += number
</span><span class='line'>    }
</span><span class='line'>    return total / Double(numbers.count)
</span><span class='line'>}
</span><span class='line'>arithmeticMean(1, 2, 3, 4, 5)
</span><span class='line'>// returns 3.0, which is the arithmetic mean of these five numbers
</span><span class='line'>arithmeticMean(3, 8, 19)
</span><span class='line'>// returns 10.0, which is the arithmetic mean of these three numbers</span></code></pre></td></tr></table></div></figure>


<p>ä¸€ä¸ªå‡½æ•°è‡³å¤šåªèƒ½æœ‰ä¸€ä¸ªvariadicå‚æ•°ï¼Œå®ƒå¿…é¡»æ€»æ˜¯åœ¨æ‰€æœ‰å‚æ•°çš„æœ€å!</p>

<h5>Constant å’Œ Variable å‚æ•°</h5>

<p>å‡½æ•°çš„å‚æ•°é»˜è®¤æ˜¯constantçš„,å¦‚æœè¯•å›¾ä¿®æ”¹å®ƒå°†å¯¼è‡´é”™è¯¯,æˆ‘ä»¬å¯ä»¥åœ¨å‚æ•°å‰åŠ varæ¥è®©å®ƒå¯ä¿®æ”¹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func alignRight(var string: String, count: Int, pad: Character) -&gt; String {
</span><span class='line'>    let amountToPad = count - countElements(string)
</span><span class='line'>    for _ in 1...amountToPad {
</span><span class='line'>        string = pad + string
</span><span class='line'>    }
</span><span class='line'>    return string
</span><span class='line'>}
</span><span class='line'>let originalString = "hello"
</span><span class='line'>let paddedString = alignRight(originalString, 10, "-")
</span><span class='line'>// paddedString is equal to "-----hello"
</span><span class='line'>// originalString is still equal to "helloâ€</span></code></pre></td></tr></table></div></figure>


<h5>In-Outå‚æ•°</h5>

<p>æ¥çœ‹ä¸ªdemoå°±æ˜ç™½In-Outæ˜¯å¦‚ä½•ä½¿ç”¨çš„äº†</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoInts(inout a: Int, inout b: Int) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoInts(&someInt, &anotherInt)
</span><span class='line'>println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
</span><span class='line'>// prints "someInt is now 107, and anotherInt is now 3â€</span></code></pre></td></tr></table></div></figure>


<p>éœ€è¦æ³¨æ„çš„æ˜¯In-outå‚æ•°ä¸èƒ½æœ‰é»˜è®¤å€¼,variadicå‚æ•°ä¸èƒ½ä¸inoutä¸€èµ·ä½¿ç”¨,letä¹Ÿä¸è¡Œ</p>

<h5>å‡½æ•°ç±»å‹</h5>

<p>å¯ä»¥åƒä»¥ä¸‹è¿™ä¹ˆç”¨</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var mathFunction: (Int, Int) -&gt; Int = addTwoInts
</span><span class='line'>println("Result: \(mathFunction(2, 3))")</span></code></pre></td></tr></table></div></figure>


<p>åŒæ ·çš„å‡½æ•°ç­¾åä¹Ÿå¯ä»¥èµ‹å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mathFunction = multiplyTwoInts
</span><span class='line'>println("Result: \(mathFunction(2, 3))")
</span><span class='line'>// prints "Result: 6</span></code></pre></td></tr></table></div></figure>


<p>ä¹Ÿå¯ä»¥æ ¹æ®Swiftçš„è‡ªåŠ¨æ¨æ–­åŠŸèƒ½åƒä»¥ä¸‹æ–¹æ³•ä½¿ç”¨</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anotherMathFunction = addTwoInts</span></code></pre></td></tr></table></div></figure>


<h5>å……å½“å‚æ•°çš„å‡½æ•°ç±»å‹</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func printMathResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int) {
</span><span class='line'>    println("Result: \(mathFunction(a, b))")
</span><span class='line'>}
</span><span class='line'>printMathResult(addTwoInts, 3, 5)
</span><span class='line'>// prints "Result: 8â€</span></code></pre></td></tr></table></div></figure>


<h5>ä½œä¸ºè¿”å›ç±»å‹çš„å‡½æ•°ç±»å‹</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func stepForward(input: Int) -&gt; Int {
</span><span class='line'>    return input + 1
</span><span class='line'>}
</span><span class='line'>func stepBackward(input: Int) -&gt; Int {
</span><span class='line'>    return input - 1
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
</span><span class='line'>    return backwards ? stepBackward : stepForward
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var currentValue = 3
</span><span class='line'>let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
</span><span class='line'>// moveNearerToZero now refers to the stepBackward() function
</span><span class='line'>
</span><span class='line'>println("Counting to zero:")
</span><span class='line'>// Counting to zero:
</span><span class='line'>while currentValue != 0 {
</span><span class='line'>    println("\(currentValue)... ")
</span><span class='line'>    currentValue = moveNearerToZero(currentValue)
</span><span class='line'>}
</span><span class='line'>println("zero!")
</span><span class='line'>// 3...
</span><span class='line'>// 2...
</span><span class='line'>// 1...
</span><span class='line'>// zero!</span></code></pre></td></tr></table></div></figure>


<h5>åµŒå¥—å‡½æ•°</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
</span><span class='line'>    func stepForward(input: Int) -&gt; Int { return input + 1 }
</span><span class='line'>    func stepBackward(input: Int) -&gt; Int { return input - 1 }
</span><span class='line'>    return backwards ? stepBackward : stepForward
</span><span class='line'>}
</span><span class='line'>var currentValue = -4
</span><span class='line'>let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
</span><span class='line'>// moveNearerToZero now refers to the nested stepForward() function
</span><span class='line'>while currentValue != 0 {
</span><span class='line'>    println("\(currentValue)... ")
</span><span class='line'>    currentValue = moveNearerToZero(currentValue)
</span><span class='line'>}
</span><span class='line'>println("zero!")
</span><span class='line'>// -4...
</span><span class='line'>// -3...
</span><span class='line'>// -2...
</span><span class='line'>// -1...
</span><span class='line'>// zero!</span></code></pre></td></tr></table></div></figure>


<h4>é—­åŒ…</h4>

<p>ç±»ä¼¼OCä¸­çš„block</p>

<h5>Sortå‡½æ•°</h5>

<p>ç¬¬ä¸€ç§ä½¿ç”¨æ–¹å¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</span><span class='line'>//demo 1
</span><span class='line'>func backwards(s1: String, s2: String) -&gt; Bool {
</span><span class='line'>    return s1 &gt; s2
</span><span class='line'>}
</span><span class='line'>var reversed = sort(names, backwards)</span></code></pre></td></tr></table></div></figure>


<p>ç¬¬äºŒç§</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in
</span><span class='line'>    return s1 &gt; s2
</span><span class='line'>    })</span></code></pre></td></tr></table></div></figure>


<p>closureçš„bodyå’Œå£°æ˜ç”¨inå…³é”®è¯åˆ†éš”å¼€æ¥</p>

<h5>Inferring Type From Context</h5>

<p>ç”±äºsortçš„closureæ˜¯ä»¥å‚æ•°çš„å½¢å¼ä¼ å…¥å‡½æ•°ï¼Œæ‰€ä»¥swiftèƒ½ä»æ¨æµ‹å‡ºé—­åŒ…çš„å‚æ•°ç±»å‹å’Œè¿”å›å€¼ç±»å‹,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŒ‰ä»¥ä¸‹æ–¹å¼æ¥å†™</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { s1, s2 in return s1 &gt; s2 } )</span></code></pre></td></tr></table></div></figure>


<p>ä¹Ÿå¯ä»¥çœç•¥return,å› ä¸ºé»˜è®¤æ˜¯æœ‰returnè¿™ä¸ªå…³é”®å­—çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { s1, s2 in  s1 &gt; s2 } )</span></code></pre></td></tr></table></div></figure>


<h5>Shorthand Argument Names</h5>

<p>Swifté»˜è®¤ä¸ºå†…è”çš„å‚æ•°åæŒ‡å®šäº†è¯¸å¦‚$0, $1ç­‰åå­—
If you use these shorthand argument names within your closure expression, you can omit the closureâ€™s argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type. The in keyword can also be omitted, because the closure expression is made up entirely of its body:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, { $0 &gt; $1 } )</span></code></pre></td></tr></table></div></figure>


<p>ä»¥ä¸Šçš„demoä¸­,$0å’Œ$1åˆ†åˆ«æŒ‡å‘äº†é—­åŒ…çš„ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªStringå‚æ•°</p>

<h5>Operators Function</h5>

<p>Thereâ€™s actually an even shorter way to write the closure expression above. Swiftâ€™s String type defines its string-specific implementation of the greater-than operator (>) as a function that has two parameters of type String, and returns a value of type Bool. This exactly matches the function type needed for the sort functionâ€™s second parameter. Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = sort(names, &gt;)</span></code></pre></td></tr></table></div></figure>


<h5>Trailing Closures</h5>

<p>å¦‚æœä½ å°†ä¸€ä¸ªé—­åŒ…æŒ‡å®šä¸ºä¸€ä¸ªå‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°ï¼Œå¹¶ä¸”è¿™ä¸ªé—­åŒ…è¡¨è¾¾å¼å¾ˆé•¿ï¼Œä½ å¯ä»¥å°†å®ƒä½œä¸ºä¸€ä¸ªtrailing closure,å®ƒæ˜¯ä¸€ä¸ªå†™åœ¨å‡½æ•°çš„æ‹¬å·ä¹‹å¤–çš„closure</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunctionThatTakesAClosure(closure: () -&gt; ()) {
</span><span class='line'>    // function body goes here
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// here's how you call this function without using a trailing closure:
</span><span class='line'> 
</span><span class='line'>someFunctionThatTakesAClosure({
</span><span class='line'>    // closure's body goes here
</span><span class='line'>    })
</span><span class='line'> 
</span><span class='line'>// here's how you call this function with a trailing closure instead:
</span><span class='line'> 
</span><span class='line'>someFunctionThatTakesAClosure() {
</span><span class='line'>    // trailing closure's body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code>:å¦‚æœä¸€ä¸ªclosure expressionæ˜¯ä¸€ä¸ªå‡½æ•°çš„æƒŸå‚æ•°,åˆ™æ— éœ€è¦æ‹¬å·ï¼Œæ•…ä»¥ä¸Šä¹Ÿå¯ä»¥å†™æˆ</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>someFunctionThatTakesAClosure {
</span><span class='line'>    // trailing closure's body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>æ¥çœ‹ä¸€ä¸ªArrayä¸­çš„mapæ–¹æ³•çš„ä¾‹å­ï¼Œåªæœ‰ä¸€ä¸ªå‚æ•°ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªclosure</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let digitNames = [
</span><span class='line'>    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
</span><span class='line'>    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
</span><span class='line'>]
</span><span class='line'>let numbers = [16, 58, 510]
</span><span class='line'>
</span><span class='line'>let strings = numbers.map {
</span><span class='line'>    (var number) -&gt; String in
</span><span class='line'>    var output = ""
</span><span class='line'>    while number &gt; 0 {
</span><span class='line'>        output = digitNames[number % 10]! + output
</span><span class='line'>        number /= 10
</span><span class='line'>    }
</span><span class='line'>    return output
</span><span class='line'>}
</span><span class='line'>// strings is inferred to be of type String[]
</span><span class='line'>// its value is ["OneSix", "FiveEight", "FiveOneZero"]</span></code></pre></td></tr></table></div></figure>


<h5>Capturing Values</h5>

<p>Swiftä¸­closureçš„æœ€ç®€å•å½¢å¼æ˜¯ä¸€ä¸ªå†…åµŒçš„å‡½æ•°</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
</span><span class='line'>    var runningTotal = 0
</span><span class='line'>    func incrementor() -&gt; Int {
</span><span class='line'>        runningTotal += amount
</span><span class='line'>        return runningTotal
</span><span class='line'>    }
</span><span class='line'>    return incrementor
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>because it modifies the runningTotal variable each time it is called, incrementor captures a reference to the current runningTotal variable, and not just a copy of its initial value. Capturing a reference ensures sure that runningTotal does not disappear when the call to makeIncrementor ends, and ensures that runningTotal will continue to be available the next time that the incrementor function is called.
æ³¨æ„ä»¥ä¸‹çš„è°ƒç”¨</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let incrementByTen = makeIncrementor(forIncrement: 10)
</span><span class='line'>
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 10
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 20
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 30</span></code></pre></td></tr></table></div></figure>


<p>If you create another incrementor, it will have its own stored reference to a new, separate runningTotal variable</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let incrementBySeven = makeIncrementor(forIncrement: 7)
</span><span class='line'>incrementBySeven()
</span><span class='line'>// returns a value of 7
</span><span class='line'>incrementByTen()
</span><span class='line'>// returns a value of 40</span></code></pre></td></tr></table></div></figure>


<p>incrementByTenæ•è·çš„å˜é‡ä¸incrementBySevenæ•è·çš„æ— å…³</p>

<h5>Closureæ˜¯å¼•ç”¨ç±»å‹</h5>

<p>ä¹Ÿå°±æ˜¯è¯´å¦‚æœä½ å°†closureèµ‹ç»™ä¸¤ä¸ªä¸åŒçš„å¸¸é‡æˆ–å˜é‡ï¼Œè¿™ä¸¤ä¸ªå¸¸é‡æˆ–å˜é‡å°†æŒ‡å‘ä¸€æ ·çš„closure</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let alsoIncrementByTen = incrementByTen
</span><span class='line'>alsoIncrementByTen()
</span><span class='line'>// returns a value of 50</span></code></pre></td></tr></table></div></figure>


<h4>Enumerations</h4>

<p>Enumerations in Swift are first-class types in their own right. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumerationâ€™s current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial member value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</p>

<h5>Enumeration Syntax</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum CompassPoint {
</span><span class='line'>    case North
</span><span class='line'>    case South
</span><span class='line'>    case East
</span><span class='line'>    case West
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<pre><code>    Unlike C and Objective-C, Swift enumeration members are not assigned a default integer value when they are created. In the CompassPoints example above, North, South, East and West do not implicitly equal 0, 1, 2 and 3. Instead, the different enumeration members are fully-fledged values in their own right, with an explicitly-defined type of CompassPoint.
</code></pre>

<p>å¤šä¸ªæˆå‘˜å€¼å¯ä»¥å‡ºç°åœ¨åŒä¸€è¡Œä¸Šï¼Œç”¨<code>,</code>åˆ†å¼€</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Planet {
</span><span class='line'>    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>æ¥çœ‹ä»¥ä¸‹ä¾‹å­</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var directionToHead = CompassPoint.West
</span><span class='line'>directionToHead = .East</span></code></pre></td></tr></table></div></figure>


<p>ä¸€æ—¦çŸ¥é“äº†directionToHeadçš„ç±»å‹ï¼Œå®ƒçš„type(CompassPoint)å¯ä»¥çœç•¥</p>

<h5>Switch..case</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>directionToHead = .South
</span><span class='line'>switch directionToHead {
</span><span class='line'>case .North:
</span><span class='line'>    println("Lots of planets have a north")
</span><span class='line'>case .South:
</span><span class='line'>    println("Watch out for penguins")
</span><span class='line'>case .East:
</span><span class='line'>    println("Where the sun rises")
</span><span class='line'>case .West:
</span><span class='line'>    println("Where the skies are blue")
</span><span class='line'>}
</span><span class='line'>// prints "Watch out for penguins</span></code></pre></td></tr></table></div></figure>


<h5>Associated Values</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Barcode {
</span><span class='line'>    case UPCA(Int, Int, Int)
</span><span class='line'>    case QRCode(String)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var productBarcode = Barcode.UPCA(8, 85909_51226, 3)
</span><span class='line'>productBarcode = .QRCode("ABCDEFGHIJKLMNOP")
</span><span class='line'>
</span><span class='line'>switch productBarcode {
</span><span class='line'>case .UPCA(let numberSystem, let identifier, let check):
</span><span class='line'>    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
</span><span class='line'>case .QRCode(let productCode):
</span><span class='line'>    println("QR code with value of \(productCode).")
</span><span class='line'>}
</span><span class='line'>// prints "QR code with value of ABCDEFGHIJKLMNOP.â€</span></code></pre></td></tr></table></div></figure>


<p>If all of the associated values for a enumeration member are extracted as constants, or if all are extracted as variables, you can place a single var or let annotation before the member name, for brevity:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>switch productBarcode {
</span><span class='line'>case let .UPCA(numberSystem, identifier, check):
</span><span class='line'>    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
</span><span class='line'>case let .QRCode(productCode):
</span><span class='line'>    println("QR code with value of \(productCode).")
</span><span class='line'>}
</span><span class='line'>// prints "QR code with value of ABCDEFGHIJKLMNOP.â€</span></code></pre></td></tr></table></div></figure>


<h5>Raw Values</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum ASCIIControlCharacter: Character {
</span><span class='line'>    case Tab = "\t"
</span><span class='line'>    case LineFeed = "\n"
</span><span class='line'>    case CarriageReturn = "\r"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The raw value for a particular enumeration member is always the same. Associated values are set when you create a new constant or variable based on one of the enumerationâ€™s members, and can be different each time you do so.
æ³¨æ„ï¼Œå¦‚æœæ•´å‹è¢«ç”¨æ¥ä½œä¸ºraw values,å¦‚æœå…¶ä»–enumeration memberæ— å€¼ï¼Œåˆ™å…¶ä»–çš„å°†ä¼šè‡ªåŠ¨å¢é•¿</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Planet: Int {
</span><span class='line'>    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>.venus = 2,&hellip;ä¾æ­¤ç±»æ¨
ç”¨toRawæ–¹æ³•æ¥è·å–ä¸€ä¸ªenumeration memberçš„rawValueå€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let earthsOrder = Planet.Earth.toRaw()
</span><span class='line'>// earthsOrder is 3</span></code></pre></td></tr></table></div></figure>


<p>ç”¨fromRawæ¥è·å–æ‹¥æœ‰ä¸€ä¸ªraw valueçš„enumberation member</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let possiblePlanet = Planet.fromRaw(7)</span></code></pre></td></tr></table></div></figure>


<p>æ³¨æ„fromRawè¿”å›çš„æ˜¯optional value,æ‰€ä»¥å¯ä»¥åƒå¦‚ä¸‹è¿™ä¸ªå†™</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let positionToFind = 9
</span><span class='line'>if let somePlanet = Planet.fromRaw(positionToFind) {
</span><span class='line'>    switch somePlanet {
</span><span class='line'>    case .Earth:
</span><span class='line'>        println("Mostly harmless")
</span><span class='line'>    default:
</span><span class='line'>        println("Not a safe place for humans")
</span><span class='line'>    }
</span><span class='line'>} else {
</span><span class='line'>    println("There isn't a planet at position \(positionToFind)")
</span><span class='line'>}
</span><span class='line'>// prints "There isn't a planet at position 9â€</span></code></pre></td></tr></table></div></figure>


<h4>Classeså’ŒStructures</h4>

<p>Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures. In Swift, you define a class or a structure in a single file, and the external interface to that class or structure is automatically made available for other code to use.</p>

<h5>äºŒè€…çš„æ¯”è¾ƒ</h5>

<p>å…±åŒä¹‹å¤„</p>

<ul>
<li>Define properties to store values</li>
<li>Define methods to provide functionality</li>
<li>Define subscripts to provide access to their values using subscript syntax</li>
<li>Define initializers to set up their initial state</li>
<li>Be extended to expand their functionality beyond a default implementation</li>
<li><p>Conform to protocols to provide standard functionality of a certain kind
ç±»æœ‰çš„ï¼Œè€ŒStructureæœ¨æœ‰çš„</p></li>
<li><p>Inheritance enables one class to inherit the characteristics of another.</p></li>
<li>Type casting enables you to check and interpret the type of a class instance at runtime.</li>
<li>Deinitializers enable an instance of a class to free up any resources it has assigned.</li>
<li>Reference counting allows more than one reference to a class instance.
<code>æ³¨æ„</code>Structuresæ€»æ˜¯è¢«copiesçš„è€Œä¸ç”¨å¼•ç”¨è®¡æ•°

<h5>è¯­æ³•å®šä¹‰</h5></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Resolution {
</span><span class='line'>    var width = 0
</span><span class='line'>    var height = 0
</span><span class='line'>}
</span><span class='line'>class VideoMode {
</span><span class='line'>    var resolution = Resolution()
</span><span class='line'>    var interlaced = false
</span><span class='line'>    var frameRate = 0.0
</span><span class='line'>    var name: String?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Class and Structures Instances</h5>

<p>åˆ›å»ºå¯¹è±¡å®ä¾‹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someResolution = Resolution()
</span><span class='line'>let someVideoMode = VideoMode()</span></code></pre></td></tr></table></div></figure>


<h5>è®¿é—®å±æ€§</h5>

<p>å¯ä»¥å±‚å±‚è®¿é—®ï¼Œæ³¨æ„ä»¥ä¸‹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println("The width of someVideoMode is \(someVideoMode.resolution.width)")
</span><span class='line'>// prints "The width of someVideoMode is 0â€</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code>
Unlike Objective-C, Swift enables you to set sub-properties of a structure property directly. In the last example above, the width property of the resolution property of someVideoMode is set directly, without your needing to set the entire resolution property to a new value.</p>

<h5>Memberwise Initializers for Structure Types</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vga = Resolution(width: 640, height: 480)</span></code></pre></td></tr></table></div></figure>


<p>ä¸è¿‡ä¸åƒstructures,ç±»çš„å¯¹è±¡åˆå§‹åŒ–æ—¶æ²¡æœ‰è¿™æ ·é»˜è®¤çš„æˆå‘˜åˆå§‹åŒ–</p>

<h4>Structuså’ŒEnumerationsæ˜¯å€¼ç±»å‹</h4>

<p>ä¹Ÿå°±æ˜¯è¯´å½“å®ƒèµ‹ç»™ä¸€ä¸ªå˜é‡æˆ–ä¸“ç»™å‡½æ•°æ—¶ï¼Œå®ƒä»¬æ˜¯copyçš„
å®é™…ä¸Š,Swiftä¸­çš„æ‰€æœ‰åŸºæœ¬ç±»å‹ï¼Œæ•´å‹ï¼Œæµ®ç‚¹å‹ï¼Œboolå‹ï¼Œstringï¼Œarrayå’Œdictionaryéƒ½æ˜¯å€¼ç±»å‹ï¼Œä¸è¿‡å¹•åéƒ½ä»¥structureçš„å½¢å¼å‘ˆç°
demo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum CompassPoint {
</span><span class='line'>    case North, South, East, West
</span><span class='line'>}
</span><span class='line'>var currentDirection = CompassPoint.West
</span><span class='line'>let rememberedDirection = currentDirection
</span><span class='line'>currentDirection = .East
</span><span class='line'>if rememberedDirection == .West {
</span><span class='line'>    println("The remembered direction is still .West")
</span><span class='line'>}
</span><span class='line'>// prints "The remembered direction is still .Westâ€</span></code></pre></td></tr></table></div></figure>


<h4>ç±»æ˜¯å¼•ç”¨ç±»å‹</h4>

<p>æˆ‘ä»¬å¯ä»¥åˆ¤æ–­ä¸¤ä¸ªå˜é‡æ˜¯å¦æŒ‡å‘åŒä¸€ä¸ªç±»çš„å¯¹è±¡
å¯ä»¥ç”¨<code>===</code></p>

<h4>é€‰æ‹©ç±»æˆ–æ˜¯Structure</h4>

<p>structureæ€»æ˜¯æŒ‰å€¼ä¼ é€’ï¼Œclassæ€»æ˜¯æŒ‰å¼•ç”¨ä¼ é€’</p>

<h4>Assignment and Copy Behavior for Collection Types</h4>

<ul>
<li>Assignment and Copy Behavior for Dictionaries
å½“ä½ å°†ä¸€ä¸ªdictionaryèµ‹äºˆä¸€ä¸ªå¸¸é‡æˆ–å˜é‡ï¼Œæˆ–è€…å°†å®ƒä¼ å…¥å‡½æ•°æ—¶,dictionaryå°±è¢«copiedäº†
å¦‚æœkeys/valuesæ˜¯å€¼ç±»å‹,å®ƒä»¬ä¹Ÿåœ¨èµ‹å€¼æˆ–ä½œä¸ºå‚æ•°ä¼ å…¥å‡½æ•°æ—¶ä¹Ÿè¢«copyäº†ï¼Œä¸è¿‡å¦‚æœå®ƒä»¬æ˜¯å¼•ç”¨ç±»å‹çš„è¯ï¼Œåªæ˜¯å¼•ç”¨copyäº†ï¼Œå¯¹è±¡å¹¶æœªè¢«copyï¼Œè¿™ç§copyè§„åˆ™ä¸ä¸€ä¸ªstructureçš„propertiesä¸€æ ·ï¼Œå¦‚æœstructureè¢«copyçš„è¯</li>
<li>Assignment and Copy Behavior for Arrays
arrayçš„copyè§„åˆ™ä¸dictionaryçš„å¤§å¤§ä¸åŒ!arrayçš„copyåªå‘ç”Ÿåœ¨ä½ æ‰€åšçš„ä¿®æ”¹ä¼šæ”¹å˜arrayçš„å¤§å°çš„æ—¶å€™</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var a = [1, 2, 3]
</span><span class='line'>var b = a
</span><span class='line'>var c = a
</span><span class='line'>
</span><span class='line'>a[0] = 42
</span><span class='line'>println(a[0])
</span><span class='line'>// 42
</span><span class='line'>println(b[0])
</span><span class='line'>// 42
</span><span class='line'>println(c[0])
</span><span class='line'>// 42
</span><span class='line'>
</span><span class='line'>a.append(4)
</span><span class='line'>a[0] = 777
</span><span class='line'>println(a[0])
</span><span class='line'>// 777
</span><span class='line'>println(b[0])
</span><span class='line'>// 42
</span><span class='line'>println(c[0])
</span><span class='line'>// 42</span></code></pre></td></tr></table></div></figure>


<h4>ç¡®ä¿arrayæ˜¯å”¯ä¸€çš„</h4>

<p>é€šè¿‡å¯¹ä¸€ä¸ªarrayçš„å˜é‡è°ƒç”¨unshareæ–¹æ³•ï¼Œä½ èƒ½ç¡®ä¿è¿™ä¸ªè¿™ä¸ªå˜é‡å¯¹è¿™ä¸ªarrayçš„å”¯ä¸€æ€§ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœæœ‰å¤šä¸ªå˜é‡æŒ‡å‘åŒä¸€ä¸ªarray,å¦‚æœä½ å¯¹å…¶ä¸­çš„æŸä¸€ä¸ªå˜é‡è°ƒç”¨unshareæ–¹æ³•ï¼Œè¿™ä¸ªarrayå°±è¢«copyäº†,æ‰€ä»¥è¿™ä¸ªå˜é‡æœ‰æ­¤arrayçš„ç‹¬ç«‹æ‹·è´,ä¸è¿‡å¦‚æœåªæœ‰ä¸€ä¸ªå˜é‡æŒ‡å‘æ­¤array,åˆ™copyä¸ä¼šå‘ç”Ÿ
åœ¨ä»¥ä¸Šçš„ä¾‹å­ä¸­,å‡è®¾æˆ‘ä»¬è°ƒç”¨äº†å¦‚ä¸‹è¯­å¥</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b.unshare()</span></code></pre></td></tr></table></div></figure>


<p>åˆ™ç»“æœå¦‚ä¸‹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b[0] = -105
</span><span class='line'>println(a[0])
</span><span class='line'>// 777
</span><span class='line'>println(b[0])
</span><span class='line'>// -105
</span><span class='line'>println(c[0])
</span><span class='line'>// 42</span></code></pre></td></tr></table></div></figure>


<h5>Checking Whether Two Arrays Share the Same Elements</h5>

<p>Check whether two arrays or subarrays share the same storage and elements by comparing them with the identity operators (=== and !==).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if b === c {
</span><span class='line'>    println("b and c still share the same array elements.")
</span><span class='line'>} else {
</span><span class='line'>    println("b and c now refer to two independent sets of array elements.")
</span><span class='line'>}
</span><span class='line'>// prints "b and c now refer to two independent sets of array elements.</span></code></pre></td></tr></table></div></figure>


<p>Alternatively, use the identity operators to check whether two subarrays share the same elements. The example below compares two identical subarrays from b and confirms that they refer to the same elements:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if b[0...1] === b[0...1] {
</span><span class='line'>    println("These two subarrays share the same elements.")
</span><span class='line'>} else {
</span><span class='line'>    println("These two subarrays do not share the same elements.")
</span><span class='line'>}
</span><span class='line'>// prints "These two subarrays share the same elements.â€</span></code></pre></td></tr></table></div></figure>


<h5>å¼ºåˆ¶arrayçš„copy</h5>

<p>è°ƒç”¨arrayçš„copyæ–¹æ³•,è¿™ä¸ªæ–¹æ³•åªæ˜¯å¯¹arrayè¿›è¡Œ<code>æµ…å¤åˆ¶</code></p>

<h4>Properties</h4>

<p>Properties associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.</p>

<p>Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties.</p>

<p>In addition, you can define property observers to monitor changes in a propertyâ€™s value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</p>

<h5>Stored Properties</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct FixedLengthRange {
</span><span class='line'>    var firstValue: Int
</span><span class='line'>    let length: Int
</span><span class='line'>}
</span><span class='line'>var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
</span><span class='line'>// the range represents integer values 0, 1, and 2
</span><span class='line'>rangeOfThreeItems.firstValue = 6
</span><span class='line'>// the range now represents integer values 6, 7, and 8</span></code></pre></td></tr></table></div></figure>


<h5>Stored Properties of Constant Structure Instances</h5>

<p>å¦‚æœä½ åˆ›å»ºäº†ä¸€ä¸ªstructureçš„instanceï¼Œå¹¶ä¸”å°†è¿™ä¸ªinstanceèµ‹äºˆä¸€ä¸ªå¸¸é‡,ä½ ä¸èƒ½é€šè¿‡è¿™ä¸ªå¸¸é‡ä¿®æ”¹è¿™ä¸ªinstanceçš„properties,å³ä½¿å®ƒä»¬è¢«å£°æ˜ä¸ºvariable properties</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
</span><span class='line'>// this range represents integer values 0, 1, 2, and 3
</span><span class='line'>rangeOfFourItems.firstValue = 6
</span><span class='line'>// this will report an error, even thought firstValue is a variable property</span></code></pre></td></tr></table></div></figure>


<p>è¿™æ˜¯å› ä¸ºstructureæ˜¯å€¼ç±»å‹çš„ç¼˜æ•…,å¦‚æœä¸€ä¸ªå€¼ç±»å‹çš„instanceè¢«æ ‡è®°ä¸ºå¸¸é‡ï¼Œåˆ™å®ƒçš„propertyä¹Ÿæ˜¯
ä¸è¿‡classä¸æ­¤ä¸åŒï¼Œclassç…§æ ·å¯ä¿®æ”¹instanceçš„variable propertiesï¼Œæ—¢ç„¶å®ƒè¢«èµ‹å€¼ä¸ºä¸€ä¸ªå¸¸é‡</p>

<h5>Lazy Stored Properties</h5>

<p>A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the @lazy attribute before its declaration.</p>

<p><code>æ³¨æ„</code>
You must always declare a lazy property as a variable (with the var keyword), because its initial value may not be retrieved until after instance initialization completes. Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.</p>

<p>Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instanceâ€™s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.</p>

<p>The example below uses a lazy stored property to avoid unnecessary initialization of a complex class. This example defines two classes called DataImporter and DataManager, neither of which is shown in full:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class DataImporter {
</span><span class='line'>    /*
</span><span class='line'>    DataImporter is a class to import data from an external file.
</span><span class='line'>    The class is assumed to take a non-trivial amount of time to initialize.
</span><span class='line'>    */
</span><span class='line'>    var fileName = "data.txt"
</span><span class='line'>    // the DataImporter class would provide data importing functionality here
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class DataManager {
</span><span class='line'>    @lazy var importer = DataImporter()
</span><span class='line'>    var data = String[]()
</span><span class='line'>    // the DataManager class would provide data management functionality here
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>let manager = DataManager()
</span><span class='line'>manager.data += "Some data"
</span><span class='line'>manager.data += "Some more data"
</span><span class='line'>// the DataImporter instance for the importer property has not yet been created</span></code></pre></td></tr></table></div></figure>


<p>åªæœ‰åœ¨importerçš„propertyé¦–æ¬¡è¢«è®¿é—®çš„æ—¶å€™ï¼Œimporteræ‰è¢«åˆ›å»º</p>

<h4>Computed Properties</h4>

<p>ä¸»è¦ç”¨æ¥è®¡ç®—ï¼Œè€Œéå­˜å‚¨ï¼Œä¸»è¦æä¾›äº†ä¸€ä¸ªgetterå’Œä¸€ä¸ªå¯é€‰çš„setter</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>struct Rect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    var center: Point {
</span><span class='line'>    get {
</span><span class='line'>        let centerX = origin.x + (size.width / 2)
</span><span class='line'>        let centerY = origin.y + (size.height / 2)
</span><span class='line'>        return Point(x: centerX, y: centerY)
</span><span class='line'>    }
</span><span class='line'>    set(newCenter) {
</span><span class='line'>        origin.x = newCenter.x - (size.width / 2)
</span><span class='line'>        origin.y = newCenter.y - (size.height / 2)
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var square = Rect(origin: Point(x: 0.0, y: 0.0),
</span><span class='line'>    size: Size(width: 10.0, height: 10.0))
</span><span class='line'>let initialSquareCenter = square.center
</span><span class='line'>square.center = Point(x: 15.0, y: 15.0)
</span><span class='line'>println("square.origin is now at (\(square.origin.x), \(square.origin.y))")
</span><span class='line'>// prints "square.origin is now at (10.0, 10.0)</span></code></pre></td></tr></table></div></figure>


<h5>Shorthand Setter Declaration</h5>

<p>å¦‚æœä¸€ä¸ªcomputed propertyçš„setterå¹¶ä¸ä¸ºæ–°å€¼å®šä¹‰ä¸€ä¸ªåå­—,åˆ™æ–°å€¼çš„é»˜è®¤åä¸ºnewValue</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct AlternativeRect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    var center: Point {
</span><span class='line'>    get {
</span><span class='line'>        let centerX = origin.x + (size.width / 2)
</span><span class='line'>        let centerY = origin.y + (size.height / 2)
</span><span class='line'>        return Point(x: centerX, y: centerY)
</span><span class='line'>    }
</span><span class='line'>    set {
</span><span class='line'>        origin.x = newValue.x - (size.width / 2)
</span><span class='line'>        origin.y = newValue.y - (size.height / 2)
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>åªè¯»çš„Computed Properties
ä¸€ä¸ªcomputed propertyå¦‚æœåªæœ‰ä¸€ä¸ªgetterï¼Œè€Œæ²¡æœ‰setterï¼Œåˆ™å®ƒè¢«ç§°ä¸ºread-only computed property,å®ƒåªèƒ½è¿”å›ä¸€ä¸ªå€¼(é€šè¿‡.)è€Œä¸èƒ½èµ‹å€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Cuboid {
</span><span class='line'>    var width = 0.0, height = 0.0, depth = 0.0
</span><span class='line'>    var volume: Double {
</span><span class='line'>    return width * height * depth
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
</span><span class='line'>println("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
</span><span class='line'>// prints "the volume of fourByFiveByTwo is 40.0â€</span></code></pre></td></tr></table></div></figure>


<p> <code>æ³¨æ„</code>ä½ å¿…é¡»ç”¨varæ¥å£°æ˜computed properties(å³ä½¿æ˜¯åªè¯»çš„ä¹Ÿä¸€æ ·),letåªç”¨äºconstant properties</p>

<p> #####Property Observer
Property observers observe and respond to changes in a propertyâ€™s value. Property observers are called every time a propertyâ€™s value is set, even if the new value is the same as the propertyâ€™s current value.</p>

<p>You can add property observers to any stored properties you define, apart from lazy stored properties. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass</p>

<p><code>æ³¨æ„</code>
You donâ€™t need to define property observers for non-overridden computed properties, because you can observe and respond to changes to their value from directly within the computed propertyâ€™s setter.</p>

<p>you have the option to define either or both of these observers on a property:</p>

<ul>
<li>willSet is called just before the value is stored.</li>
<li>didSet is called immediately after the new value is stored.</li>
</ul>


<p>If you implement a willSet observer, it is passed the new property value as a constant parameter. You can specify a name for this parameter as part of your willSet implementation. If you choose not to write the parameter name and parentheses within your implementation, the parameter will still be made available with a default parameter name of newValue.</p>

<p>Similarly, if you implement a didSet observer, it will be passed a constant parameter containing the old property value. You can name the parameter if you wish, or use the default parameter name of oldValue.</p>

<p><code>æ³¨æ„</code>
willSet and didSet observers are not called when a property is first initialized. They are only called when the propertyâ€™s value is set outside of an initialization context.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class StepCounter {
</span><span class='line'>    var totalSteps: Int = 0 {
</span><span class='line'>    willSet(newTotalSteps) {
</span><span class='line'>        println("About to set totalSteps to \(newTotalSteps)")
</span><span class='line'>    }
</span><span class='line'>    didSet {
</span><span class='line'>        if totalSteps &gt; oldValue  {
</span><span class='line'>            println("Added \(totalSteps - oldValue) steps")
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let stepCounter = StepCounter()
</span><span class='line'>stepCounter.totalSteps = 200
</span><span class='line'>// About to set totalSteps to 200
</span><span class='line'>// Added 200 steps
</span><span class='line'>stepCounter.totalSteps = 360
</span><span class='line'>// About to set totalSteps to 360
</span><span class='line'>// Added 160 steps
</span><span class='line'>stepCounter.totalSteps = 896
</span><span class='line'>// About to set totalSteps to 896
</span><span class='line'>// Added 536 steps</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code>
If you assign a value to a property within its own didSet observer, the new value that you assign will replace the one that was just set</p>

<h4>å…¨å±€å’Œå±€éƒ¨å˜é‡</h4>

<p>The capabilities described above for computing and observing properties are also available to global variables and local variables.</p>

<p>The global and local variables you have encountered in previous chapters have all been stored variables. Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.</p>

<p>However, you can also define computed variables and define observers for stored variables, in either a global or local scope. Computed variables calculate rather than store a value, and are written in the same way as computed properties.</p>

<p><code>æ³¨æ„</code>
Global constants and variables are always computed lazily, in a similar manner to Lazy Stored Properties. Unlike lazy stored properties, global constants and variables do not need to be marked with the @lazy attribute.</p>

<p>Local constants and variables are never computed lazily.</p>

<h4>Type Properties</h4>

<p>For value types (that is, structures and enumerations), you can define stored and computed type properties. For classes, you can define computed type properties only.</p>

<p>Stored type properties for value types can be variables or constants. Computed type properties are always declared as variable properties, in the same way as
computed instance properties.</p>

<p><code>æ³¨æ„</code>
Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>

<h5>Type propertyè¯­æ³•</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct SomeStructure {
</span><span class='line'>    static var storedTypeProperty = "Some value."
</span><span class='line'>    static var computedTypeProperty: Int {
</span><span class='line'>    // return an Int value here
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>enum SomeEnumeration {
</span><span class='line'>    static var storedTypeProperty = "Some value."
</span><span class='line'>    static var computedTypeProperty: Int {
</span><span class='line'>    // return an Int value here
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>class SomeClass {
</span><span class='line'>    class var computedTypeProperty: Int {
</span><span class='line'>    // return an Int value here
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Querying and Setting Type Properties</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>println(SomeClass.computedTypeProperty)
</span><span class='line'>// prints "42"
</span><span class='line'> 
</span><span class='line'>println(SomeStructure.storedTypeProperty)
</span><span class='line'>// prints "Some value."
</span><span class='line'>SomeStructure.storedTypeProperty = "Another value."
</span><span class='line'>println(SomeStructure.storedTypeProperty)
</span><span class='line'>// prints "Another value."</span></code></pre></td></tr></table></div></figure>


<p>å†æ¥çœ‹ä¸€ä¸ªä¾‹å­</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct AudioChannel {
</span><span class='line'>    static let thresholdLevel = 10
</span><span class='line'>    static var maxInputLevelForAllChannels = 0
</span><span class='line'>    var currentLevel: Int = 0 {
</span><span class='line'>    didSet {
</span><span class='line'>        if currentLevel &gt; AudioChannel.thresholdLevel {
</span><span class='line'>            // cap the new audio level to the threshold level
</span><span class='line'>            currentLevel = AudioChannel.thresholdLevel
</span><span class='line'>        }
</span><span class='line'>        if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels {
</span><span class='line'>            // store this as the new overall maximum input level
</span><span class='line'>            AudioChannel.maxInputLevelForAllChannels = currentLevel
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code>
In the first of these two checks, the didSet observer sets currentLevel to a different value. This does not, however, cause the observer to be called again.</p>

<h4>æ–¹æ³•</h4>

<p>ä¸Cä¸åŒ,Swiftä¸­çš„Structureå’Œenumerationsèƒ½å®šä¹‰æ–¹æ³•</p>

<h5>Instance Methods</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Counter {
</span><span class='line'>    var count = 0
</span><span class='line'>    func increment() {
</span><span class='line'>        count++
</span><span class='line'>    }
</span><span class='line'>    func incrementBy(amount: Int) {
</span><span class='line'>        count += amount
</span><span class='line'>    }
</span><span class='line'>    func reset() {
</span><span class='line'>        count = 0
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let counter = Counter()
</span><span class='line'>// the initial counter value is 0
</span><span class='line'>counter.increment()
</span><span class='line'>// the counter's value is now 1
</span><span class='line'>counter.incrementBy(5)
</span><span class='line'>// the counter's value is now 6
</span><span class='line'>counter.reset()
</span><span class='line'>// the counter's value is now 0</span></code></pre></td></tr></table></div></figure>


<h5>Local and External Parameter Names for Methods</h5>

<p>Function parameters can have both a local name (for use within the functionâ€™s body) and an external name (for use when calling the function)</p>

<p>The same is true for method parameters, because methods are just functions that are associated with a type. However, the default behavior of local names and external names is <code>different</code> for functions and methods.</p>

<p>Specifically, Swift gives the first parameter name in a method a local parameter name by default, and gives the second and subsequent parameter names both local and external parameter names by default.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Counter {
</span><span class='line'>    var count: Int = 0
</span><span class='line'>    func incrementBy(amount: Int, numberOfTimes: Int) {
</span><span class='line'>        count += amount * numberOfTimes
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let counter = Counter()
</span><span class='line'>counter.incrementBy(5, numberOfTimes: 3)
</span><span class='line'>// counter value is now 15</span></code></pre></td></tr></table></div></figure>


<p>This default behavior effectively treats the method as if you had written a hash symbol (#) before the numberOfTimes parameter:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func incrementBy(amount: Int, #numberOfTimes: Int) {
</span><span class='line'>    count += amount * numberOfTimes
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Modifying External Parameter Name Behavior for Methods</h5>

<p>Sometimes itâ€™s useful to provide an external parameter name for a methodâ€™s first parameter, even though this is not the default behavior. You can either add an explicit external name yourself, or you can prefix the first parameterâ€™s name with a hash symbol to use the local name as an external name too.</p>

<p>Conversely, if you do not want to provide an external name for the second or subsequent parameter of a method, override the default behavior by using an underscore character (_) as an explicit external parameter name for that parameter.</p>

<h5>The self Property</h5>

<p>ä»¥ä¸Šçš„å¯ä»¥æ”¹æˆä»¥ä¸‹çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func increment() {
</span><span class='line'>    self.count++
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method.</p>

<p>The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance. In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way. You use the implicit self property to distinguish between the parameter name and the property name.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    func isToTheRightOfX(x: Double) -&gt; Bool {
</span><span class='line'>        return self.x &gt; x
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let somePoint = Point(x: 4.0, y: 5.0)
</span><span class='line'>if somePoint.isToTheRightOfX(1.0) {
</span><span class='line'>    println("This point is to the right of the line where x == 1.0")
</span><span class='line'>}
</span><span class='line'>// prints "This point is to the right of the line where x == 1.0â€</span></code></pre></td></tr></table></div></figure>


<h4>Modifying Value Types from Within Instance Methods</h4>

<p>Structures å’Œ enumerationséƒ½æ˜¯å€¼ç±»å‹,å€¼ç±»å‹çš„å±æ€§æ˜¯ä¸èƒ½åœ¨å®ƒçš„instanceæ–¹æ³•é‡Œä¿®æ”¹çš„,ä¸è¿‡ä½ å¯ä»¥åœ¨æ–¹æ³•åå‰åŠ mutatingæ¥å¯¹propertyè¿›è¡Œä¿®æ”¹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>        x += deltaX
</span><span class='line'>        y += deltaY
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var somePoint = Point(x: 1.0, y: 1.0)
</span><span class='line'>somePoint.moveByX(2.0, y: 3.0)
</span><span class='line'>println("The point is now at (\(somePoint.x), \(somePoint.y))")
</span><span class='line'>// prints "The point is now at (3.0, 4.0)â€</span></code></pre></td></tr></table></div></figure>


<p>The method can also assign a completely new instance to its implicit self property, and this new instance will replace the existing one when the method ends.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>        self = Point(x: x + deltaX, y: y + deltaY)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Mutating methods for enumerations can set the implicit self parameter to be a different member from the same enumeration:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum TriStateSwitch {
</span><span class='line'>    case Off, Low, High
</span><span class='line'>    mutating func next() {
</span><span class='line'>        switch self {
</span><span class='line'>        case Off:
</span><span class='line'>            self = Low
</span><span class='line'>        case Low:
</span><span class='line'>            self = High
</span><span class='line'>        case High:
</span><span class='line'>            self = Off
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var ovenLight = TriStateSwitch.Low
</span><span class='line'>ovenLight.next()
</span><span class='line'>// ovenLight is now equal to .High
</span><span class='line'>ovenLight.next()
</span><span class='line'>// ovenLight is now equal to .Off</span></code></pre></td></tr></table></div></figure>


<h4>Type Methods</h4>

<p> å¯¹class,åœ¨æ–¹æ³•çš„funcå…³é”®å­—å‰åŠ class,å¯¹structureå’Œenumeration,åœ¨funcå‰åŠ static</p>

<p>  <code>æ³¨æ„</code>:In Objective-C, you can define type-level methods only for Objective-C classes. In Swift, you can define type-level methods for all classes, structures, and enumerations. Each type method is explicitly scoped to the type it supports.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//å¯¹ç±»è€Œè¨€
</span><span class='line'>class SomeClass {
</span><span class='line'>    class func someTypeMethod() {
</span><span class='line'>        // type method implementation goes here
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>SomeClass.someTypeMethod()
</span><span class='line'>//å¯¹structureå’Œenumerationè€Œè¨€
</span></code></pre></td></tr></table></div></figure>


<p>åœ¨ä¸€ä¸ªtypeæ–¹æ³•çš„æ–¹æ³•ä½“é‡Œ,selfæŒ‡çš„æ˜¯typeæœ¬èº«</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct LevelTracker {
</span><span class='line'>    static var highestUnlockedLevel = 1
</span><span class='line'>    static func unlockLevel(level: Int) {
</span><span class='line'>        if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
</span><span class='line'>    }
</span><span class='line'>    static func levelIsUnlocked(level: Int) -&gt; Bool {
</span><span class='line'>        return level &lt;= highestUnlockedLevel
</span><span class='line'>    }
</span><span class='line'>    var currentLevel = 1
</span><span class='line'>    mutating func advanceToLevel(level: Int) -&gt; Bool {
</span><span class='line'>        if LevelTracker.levelIsUnlocked(level) {
</span><span class='line'>            currentLevel = level
</span><span class='line'>            return true
</span><span class='line'>        } else {
</span><span class='line'>            return false
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ä¸Playerç±»çš„ç»“åˆä½¿ç”¨</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Player {
</span><span class='line'>    var tracker = LevelTracker()
</span><span class='line'>    let playerName: String
</span><span class='line'>    func completedLevel(level: Int) {
</span><span class='line'>        LevelTracker.unlockLevel(level + 1)
</span><span class='line'>        tracker.advanceToLevel(level + 1)
</span><span class='line'>    }
</span><span class='line'>    init(name: String) {
</span><span class='line'>        playerName = name
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Subscripts</h4>

<p>You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript. Subscripts are not limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom typeâ€™s needs.</p>

<h5>Subscript Syntax</h5>

<p>ä¸åƒå…¶ä»–çš„instanceæ–¹æ³•,subscriptså¯ä»¥æ˜¯è¯»å†™çš„æˆ–æ˜¯åªè¯»çš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subscript(index: Int) -&gt; Int {
</span><span class='line'>    get {
</span><span class='line'>        // return an appropriate subscript value here
</span><span class='line'>    }
</span><span class='line'>    set(newValue) {
</span><span class='line'>        // perform a suitable setting action here
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>å¯¹äºåªè¯»çš„computed property,å¯¹åªè¯»çš„subscripts,æˆ‘ä»¬å¯ä»¥å»æ‰getå…³é”®å­—</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subscript(index: Int) -&gt; Int {
</span><span class='line'>    // return an appropriate subscript value here
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct TimesTable {
</span><span class='line'>    let multiplier: Int
</span><span class='line'>    subscript(index: Int) -&gt; Int {
</span><span class='line'>        return multiplier * index
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let threeTimesTable = TimesTable(multiplier: 3)
</span><span class='line'>println("six times three is \(threeTimesTable[6])")
</span><span class='line'>// prints "six times three is 18â€</span></code></pre></td></tr></table></div></figure>


<h5>Subscript Options</h5>

<p>Subscriptsèƒ½æ¥æ”¶ä»»æ„æ•°é‡çš„å‚æ•°ï¼Œå¹¶ä¸”è¿™äº›å‚æ•°å¯ä»¥æ˜¯ä»»æ„ç±»å‹çš„
Subscriptsèƒ½æ¥æ”¶variable å‚æ•° å’Œ variadic å‚æ•°,ä½†ä¸èƒ½ä½¿ç”¨in-outå‚æ•°æˆ–æ˜¯ä¸ºå‚æ•°æä¾›é»˜è®¤å€¼</p>

<p>A class or structure can provide as many subscript implementations as it needs, and the appropriate subscript to be used will be inferred based on the types of the value or values that are contained within the subscript braces at the point that the subscript is used. This definition of multiple subscripts is known as subscript overloading.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Matrix {
</span><span class='line'>    let rows: Int, columns: Int
</span><span class='line'>    var grid: Double[]
</span><span class='line'>    init(rows: Int, columns: Int) {
</span><span class='line'>        self.rows = rows
</span><span class='line'>        self.columns = columns
</span><span class='line'>        grid = Array(count: rows * columns, repeatedValue: 0.0)
</span><span class='line'>    }
</span><span class='line'>    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
</span><span class='line'>        return row &gt;= 0 && row &lt; rows && column &gt;= 0 && column &lt; columns
</span><span class='line'>    }
</span><span class='line'>    subscript(row: Int, column: Int) -&gt; Double {
</span><span class='line'>        get {
</span><span class='line'>            assert(indexIsValidForRow(row, column: column), "Index out of range")
</span><span class='line'>            return grid[(row * columns) + column]
</span><span class='line'>        }
</span><span class='line'>        set {
</span><span class='line'>            assert(indexIsValidForRow(row, column: column), "Index out of range")
</span><span class='line'>            grid[(row * columns) + column] = newValue
</span><span class='line'>        }
</span><span class='line'>     }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var matrix = Matrix(rows: 2, columns: 2)
</span><span class='line'>
</span><span class='line'>matrix[0, 1] = 1.5
</span><span class='line'>matrix[1, 0] = 3.2
</span><span class='line'>
</span><span class='line'>let someValue = matrix[2, 2]
</span><span class='line'>// this triggers an assert, because [2, 2] is outside of the matrix bounds
</span></code></pre></td></tr></table></div></figure>


<h4>ç»§æ‰¿</h4>

<p>åªæœ‰ç±»èƒ½ç»§æ‰¿
Classes can also add property observers to inherited properties in order to be notified when the value of a property changes. Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Vehicle {
</span><span class='line'>    var numberOfWheels: Int
</span><span class='line'>    var maxPassengers: Int
</span><span class='line'>    func description() -&gt; String {
</span><span class='line'>        return "\(numberOfWheels) wheels; up to \(maxPassengers) passengers"
</span><span class='line'>    }
</span><span class='line'>    init() {
</span><span class='line'>        numberOfWheels = 0
</span><span class='line'>        maxPassengers = 1
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let someVehicle = Vehicle()
</span></code></pre></td></tr></table></div></figure>


<h5>Subclassing</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Bicycle: Vehicle {
</span><span class='line'>    init() {
</span><span class='line'>        super.init()
</span><span class='line'>        numberOfWheels = 2
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let bicycle = Bicycle()
</span><span class='line'>println("Bicycle: \(bicycle.description())")
</span><span class='line'>// Bicycle: 2 wheels; up to 1 passengers</span></code></pre></td></tr></table></div></figure>


<p>The Bicycle class also defines an initializer to set up its tailored characteristics. The initializer for Bicycle calls super.init(), the initializer for the Bicycle classâ€™s superclass, Vehicle, and ensures that all of the inherited properties are initialized by Vehicle before Bicycle tries to modify them.</p>

<p><code>æ³¨æ„</code>:initializers are not inherited by default in Swift</p>

<h4>Overriding</h4>

<p>A subclass can provide its own custom implementation of an instance method, class method, instance property, or subscript that it would otherwise inherit from a superclass. This is known as overriding.
å­ç±»é‡å†™çˆ¶ç±»çš„æ–¹æ³•å¿…é¡»åŠ override</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Car: Vehicle {
</span><span class='line'>    var speed: Double = 0.0
</span><span class='line'>    init() {
</span><span class='line'>        super.init()
</span><span class='line'>        maxPassengers = 5
</span><span class='line'>        numberOfWheels = 4
</span><span class='line'>    }
</span><span class='line'>    override func description() -&gt; String {
</span><span class='line'>        return super.description() + "; "
</span><span class='line'>            + "traveling at \(speed) mph"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let car = Car()
</span><span class='line'>println("Car: \(car.description())")
</span><span class='line'>// Car: 4 wheels; up to 5 passengers; traveling at 0.0 mph</span></code></pre></td></tr></table></div></figure>


<h5>Overriding Properties</h5>

<p>You can override an inherited instance or class property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes</p>

<p>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.</p>

<p>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.</p>

<p><code>æ³¨æ„</code>
If you provide a setter as part of a property override, you must also provide a getter for that override. If you donâ€™t want to modify the inherited propertyâ€™s value within the overriding getter, you can simply pass through the inherited value by returning super.someProperty from the getter, as in the SpeedLimitedCar example below.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SpeedLimitedCar: Car {
</span><span class='line'>    override var speed: Double  {
</span><span class='line'>    get {
</span><span class='line'>        return super.speed
</span><span class='line'>    }
</span><span class='line'>    set {
</span><span class='line'>        super.speed = min(newValue, 40.0)
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let limitedCar = SpeedLimitedCar()
</span><span class='line'>limitedCar.speed = 60.0
</span><span class='line'>println("SpeedLimitedCar: \(limitedCar.description())")
</span><span class='line'>// SpeedLimitedCar: 4 wheels; up to 5 passengers; traveling at 40.0 mph</span></code></pre></td></tr></table></div></figure>


<h5>Overriding Property Observers</h5>

<p>You can use property overriding to add property observers to an inherited property. This enables you to be notified when the value of the inherited property changes, regardless of how that property was originally implemented</p>

<p><code>æ³¨æ„</code></p>

<p>You cannot add property observers to inherited constant stored properties or inherited read-only computed properties. The value of these properties cannot be set, and so it is not appropriate to provide a willSet or didSet implementation as part of an override.</p>

<p>Note also that you cannot provide both an overriding setter and an overriding property observer. If you want to observe changes to a propertyâ€™s value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class AutomaticCar: Car {
</span><span class='line'>    var gear = 1
</span><span class='line'>    override var speed: Double {
</span><span class='line'>    didSet {
</span><span class='line'>        gear = Int(speed / 10.0) + 1
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>    override func description() -&gt; String {
</span><span class='line'>        return super.description() + " in gear \(gear)"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let automatic = AutomaticCar()
</span><span class='line'>automatic.speed = 35.0
</span><span class='line'>println("AutomaticCar: \(automatic.description())")
</span><span class='line'>// AutomaticCar: 4 wheels; up to 5 passengers; traveling at 35.0 mph in gear 4</span></code></pre></td></tr></table></div></figure>


<h5>Preventing Overrides</h5>

<p>æˆ‘ä»¬å¯ä»¥åœ¨æ–¹æ³•ï¼Œå±æ€§æˆ–subscriptå‰åŠ @finalæ¥é˜»æ­¢å®ƒä»¬è¢«ç»§æ‰¿</p>

<p>Methods, properties or subscripts that you add to a class in an extension can also be marked as final within the extensionâ€™s definition.</p>

<p>ä½ ä¹Ÿå¯ä»¥ç”¨@finalæ¥é˜»æ­¢ç±»è¢«ç»§æ‰¿</p>

<h4>åˆå§‹åŒ–</h4>

<h5>Setting Initial Values for Stored Properties</h5>

<p>Classes and structures must set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties cannot be left in an indeterminate state.</p>

<p>æˆ‘ä»¬å¯ä»¥åœ¨initializerå†…ä¸ºä¸€ä¸ªstored propertyè®¾ç½®ä¸€ä¸ªåˆå§‹å€¼,æˆ–åœ¨å®ƒçš„å®šä¹‰ä¸­ä¸ºå…¶æŒ‡å®šä¸€ä¸ªé»˜è®¤å€¼
Stored properties cannot be left in an indeterminate state.</p>

<p><code>æ³¨æ„</code>
When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers.</p>

<h5>Initializers</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Fahrenheit {
</span><span class='line'>    var temperature: Double
</span><span class='line'>    init() {
</span><span class='line'>        temperature = 32.0
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var f = Fahrenheit()
</span><span class='line'>println("The default temperature is \(f.temperature)Â° Fahrenheit")
</span><span class='line'>// prints "The default temperature is 32.0Â° Fahrenheit"</span></code></pre></td></tr></table></div></figure>


<h5>Default Property Values</h5>

<p><code>æ³¨æ„</code>
If a property always takes the same initial value, provide a default value rather than setting a value within an initializer. The end result is the same, but the default value ties the propertyâ€™s initialization more closely to its declaration. It makes for shorter, clearer initializers and <code>enables you to infer the type of the property from its default value</code>. The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.</p>

<p>ä¹‹å‰çš„demoå¯ä»¥æ¢æˆä»¥ä¸‹å½¢å¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Fahrenheit {
</span><span class='line'>    var temperature = 32.0
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Customizing Initialization</h5>

<p>You can customize the initialization process with input parameters and optional property types,or by modifying constant properties during initialization</p>

<ul>
<li>Initialization Parameters
You can provide initialization parameters as part of an initializerâ€™s definition, to define the types and names of values that customize the initialization process.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Celsius {
</span><span class='line'>    var temperatureInCelsius: Double = 0.0
</span><span class='line'>    init(fromFahrenheit fahrenheit: Double) {
</span><span class='line'>        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
</span><span class='line'>    }
</span><span class='line'>    init(fromKelvin kelvin: Double) {
</span><span class='line'>        temperatureInCelsius = kelvin - 273.15
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
</span><span class='line'>// boilingPointOfWater.temperatureInCelsius is 100.0
</span><span class='line'>let freezingPointOfWater = Celsius(fromKelvin: 273.15)
</span><span class='line'>// freezingPointOfWater.temperatureInCelsius is 0.0</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Local and External Parameter Names
As with function and method parameters, initialization parameters can have both a local name for use within the initializerâ€™s body and an external name for use when calling the initializer.</li>
</ul>


<p>However, initializers do not have an identifying function name before their parentheses in the way that functions and methods do. Therefore, the names and types of an initializerâ€™s parameters play a particularly important role in identifying which initializer should be called. Because of this,<code>Swift provides an automatic external name for every parameter in an initializer if you donâ€™t provide an external name yourself</code>.</p>

<p><code>æ³¨æ„</code>
If you do not want to provide an external name for a parameter in an initializer, provide an underscore (_) as an explicit external name for that parameter to override the default behavior described above.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Color {
</span><span class='line'>    let red = 0.0, green = 0.0, blue = 0.0
</span><span class='line'>    init(red: Double, green: Double, blue: Double) {
</span><span class='line'>        self.red   = red
</span><span class='line'>        self.green = green
</span><span class='line'>        self.blue  = blue
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code>
It is not possible to call this initializer without using the external names. External names must always be used in an intializer if they are defined, and omitting them is a compile-time error:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let veryGreen = Color(0.0, 1.0, 0.0)
</span><span class='line'>// this reports a compile-time error - external names are required</span></code></pre></td></tr></table></div></figure>


<h5>Optional Property Types</h5>

<p>Properties of optional type are automatically initialized with a value of nil, indicating that the property is deliberately intended to have â€œno value yetâ€ during initialization.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SurveyQuestion {
</span><span class='line'>    var text: String
</span><span class='line'>    var response: String?
</span><span class='line'>    init(text: String) {
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    func ask() {
</span><span class='line'>        println(text)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
</span><span class='line'>cheeseQuestion.ask()
</span><span class='line'>// prints "Do you like cheese?"
</span><span class='line'>cheeseQuestion.response = "Yes, I do like cheese.â€</span></code></pre></td></tr></table></div></figure>


<h5>Modifying Constant Properties During Initialization</h5>

<p>You can modify the value of a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes.</p>

<p><code>æ³¨æ„</code>
For class instances, a constant property can only be modified during initialization by the class that introduces it. It cannot be modified by a subclass.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SurveyQuestion {
</span><span class='line'>    let text: String
</span><span class='line'>    var response: String?
</span><span class='line'>    init(text: String) {
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    func ask() {
</span><span class='line'>        println(text)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let beetsQuestion = SurveyQuestion(text: "How about beets?")
</span><span class='line'>beetsQuestion.ask()
</span><span class='line'>// prints "How about beets?"
</span><span class='line'>beetsQuestion.response = "I also like beets. (But not with cheese.)â€</span></code></pre></td></tr></table></div></figure>


<h5>Default Initializers</h5>

<p>Swift provides a default initializer for any structure or base class that provides default values for all of its properties and does not provide at least one initializer itself. The default initializer simply creates a new instance with all of its properties set to their default values.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ShoppingListItem {
</span><span class='line'>    var name: String?
</span><span class='line'>    var quantity = 1
</span><span class='line'>    var purchased = false
</span><span class='line'>}
</span><span class='line'>var item = ShoppingListItem()</span></code></pre></td></tr></table></div></figure>


<h5>Memberwise Initializers for Structure Types</h5>

<p>In addition to the default initializers mentioned above, structure types automatically receive a memberwise initializer if they provide default values for all of their stored properties and do not define any of their own custom initializers.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>let twoByTwo = Size(width: 2.0, height: 2.0)</span></code></pre></td></tr></table></div></figure>


<h5>Initializer Delegation for Value Types</h5>

<p>Initializers can call other initializers to perform part of an instanceâ€™s initialization. This process, known as initializer delegation, avoids duplicating code across multiple initializers.</p>

<p>å¯¹äºå€¼ç±»å‹è€Œè¨€,å®ƒä»¬çš„initializer delegationç›¸å¯¹æ¯”è¾ƒç®€å•,because they can only delegate to another initializer that they provide themselves.
è€Œç±»åˆ™å¯ä»¥ç»§æ‰¿,This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization.</p>

<p>For value types, you use self.init to refer to other initializers from the same value type when writing your own custom initializers. You can only call self.init from within an initializer.</p>

<p>Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise structure initializer, if it is a structure) for that type.</p>

<p><code>æ³¨æ„</code>
If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value typeâ€™s original implementation.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct Rect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    init() {}
</span><span class='line'>    init(origin: Point, size: Size) {
</span><span class='line'>        self.origin = origin
</span><span class='line'>        self.size = size
</span><span class='line'>    }
</span><span class='line'>    init(center: Point, size: Size) {
</span><span class='line'>        let originX = center.x - (size.width / 2)
</span><span class='line'>        let originY = center.y - (size.height / 2)
</span><span class='line'>        self.init(origin: Point(x: originX, y: originY), size: size)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let basicRect = Rect()
</span><span class='line'>// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)
</span><span class='line'>
</span><span class='line'>let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
</span><span class='line'>    size: Size(width: 5.0, height: 5.0))
</span><span class='line'>// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)
</span><span class='line'>
</span><span class='line'>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
</span><span class='line'>    size: Size(width: 3.0, height: 3.0))
</span><span class='line'>// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></code></pre></td></tr></table></div></figure>


<p>The init(center:size:) initializer could have assigned the new values of origin and size to the appropriate properties itself. However, it is more convenient (and clearer in intent) for the init(center:size:) initializer to take advantage of an existing initializer that already provides exactly that functionality.</p>

<h4>ç±»ç»§æ‰¿å’Œåˆå§‹åŒ–</h4>

<p>All of a classâ€™s stored propertiesâ€”including any properties the class inherits from its superclassâ€”must be assigned an initial value during initialization.</p>

<p>Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value. These are known as designated initializers and convenience initializers</p>

<h5>Designated Initializers and Convenience Initializers</h5>

<p>Designated initializers are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</p>

<p>Classes tend to have very few designated initializers, and it is quite common for a class to have only one. Designated initializers are â€œfunnelâ€ points through which initialization takes place, and through which the initialization process continues up the superclass chain.</p>

<p>Every class must have at least one designated initializer. In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass</p>

<p>Convenience initializers are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializerâ€™s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</p>

<p>You do not have to provide convenience initializers if your class does not require them. Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent</p>

<h5>Initializer Chaining</h5>

<p>To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:</p>

<ul>
<li>è§„åˆ™1
Designated initializers must call a designated initializer from their immediate superclass.</li>
<li>è§„åˆ™2
Convenience initializers must call another initializer available in the same class.</li>
<li>è§„åˆ™3
Convenience initializers must ultimately end up calling a designated initializer.</li>
</ul>


<p>A simple way to remember this is:</p>

<ul>
<li>Designated initializers must always delegate up.</li>
<li>Convenience initializers must always delegate across.
å…³ç³»å¯ä»¥ç”¨ä»¥ä¸‹ä¸¤å¼ å›¾è¡¨ç¤º
<img src="/images/2014/8/initialize.png">
<img src="/images/2014/8/complex_initialize.png"></li>
</ul>


<h5>Two-Phase Initialization</h5>

<p>Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</p>

<p>Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly.</p>

<p>Swiftâ€™s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:</p>

<ul>
<li><p>Safety check 1
A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.</p></li>
<li><p>Safety check 2
A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesnâ€™t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</p></li>
<li>Safety check 3
A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class). If it doesnâ€™t, the new value the convenience initializer assigns will be overwritten by its own classâ€™s designated initializer.</li>
<li>Safety check 4
An initializer cannot call any instance methods, read the values of any instance properties, or refer to self as a value until after the first phase of initialization is complete.</li>
</ul>


<p>The class instance is not fully valid until the first phase ends. Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.</p>

<p>Hereâ€™s how two-phase initialization plays out, based on the four safety checks above:</p>

<ol>
<li>Phase 1

<ul>
<li>A designated or convenience initializer is called on a class.</li>
<li>Memory for a new instance of that class is allocated. The memory is not yet initialized.</li>
<li>A designated initializer for that class confirms that all stored properties introduced by that class have a value. The memory for these stored properties is now initialized.</li>
<li>The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.</li>
<li>This continues up the class inheritance chain until the top of the chain is reached.</li>
<li>Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instanceâ€™s memory is considered to be fully initialized, and phase 1 is complete.</li>
</ul>
</li>
<li>Phase 2

<ul>
<li>Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access self and can modify its properties, call its instance methods, and so on.</li>
<li>Finally, any convenience initializers in the chain have the option to customize the instance and to work with self.

<h4>Initializer Inheritance and Overriding</h4>

<p>Unlike subclasses in Objective-C, Swift subclasses do not not inherit their superclass initializers by default.</p></li>
</ul>
</li>
</ol>


<p>If you want your custom subclass to present one or more of the same initializers as its superclassâ€”perhaps to perform some customization during initializationâ€”you can provide an overriding implementation of the same initializer within your custom subclass.</p>

<p>If the initializer you are overriding is a designated initializer, you can override its implementation in your subclass and call the superclass version of the initializer from within your overriding version.</p>

<p>If the initializer you are overriding is a convenience initializer, your override must call another designated initializer from its own subclass</p>

<p><code>æ³¨æ„</code></p>

<pre><code>Unlike methods, properties, and subscripts, you do not need to write the override keyword when overriding an initializer.
</code></pre>

<h5>Automatic Initializer Inheritance</h5>

<p>Subclasses do not not inherit their superclass initializers by default. However, superclass initializers are automatically inherited if certain conditions are met. In practice, this means that you do not need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it is safe to do so.</p>

<p>Assuming that you provide default values for <code>any</code> new properties you introduce in a subclass, the following two rules apply:</p>

<ul>
<li><p>Rule 1</p>

<p>  If your subclass doesnâ€™t define any designated initializers, it automatically inherits all of its superclass designated initializers.</p></li>
<li><p>Rule 2</p>

<p>  If your subclass provides an implementation of <code>all</code> of its superclass designated initializersâ€”either by inheriting them as per rule 1, or by providing a custom implementation as part of its definitionâ€”then it automatically inherits all of the superclass convenience initializers.</p></li>
</ul>


<p>These rules apply even if your subclass adds further convenience initializers.</p>

<p><code>æ³¨æ„</code></p>

<pre><code>A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.
</code></pre>

<h5>Syntax for Designated and Convenience Initializers</h5>

<ul>
<li>Designated initializers</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init(parameters) {
</span><span class='line'>  statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Convenience initializers</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>convenience init(parameters) {
</span><span class='line'>    statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Designated and Convenience Initializers in Action</h5>

<p>ä»¥ä¸‹æ˜¾ç¤ºäº†designated initializers, convenience initializers, and automatic initializer inheritance in action,å®šä¹‰äº†ä¸‰ä¸ªç±»Food,RecipeIngredient,ShoppingListItemçš„ç»§æ‰¿å…³ç³»</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//Food
</span><span class='line'>class Food {
</span><span class='line'>    var name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>    convenience init() {
</span><span class='line'>        self.init(name: "[Unnamed]")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//Designated initializer
</span><span class='line'>let namedMeat = Food(name: "Bacon")
</span><span class='line'>// namedMeat's name is "Baconâ€
</span><span class='line'>
</span><span class='line'>let mysteryMeat = Food()</span></code></pre></td></tr></table></div></figure>


<p>Foodçš„initializer chainå›¾</p>

<p><img src="/images/2014/8/initialize.png"></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RecipeIngredient: Food {
</span><span class='line'>    var quantity: Int
</span><span class='line'>    init(name: String, quantity: Int) {
</span><span class='line'>        self.quantity = quantity
</span><span class='line'>        super.init(name: name)
</span><span class='line'>    }
</span><span class='line'>    convenience init(name: String) {
</span><span class='line'>        self.init(name: name, quantity: 1)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let oneMysteryItem = RecipeIngredient()
</span><span class='line'>let oneBacon = RecipeIngredient(name: "Bacon")
</span><span class='line'>let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)
</span></code></pre></td></tr></table></div></figure>


<p>å›¾ç¤ºå¦‚ä¸‹</p>

<p><img src="/images/2014/8/recipeIngredient.png"></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ShoppingListItem: RecipeIngredient {
</span><span class='line'>    var purchased = false
</span><span class='line'>    var description: String {
</span><span class='line'>    var output = "\(quantity) x \(name.lowercaseString)"
</span><span class='line'>        output += purchased ? " âœ”" : " âœ˜"
</span><span class='line'>        return output
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ä»¥ä¸Šä¸‰ä¸ªç±»çš„ç»§æ‰¿å›¾</p>

<p><img src="/images/2014/8/foodchaining.png">
You can use all three of the inherited initializers to create a new ShoppingListItem instance:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>â€œvar breakfastList = [
</span><span class='line'>    ShoppingListItem(),
</span><span class='line'>    ShoppingListItem(name: "Bacon"),
</span><span class='line'>    ShoppingListItem(name: "Eggs", quantity: 6),
</span><span class='line'>]
</span><span class='line'>breakfastList[0].name = "Orange juice"
</span><span class='line'>breakfastList[0].purchased = true
</span><span class='line'>for item in breakfastList {
</span><span class='line'>    println(item.description)
</span><span class='line'>}
</span><span class='line'>// 1 x orange juice âœ”
</span><span class='line'>// 1 x bacon âœ˜
</span><span class='line'>// 6 x eggs âœ˜â€</span></code></pre></td></tr></table></div></figure>


<h5>ç”¨closureæˆ–æ˜¯å‡½æ•°æ¥è®¾ç½®ä¸€ä¸ªé»˜è®¤å€¼</h5>

<p>If a stored propertyâ€™s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that propertyï¼ŒWhenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the propertyâ€™s default value.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeClass {
</span><span class='line'>    let someProperty: SomeType = {
</span><span class='line'>        // create a default value for someProperty inside this closure
</span><span class='line'>        // someValue must be of the same type as SomeType
</span><span class='line'>        return someValue
</span><span class='line'>        }()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Note that the closureâ€™s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately</p>

<p><code>æ³¨æ„</code></p>

<pre><code>If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed. This means that you cannot access any other property values from within your closure, even if those properties have default values. You also cannot use the implicit self property, or call any of the instanceâ€™s methods.
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Checkerboard {
</span><span class='line'>    let boardColors: Bool[] = {
</span><span class='line'>        var temporaryBoard = Bool[]()
</span><span class='line'>        var isBlack = false
</span><span class='line'>        for i in 1...10 {
</span><span class='line'>            for j in 1...10 {
</span><span class='line'>                temporaryBoard.append(isBlack)
</span><span class='line'>                isBlack = !isBlack
</span><span class='line'>            }
</span><span class='line'>            isBlack = !isBlack
</span><span class='line'>        }
</span><span class='line'>        return temporaryBoard
</span><span class='line'>        }()
</span><span class='line'>    func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
</span><span class='line'>        return boardColors[(row * 10) + column]
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let board = Checkerboard()
</span><span class='line'>println(board.squareIsBlackAtRow(0, column: 1))
</span><span class='line'>// prints "true"
</span><span class='line'>println(board.squareIsBlackAtRow(9, column: 9))
</span><span class='line'>// prints "falseâ€</span></code></pre></td></tr></table></div></figure>


<h4>Deinitialization</h4>

<p>A deinitializer is called immediately before a class instance is deallocated. You write deinitializers with the <code>deinit</code> keyword, similar to how intializers are written with the init keyword. <code>Deinitializers are only available on class types</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>deinit {
</span><span class='line'>    // perform the deinitialization
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>æ¥çœ‹ä¸€ä¸ªdemo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Bank {
</span><span class='line'>    static var coinsInBank = 10_000
</span><span class='line'>    static func vendCoins(var numberOfCoinsToVend: Int) -&gt; Int {
</span><span class='line'>        numberOfCoinsToVend = min(numberOfCoinsToVend, coinsInBank)
</span><span class='line'>        coinsInBank -= numberOfCoinsToVend
</span><span class='line'>        return numberOfCoinsToVend
</span><span class='line'>    }
</span><span class='line'>    static func receiveCoins(coins: Int) {
</span><span class='line'>        coinsInBank += coins
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Player {
</span><span class='line'>    var coinsInPurse: Int
</span><span class='line'>    init(coins: Int) {
</span><span class='line'>        coinsInPurse = Bank.vendCoins(coins)
</span><span class='line'>    }
</span><span class='line'>    func winCoins(coins: Int) {
</span><span class='line'>        coinsInPurse += Bank.vendCoins(coins)
</span><span class='line'>    }
</span><span class='line'>    deinit {
</span><span class='line'>        Bank.receiveCoins(coinsInPurse)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var playerOne: Player? = Player(coins: 100)
</span><span class='line'>println("A new player has joined the game with \(playerOne!.coinsInPurse) coins")
</span><span class='line'>// prints "A new player has joined the game with 100 coins"
</span><span class='line'>println("There are now \(Bank.coinsInBank) coins left in the bank")
</span><span class='line'>// prints "There are now 9900 coins left in the bankâ€
</span><span class='line'>
</span><span class='line'>playerOne!.winCoins(2_000)
</span><span class='line'>println("PlayerOne won 2000 coins & now has \(playerOne!.coinsInPurse) coins")
</span><span class='line'>// prints "PlayerOne won 2000 coins & now has 2100 coins"
</span><span class='line'>println("The bank now only has \(Bank.coinsInBank) coins left")
</span><span class='line'>// prints "The bank now only has 7900 coins leftâ€
</span><span class='line'>
</span><span class='line'>playerOne = nil
</span><span class='line'>println("PlayerOne has left the game")
</span><span class='line'>// prints "PlayerOne has left the game"
</span><span class='line'>println("The bank now has \(Bank.coinsInBank) coins")
</span><span class='line'>// prints "The bank now has 10000 coinsâ€</span></code></pre></td></tr></table></div></figure>


<h4>ARC</h4>

<p>Swiftä¹Ÿç”¨arc,ä¸è¿‡ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯arcåªé€‚ç”¨äºç±»å¯¹è±¡,ä¸é€‚ç”¨äºStructureå’Œenumerationè¿™ç±»å€¼ç±»å‹</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        println("\(name) is being initialized")
</span><span class='line'>    }
</span><span class='line'>    deinit {
</span><span class='line'>        println("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>reference1 = Person(name: "John Appleseed")
</span><span class='line'>// prints "John Appleseed is being initialized"
</span><span class='line'>
</span><span class='line'>reference2 = reference1
</span><span class='line'>reference3 = reference1
</span><span class='line'>reference1 = nil
</span><span class='line'>reference2 = nil
</span><span class='line'>
</span><span class='line'>reference3 = nil
</span><span class='line'>// prints "John Appleseed is being deinitializedâ€
</span></code></pre></td></tr></table></div></figure>


<p>ç±»å¯¹è±¡ä¹‹é—´çš„å¾ªç¯å¼•ç”¨
You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references
æˆ‘ä»¬æ¥çœ‹çœ‹å¾ªç¯å¼•ç”¨æ˜¯å¦‚ä½•é€ æˆçš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>    var apartment: Apartment?
</span><span class='line'>    deinit { println("\(name) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class Apartment {
</span><span class='line'>    let number: Int
</span><span class='line'>    init(number: Int) { self.number = number }
</span><span class='line'>    var tenant: Person?
</span><span class='line'>    deinit { println("Apartment #\(number) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var john: Person?
</span><span class='line'>var number73: Apartment?
</span><span class='line'>
</span><span class='line'>john = Person(name: "John Appleseed")
</span><span class='line'>number73 = Apartment(number: 73)
</span><span class='line'>
</span><span class='line'>john!.apartment = number73
</span><span class='line'>number73!.tenant = john
</span></code></pre></td></tr></table></div></figure>


<p>ç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹ cycle retainå›¾</p>

<p><img src="/images/2014/8/cycleretain.png"></p>

<h4>å¦‚ä½•è§£å†³</h4>

<p>Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.</p>

<p>Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization.</p>

<ul>
<li>Weak References</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>    var apartment: Apartment?
</span><span class='line'>    deinit { println("\(name) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class Apartment {
</span><span class='line'>    let number: Int
</span><span class='line'>    init(number: Int) { self.number = number }
</span><span class='line'>    weak var tenant: Person?
</span><span class='line'>    deinit { println("Apartment #\(number) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var john: Person?
</span><span class='line'>var number73: Apartment?
</span><span class='line'> 
</span><span class='line'>john = Person(name: "John Appleseed")
</span><span class='line'>number73 = Apartment(number: 73)
</span><span class='line'> 
</span><span class='line'>john!.apartment = number73
</span><span class='line'>number73!.tenant = john
</span></code></pre></td></tr></table></div></figure>


<p>æˆ‘ä»¬æ¥çœ‹çœ‹å¼•ç”¨å›¾</p>

<p><img src="/images/2014/8/weakref.png"></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = nil
</span><span class='line'>// prints "John Appleseed is being deinitializedâ€
</span><span class='line'>number73 = nil
</span><span class='line'>// prints "Apartment #73 is being deinitializedâ€
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Unowned References
Unlike a weak reference, an unowned reference is assumed to always have a value, Because of this, an unowned reference is always defined as a non-optional type.</li>
</ul>


<p>ARC cannot set the reference to nil when the instance it refers to is deallocated, <code>because variables of a non-optional type cannot be set to nil.</code></p>

<p>æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼Œè¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸¤ä¸ªç±»,Customerå’ŒCreditCard,ä¸ä¹‹å‰ä¸åŒï¼ŒCreditCardè‚¯å®šå¯¹åº”ç€ä¸€ä¸ªCustomer,æ•…ç”¨unowned</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Customer {
</span><span class='line'>    let name: String
</span><span class='line'>    var card: CreditCard?
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>    deinit { println("\(name) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class CreditCard {
</span><span class='line'>    let number: Int
</span><span class='line'>    unowned let customer: Customer
</span><span class='line'>    init(number: Int, customer: Customer) {
</span><span class='line'>        self.number = number
</span><span class='line'>        self.customer = customer
</span><span class='line'>    }
</span><span class='line'>    deinit { println("Card #\(number) is being deinitialized") }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var john: Customer?
</span><span class='line'>john = Customer(name: "John Appleseed")
</span><span class='line'>john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/2014/8/unowned.png"></p>

<h5>Unowned References and Implicitly Unwrapped Optional Properties</h5>

<p>in two classes ,both properties should always have a value, and neither property should ever be nil once initialization is complete. In this scenario, it is useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</p>

<p>This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle. This section shows you how to set up such a relationship.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Country {
</span><span class='line'>    let name: String
</span><span class='line'>    let capitalCity: City!
</span><span class='line'>    init(name: String, capitalName: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.capitalCity = City(name: capitalName, country: self)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class City {
</span><span class='line'>    let name: String
</span><span class='line'>    unowned let country: Country
</span><span class='line'>    init(name: String, country: Country) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.country = country
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The initializer for City is called from within the initializer for Country. However, the initializer for Country cannot pass self to the City initializer until a new Country instance is fully initialized, as described in Two-Phase Initialization.</p>

<p>To cope with this requirement, you declare the capitalCity property of Country as an implicitly unwrapped optional property, indicated by the exclamation mark at the end of its type annotation (City!). This means that the capitalCity property has a default value of nil, like any other optional, but can be accessed without the need to unwrap its value as described in Implicitly Unwrapped Optionals.</p>

<p>Because capitalCity has a default nil value, a new Country instance is considered fully initialized as soon as the Country instance sets its name property within its initializer</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var country = Country(name: "Canada", capitalName: "Ottawa")
</span><span class='line'>println("\(country.name)'s capital city is called \(country.capitalCity.name)")
</span><span class='line'>// prints "Canada's capital city is called Ottawaâ€</span></code></pre></td></tr></table></div></figure>


<h5>Strong Reference Cycles for Closures</h5>

<p>closureæœ‰å¯èƒ½å¯¼è‡´å¾ªç¯å¼•ç”¨ï¼Œå› ä¸ºclosureä¹Ÿæ˜¯å¼•ç”¨ç±»å‹,Swiftæä¾›äº†ä¸€ä¸ªå«åš<code>closure capture list</code>çš„æ–¹å¼æ¥è§£å†³æ­¤ç±»é—®é¢˜
æˆ‘ä»¬å…ˆçœ‹çœ‹closureå¼•ç”¨çš„å¾ªç¯å¼•ç”¨æ˜¯å¦‚ä½•äº§ç”Ÿçš„</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HTMLElement {
</span><span class='line'>    
</span><span class='line'>    let name: String
</span><span class='line'>    let text: String?
</span><span class='line'>    
</span><span class='line'>    @lazy var asHTML: () -&gt; String = {
</span><span class='line'>        if let text = self.text {
</span><span class='line'>            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>        } else {
</span><span class='line'>            return "&lt;\(self.name) /&gt;"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(name: String, text: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        println("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>println(paragraph!.asHTML())
</span><span class='line'>// prints "&lt;p&gt;hello, world&lt;/p&gt;"</span></code></pre></td></tr></table></div></figure>


<p>The asHTML property is named and used somewhat like an instance method. However, because asHTML is a closure property rather than an instance method, you can replace the default value of the asHTML property with a custom closure, if you want to change the HTML rendering for a particular HTML element.</p>

<p><code>æ³¨æ„</code></p>

<pre><code>The asHTML property is declared as a lazy property, because it is only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that asHTML is a lazy property means that you can refer to self within the default closure, because the lazy property will not be accessed until after initialization has been completed and self is known to exist.

Even though the closure refers to self multiple times, it only captures one strong reference to the HTMLElement instance.
</code></pre>

<h5>è§£å†³closureå¯¼è‡´çš„å¼•ç”¨å¾ªç¯</h5>

<p>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closureâ€™s definition</p>

<p>A capture list defines the rules to use when capturing one or more reference types within the closureâ€™s body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference</p>

<p><code>æ³¨æ„</code></p>

<pre><code>Swift requires you to write self.someProperty or self.someMethod (rather than just someProperty or someMethod) whenever you refer to a member of self within a closure. This helps you remember that itâ€™s possible to capture self by accident.
</code></pre>

<h5>å®šä¹‰ä¸€ä¸ªCature List</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@lazy var someClosure: (Int, String) -&gt; String = {
</span><span class='line'>    [unowned self] (index: Int, stringToProcess: String) -&gt; String in
</span><span class='line'>    // closure body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>å¦‚æœclosureä¸æŒ‡å®šå‚æ•°åˆ—è¡¨æˆ–è¿”å›å‹(å› ä¸ºå®ƒä»¬èƒ½ä»ä¸Šä¸‹æ–‡ä¸­æ¨æµ‹å‡º,åˆ™å¯ç”¨ä»¥ä¸‹å½¢å¼ä»£æ›¿</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@lazy var someClosure: () -&gt; String = {
</span><span class='line'>    [unowned self] in
</span><span class='line'>    // closure body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Weak and Unowned References</h5>

<p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>

<p>Weak references are <code>always</code> of an <code>optional type</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HTMLElement {
</span><span class='line'>    
</span><span class='line'>    let name: String
</span><span class='line'>    let text: String?
</span><span class='line'>    
</span><span class='line'>    @lazy var asHTML: () -&gt; String = {
</span><span class='line'>        [unowned self] in
</span><span class='line'>        if let text = self.text {
</span><span class='line'>            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>        } else {
</span><span class='line'>            return "&lt;\(self.name) /&gt;"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(name: String, text: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        println("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>println(paragraph!.asHTML())
</span><span class='line'>// prints "&lt;p&gt;hello, world&lt;/p&gt;â€</span></code></pre></td></tr></table></div></figure>


<p><img src="/images/2014/8/unownedblock.png"></p>

<h5>Optional Chaining</h5>

<p>If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil. Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.</p>

<p><code>æ³¨æ„</code></p>

<pre><code>Optional chaining in Swift is similar to messaging nil in Objective-C, but in a way that works for any type, and that can be checked for success or failure.
</code></pre>

<h5>Optional Chaining as an Alternative to Forced Unwrapping</h5>

<p>To reflect the fact that optional chaining can be called on a nil value, the result of an optional chaining call is always an optional value,even if the property, method, or subscript you are querying returns a non-optional value</p>

<p>Specifically, the result of an optional chaining call is of the same type as the expected return value, but wrapped in an optional,A property that normally returns an Int will return an Int? when accessed through optional chaining.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    var residence: Residence?
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class Residence {
</span><span class='line'>    var numberOfRooms = 1
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let john = Person()
</span><span class='line'>
</span><span class='line'>let roomCount = john.residence!.numberOfRooms
</span><span class='line'>// this triggers a runtime error
</span><span class='line'>
</span><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    println("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// prints "Unable to retrieve the number of rooms.â€
</span><span class='line'>
</span><span class='line'>john.residence = Residence()
</span><span class='line'>
</span><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    println("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// prints "John's residence has 1 room(s).â€</span></code></pre></td></tr></table></div></figure>


<h5>Defining Model Classes for Optional Chaining</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    var residence: Residence?
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Residence {
</span><span class='line'>    var rooms = Room[]()
</span><span class='line'>    var numberOfRooms: Int {
</span><span class='line'>    return rooms.count
</span><span class='line'>    }
</span><span class='line'>    subscript(i: Int) -&gt; Room {
</span><span class='line'>        return rooms[i]
</span><span class='line'>    }
</span><span class='line'>    func printNumberOfRooms() {
</span><span class='line'>        println("The number of rooms is \(numberOfRooms)")
</span><span class='line'>    }
</span><span class='line'>    var address: Address?
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Room {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Address {
</span><span class='line'>    var buildingName: String?
</span><span class='line'>    var buildingNumber: String?
</span><span class='line'>    var street: String?
</span><span class='line'>    func buildingIdentifier() -&gt; String? {
</span><span class='line'>        if buildingName {
</span><span class='line'>            return buildingName
</span><span class='line'>        } else if buildingNumber {
</span><span class='line'>            return buildingNumber
</span><span class='line'>        } else {
</span><span class='line'>            return nil
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h5>Calling Properties Through Optional Chaining</h5>

<p>you can use optional chaining to access a property on an optional value, and to check if that property access is successful. You cannot, however, set a propertyâ€™s value through optional chaining.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let john = Person()
</span><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    println("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// prints "Unable to retrieve the number of rooms.â€</span></code></pre></td></tr></table></div></figure>


<h5>Calling Methods Through Optional Chaining</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if john.residence?.printNumberOfRooms() {
</span><span class='line'>    println("It was possible to print the number of rooms.")
</span><span class='line'>} else {
</span><span class='line'>    println("It was not possible to print the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// prints "It was not possible to print the number of rooms.â€</span></code></pre></td></tr></table></div></figure>


<h5>Calling Subscripts Through Optional Chaining</h5>

<p><code>æ³¨æ„</code></p>

<p>When you access a subscript on an optional value through optional chaining, you place the question mark before the subscriptâ€™s braces, not after. The optional chaining question mark always follows immediately after the part of the expression that is optional.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let firstRoomName = john.residence?[0].name {
</span><span class='line'>    println("The first room name is \(firstRoomName).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the first room name.")
</span><span class='line'>}
</span><span class='line'>// prints "Unable to retrieve the first room name.â€
</span><span class='line'>
</span><span class='line'>let johnsHouse = Residence()
</span><span class='line'>johnsHouse.rooms += Room(name: "Living Room")
</span><span class='line'>johnsHouse.rooms += Room(name: "Kitchen")
</span><span class='line'>john.residence = johnsHouse
</span><span class='line'> 
</span><span class='line'>if let firstRoomName = john.residence?[0].name {
</span><span class='line'>    println("The first room name is \(firstRoomName).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the first room name.")
</span><span class='line'>}
</span><span class='line'>// prints "The first room name is Living Room."</span></code></pre></td></tr></table></div></figure>


<h5>Linking Multiple Levels of Chaining</h5>

<p>multiple levels of optional chaining do not add more levels of optionality to the returned value.</p>

<p>ä¹Ÿå°±æ˜¯è¯´</p>

<ul>
<li>If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.</li>
<li>If the type you are trying to retrieve is already optional, it will not become more optional because of the chaining.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let johnsStreet = john.residence?.address?.street {
</span><span class='line'>    println("John's street name is \(johnsStreet).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the address.")
</span><span class='line'>}
</span><span class='line'>// prints "Unable to retrieve the address."
</span><span class='line'>
</span><span class='line'>let johnsAddress = Address()
</span><span class='line'>johnsAddress.buildingName = "The Larches"
</span><span class='line'>johnsAddress.street = "Laurel Street"
</span><span class='line'>john.residence!.address = johnsAddress
</span><span class='line'> 
</span><span class='line'>if let johnsStreet = john.residence?.address?.street {
</span><span class='line'>    println("John's street name is \(johnsStreet).")
</span><span class='line'>} else {
</span><span class='line'>    println("Unable to retrieve the address.")
</span><span class='line'>}
</span><span class='line'>// prints "John's street name is Laurel Street.â€</span></code></pre></td></tr></table></div></figure>


<h5>Chaining on Methods With Optional Return Values</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
</span><span class='line'>    println("John's building identifier is \(buildingIdentifier).")
</span><span class='line'>}
</span><span class='line'>// prints "John's building identifier is The Larches.â€
</span><span class='line'>
</span><span class='line'>if let upper = john.residence?.address?.buildingIdentifier()?.uppercaseString {
</span><span class='line'>    println("John's uppercase building identifier is \(upper).")
</span><span class='line'>}
</span><span class='line'>// prints "John's uppercase building identifier is THE LARCHES."</span></code></pre></td></tr></table></div></figure>


<h4>Type Casting</h4>

<p>Type casting is a way to check the type of an instance, and/or to treat that instance as if it is a different superclass or subclass from somewhere else in its own class hierarchy.</p>

<p>Type casting in Swift is implemented with the <code>is</code> and <code>as</code> operators.</p>

<p>You can also use type casting to check whether a type conforms to a protocol</p>

<h5>Defining a Class Hierarchy for Type Casting</h5>

<p>Defining a Class Hierarchy for Type Casting</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class MediaItem {
</span><span class='line'>    var name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Movie: MediaItem {
</span><span class='line'>    var director: String
</span><span class='line'>    init(name: String, director: String) {
</span><span class='line'>        self.director = director
</span><span class='line'>        super.init(name: name)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>class Song: MediaItem {
</span><span class='line'>    var artist: String
</span><span class='line'>    init(name: String, artist: String) {
</span><span class='line'>        self.artist = artist
</span><span class='line'>        super.init(name: name)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let library = [
</span><span class='line'>    Movie(name: "Casablanca", director: "Michael Curtiz"),
</span><span class='line'>    Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
</span><span class='line'>    Movie(name: "Citizen Kane", director: "Orson Welles"),
</span><span class='line'>    Song(name: "The One And Only", artist: "Chesney Hawkes"),
</span><span class='line'>    Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
</span><span class='line'>]
</span><span class='line'>// the type of "library" is inferred to be MediaItem[]â€
</span></code></pre></td></tr></table></div></figure>


<h5>Checking Type</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var movieCount = 0
</span><span class='line'>var songCount = 0
</span><span class='line'> 
</span><span class='line'>for item in library {
</span><span class='line'>    if item is Movie {
</span><span class='line'>        ++movieCount
</span><span class='line'>    } else if item is Song {
</span><span class='line'>        ++songCount
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>println("Media library contains \(movieCount) movies and \(songCount) songs")
</span><span class='line'>// prints "Media library contains 2 movies and 3 songsâ€</span></code></pre></td></tr></table></div></figure>


<h5>Downcasting</h5>

<p>Because downcasting can fail, the type cast operator comes in two different forms. The optional form, as?, returns an optional value of the type you are trying to downcast to. The forced form, as, attempts the downcast and force-unwraps the result as a single compound action.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for item in library {
</span><span class='line'>    if let movie = item as? Movie {
</span><span class='line'>        println("Movie: '\(movie.name)', dir. \(movie.director)")
</span><span class='line'>    } else if let song = item as? Song {
</span><span class='line'>        println("Song: '\(song.name)', by \(song.artist)")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// Movie: 'Casablanca', dir. Michael Curtiz
</span><span class='line'>// Song: 'Blue Suede Shoes', by Elvis Presley
</span><span class='line'>// Movie: 'Citizen Kane', dir. Orson Welles
</span><span class='line'>// Song: 'The One And Only', by Chesney Hawkes
</span><span class='line'>// Song: 'Never Gonna Give You Up', by Rick Astleyâ€</span></code></pre></td></tr></table></div></figure>


<h4>Type Casting for Any and AnyObject</h4>

<p>Swift provides two special type aliases for working with non-specific types:</p>

<ul>
<li>AnyObject can represent an instance of any class type.</li>
<li>Any can represent an instance of any type at all, apart from function types.</li>
</ul>


<p><code>æ³¨æ„</code></p>

<p>Use Any and AnyObject only when you explicitly need the behavior and capabilities they provide. It is always better to be specific about the types you expect to work with in your code.</p>

<h5>AnyObject</h5>

<p>When working with Cocoa APIs, it is common to receive an array with a type of AnyObject[], or â€œan array of values of any object typeâ€. This is because Objective-C does not have explicitly typed arrays</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someObjects: AnyObject[] = [
</span><span class='line'>    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
</span><span class='line'>    Movie(name: "Moon", director: "Duncan Jones"),
</span><span class='line'>    Movie(name: "Alien", director: "Ridley Scott")
</span><span class='line'>]
</span><span class='line'>
</span><span class='line'>for object in someObjects {
</span><span class='line'>    let movie = object as Movie
</span><span class='line'>    println("Movie: '\(movie.name)', dir. \(movie.director)")
</span><span class='line'>}
</span><span class='line'>// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
</span><span class='line'>// Movie: 'Moon', dir. Duncan Jones
</span><span class='line'>// Movie: 'Alien', dir. Ridley Scottâ€
</span><span class='line'>
</span><span class='line'>//æˆ–è€… 
</span><span class='line'>
</span><span class='line'>for movie in someObjects as Movie[] {
</span><span class='line'>    println("Movie: '\(movie.name)', dir. \(movie.director)")
</span><span class='line'>}
</span><span class='line'>// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
</span><span class='line'>// Movie: 'Moon', dir. Duncan Jones
</span><span class='line'>// Movie: 'Alien', dir. Ridley Scottâ€</span></code></pre></td></tr></table></div></figure>


<h5>Any</h5>

<p>Hereâ€™s an example of using Any to work with a mix of different types, including non-class types</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var things = Any[]()
</span><span class='line'> 
</span><span class='line'>things.append(0)
</span><span class='line'>things.append(0.0)
</span><span class='line'>things.append(42)
</span><span class='line'>things.append(3.14159)
</span><span class='line'>things.append("hello")
</span><span class='line'>things.append((3.0, 5.0))
</span><span class='line'>things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))</span></code></pre></td></tr></table></div></figure>


<p>You can use the is and as operators in a switch statementâ€™s cases to discover the specific type of a constant or variable that is known <code>only</code> to be of type <code>Any</code> or <code>AnyObject</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for thing in things {
</span><span class='line'>    switch thing {
</span><span class='line'>    case 0 as Int:
</span><span class='line'>        println("zero as an Int")
</span><span class='line'>    case 0 as Double:
</span><span class='line'>        println("zero as a Double")
</span><span class='line'>    case let someInt as Int:
</span><span class='line'>        println("an integer value of \(someInt)")
</span><span class='line'>    case let someDouble as Double where someDouble &gt; 0:
</span><span class='line'>        println("a positive double value of \(someDouble)")
</span><span class='line'>    case is Double:
</span><span class='line'>        println("some other double value that I don't want to print")
</span><span class='line'>    case let someString as String:
</span><span class='line'>        println("a string value of \"\(someString)\"")
</span><span class='line'>    case let (x, y) as (Double, Double):
</span><span class='line'>    
</span><span class='line'>println("an (x, y) point at \(x), \(y)")
</span><span class='line'>    case let movie as Movie:
</span><span class='line'>        println("a movie called '\(movie.name)', dir. \(movie.director)")
</span><span class='line'>    default:
</span><span class='line'>        println("something else")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// zero as an Int
</span><span class='line'>// zero as a Double
</span><span class='line'>// an integer value of 42
</span><span class='line'>// a positive double value of 3.14159
</span><span class='line'>// a string value of "hello"
</span><span class='line'>// an (x, y) point at 3.0, 5.0
</span><span class='line'>// a movie called 'Ghostbusters', dir. Ivan Reitman</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<pre><code>The cases of a switch statement use the forced version of the type cast operator (as, not as?) to check and cast to a specific type. This check is always safe within the context of a switch case statement.
</code></pre>

<h5>Nested Types</h5>

<p>Nest supporting enumerations, classes, and structures within the definition of the type they support.</p>

<p>To nest a type within another type, write its definition within the outer braces of the type it supports. Types can be nested to <code>as many levels as are required</code>.</p>

<h5>Nested Types in Action</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct BlackjackCard {
</span><span class='line'>// nested Suit enumeration
</span><span class='line'>    enum Suit: Character {
</span><span class='line'>        case Spades = "â™ ", Hearts = "â™¡", Diamonds = "â™¢", Clubs = "â™£"
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // nested Rank enumeration
</span><span class='line'>    enum Rank: Int {
</span><span class='line'>        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
</span><span class='line'>        case Jack, Queen, King, Ace
</span><span class='line'>        struct Values {
</span><span class='line'>            let first: Int, second: Int?
</span><span class='line'>        }
</span><span class='line'>        var values: Values {
</span><span class='line'>        switch self {
</span><span class='line'>        case .Ace:
</span><span class='line'>            return Values(first: 1, second: 11)
</span><span class='line'>        case .Jack, .Queen, .King:
</span><span class='line'>            return Values(first: 10, second: nil)
</span><span class='line'>        default:
</span><span class='line'>            return Values(first: self.toRaw(), second: nil)
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>  }
</span><span class='line'>    
</span><span class='line'>    // BlackjackCard properties and methods
</span><span class='line'>    let rank: Rank, suit: Suit
</span><span class='line'>    var description: String {
</span><span class='line'>    var output = "suit is \(suit.toRaw()),"
</span><span class='line'>        output += " value is \(rank.values.first)"
</span><span class='line'>        if let second = rank.values.second {
</span><span class='line'>            output += " or \(second)"
</span><span class='line'>        }
</span><span class='line'>        return output
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
</span><span class='line'>println("theAceOfSpades: \(theAceOfSpades.description)")
</span><span class='line'>// prints "theAceOfSpades: suit is â™ , value is 1 or 11â€</span></code></pre></td></tr></table></div></figure>


<p>Even though Rank and Suit are nested within BlackjackCard, their type can be inferred from context,â€œ\and so the initialization of this instance is able to refer to the enumeration members by their member names (.Ace and .Spades) alone.</p>

<h5>Referring to Nested Types</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let heartsSymbol = BlackjackCard.Suit.Hearts.toRaw()
</span><span class='line'>// heartsSymbol is "â™¡â€</span></code></pre></td></tr></table></div></figure>


<h4>Extensions</h4>

<p>Extensions add new functionality to an existing class, structure, or enumeration type,ç±»ä¼¼OCä¸­çš„ç±»åˆ«,Unlike Objective-C categories, Swift extensions do not have names
Swiftä¸­çš„Extensionsèƒ½åšä»¥ä¸‹äº‹æƒ…</p>

<ul>
<li>æ·»åŠ computed propertieså’Œcomputed static properties</li>
<li>å®šä¹‰instance methodså’Œtype methods</li>
<li>æä¾›æ–°çš„initializers</li>
<li>å®šä¹‰subscripts</li>
<li>å®šä¹‰å¹¶ä½¿ç”¨nested types</li>
<li>è®©ä¸€ä¸ªå·²å­˜åœ¨çš„typeéµå¾ªæŸä¸ªåè®®</li>
</ul>


<p><code>æ³¨æ„</code></p>

<pre><code>If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.
</code></pre>

<h5>è¯­æ³•</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SomeType {
</span><span class='line'>    // new functionality to add to SomeType goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>An extension can extend an existing type to make it adopt one or more protocols.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SomeType: SomeProtocol, AnotherProtocol {
</span><span class='line'>    // implementation of protocol requirements goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Computed Properties</h5>

<p>Extensions can add computed instance properties and computed type properties to existing types</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Double {
</span><span class='line'>    var km: Double { return self * 1_000.0 }
</span><span class='line'>    var m: Double { return self }
</span><span class='line'>    var cm: Double { return self / 100.0 }
</span><span class='line'>    var mm: Double { return self / 1_000.0 }
</span><span class='line'>    var ft: Double { return self / 3.28084 }
</span><span class='line'>}
</span><span class='line'>let oneInch = 25.4.mm
</span><span class='line'>println("One inch is \(oneInch) meters")
</span><span class='line'>// prints "One inch is 0.0254 meters"
</span><span class='line'>let threeFeet = 3.ft
</span><span class='line'>println("Three feet is \(threeFeet) meters")
</span><span class='line'>// prints "Three feet is 0.914399970739201 metersâ€
</span><span class='line'>
</span><span class='line'>let aMarathon = 42.km + 195.m
</span><span class='line'>println("A marathon is \(aMarathon) meters long")
</span><span class='line'>// prints "A marathon is 42195.0 meters longâ€</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<pre><code>Extensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.
</code></pre>

<h5>Initializers</h5>

<p>Extensions can add new initializers to existing types. This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the typeâ€™s original implementation.</p>

<p><code>Extensions can add new convenience initializers to a class, but they cannot add new designated initializers or deinitializers to a class</code>. Designated initializers and deinitializers must always be provided by the original class implementation.</p>

<p><code>æ³¨æ„</code></p>

<pre><code>If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and does not define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extensionâ€™s initializer.

This would not be the case if you had written the initializer as part of the value typeâ€™s original implementation
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}
</span><span class='line'>struct Rect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let defaultRect = Rect()
</span><span class='line'>let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
</span><span class='line'>    size: Size(width: 5.0, height: 5.0))
</span><span class='line'>    
</span><span class='line'>extension Rect {
</span><span class='line'>    init(center: Point, size: Size) {
</span><span class='line'>        let originX = center.x - (size.width / 2)
</span><span class='line'>        let originY = center.y - (size.height / 2)
</span><span class='line'>        self.init(origin: Point(x: originX, y: originY), size: size)
</span><span class='line'>    }
</span><span class='line'>}    
</span><span class='line'>
</span><span class='line'>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
</span><span class='line'>    size: Size(width: 3.0, height: 3.0))
</span><span class='line'>// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<pre><code>If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.
</code></pre>

<h5>Methods</h5>

<p>Extensions can add new instance methods and type methods to existing types.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Int {
</span><span class='line'>    func repetitions(task: () -&gt; ()) {
</span><span class='line'>        for i in 0..self {
</span><span class='line'>            task()
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>3.repetitions({
</span><span class='line'>    println("Hello!")
</span><span class='line'>    })
</span><span class='line'>// Hello!
</span><span class='line'>// Hello!
</span><span class='line'>// Hello!
</span><span class='line'>
</span><span class='line'>//æˆ–è€…
</span><span class='line'>3.repetitions {
</span><span class='line'>    println("Goodbye!")
</span><span class='line'>}
</span><span class='line'>// Goodbye!
</span><span class='line'>// Goodbye!
</span><span class='line'>// Goodbye!</span></code></pre></td></tr></table></div></figure>


<h5>Mutating Instance Methods</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Int {
</span><span class='line'>    mutating func square() {
</span><span class='line'>        self = self * self
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var someInt = 3
</span><span class='line'>someInt.square()
</span><span class='line'>// someInt is now 9</span></code></pre></td></tr></table></div></figure>


<h5>Subscripts</h5>

<p>Extensions can add new subscripts to an existing type.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>â€œextension Int {
</span><span class='line'>    subscript(digitIndex: Int) -&gt; Int {
</span><span class='line'>        var decimalBase = 1
</span><span class='line'>            for _ in 1...digitIndex {
</span><span class='line'>                decimalBase *= 10
</span><span class='line'>            }
</span><span class='line'>            return (self / decimalBase) % 10
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>746381295[0]
</span><span class='line'>// returns 5
</span><span class='line'>746381295[1]
</span><span class='line'>// returns 9
</span><span class='line'>746381295[2]
</span><span class='line'>// returns 2
</span><span class='line'>746381295[8]
</span><span class='line'>// returns 7</span></code></pre></td></tr></table></div></figure>


<h5>Nested Types</h5>

<p>Extensions can add new nested types to existing classes, structures and enumerations:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Character {
</span><span class='line'>    enum Kind {
</span><span class='line'>        case Vowel, Consonant, Other
</span><span class='line'>    }
</span><span class='line'>    var kind: Kind {
</span><span class='line'>    switch String(self).lowercaseString {
</span><span class='line'>    case "a", "e", "i", "o", "u":
</span><span class='line'>        return .Vowel
</span><span class='line'>    case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
</span><span class='line'>    "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
</span><span class='line'>        return .Consonant
</span><span class='line'>    default:
</span><span class='line'>        return .Other
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func printLetterKinds(word: String) {
</span><span class='line'>    println("'\(word)' is made up of the following kinds of letters:")
</span><span class='line'>    for character in word {
</span><span class='line'>        switch character.kind {
</span><span class='line'>        case .Vowel:
</span><span class='line'>            print("vowel ")
</span><span class='line'>        case .Consonant:
</span><span class='line'>            print("consonant ")
</span><span class='line'>        case .Other:
</span><span class='line'>            print("other ")
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    print("\n")
</span><span class='line'>}
</span><span class='line'>printLetterKinds("Hello")
</span><span class='line'>// 'Hello' is made up of the following kinds of letters:
</span><span class='line'>// consonant vowel consonant consonant vowel</span></code></pre></td></tr></table></div></figure>


<h4>Protocol</h4>

<p>A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality.</p>

<p>Protocols can <code>require</code> that conforming types have specific instance properties, instance methods, type methods, operators, and subscripts.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol SomeProtocol {
</span><span class='line'>    // protocol definition goes here
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct SomeStructure: FirstProtocol, AnotherProtocol {
</span><span class='line'>    // structure definition goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>If a class has a <code>superclass</code>, list the superclass name before any protocols it adopts, followed by a comma:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
</span><span class='line'>    // class definition goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Property Requirements</h5>

<p>A protocol can require any conforming type to provide an instance property or type property with a particular name and type.</p>

<p>The protocol doesnâ€™t specify whether the property should be a stored property or a computed propertyâ€”it only specifies the required property name and type. The protocol also specifies whether each property must be gettable or gettable and settable.</p>

<p>If a protocol requires a property to be gettable and settable, that property requirement cannot be fulfilled by a constant stored property or a read-only computed property.</p>

<p>Property requirements are always declared as variable properties, prefixed with the var keyword.</p>

<p>Gettable and settable properties are indicated by writing { get set } after their type declaration, and gettable properties are indicated by writing { get }.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol SomeProtocol {
</span><span class='line'>    var mustBeSettable: Int { get set }
</span><span class='line'>    var doesNotNeedToBeSettable: Int { get }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<pre><code>Always prefix type property requirements with the class keyword when you define them in a protocol. This is true even though type property requirements are prefixed with the static keyword when implemented by a structure or enumeration:
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol AnotherProtocol {
</span><span class='line'>    class var someTypeProperty: Int { get set }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Hereâ€™s an example of a protocol with a single instance property requirement:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol FullyNamed {
</span><span class='line'>    var fullName: String { get }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct Person: FullyNamed {
</span><span class='line'>    var fullName: String
</span><span class='line'>}
</span><span class='line'>let john = Person(fullName: "John Appleseed")
</span><span class='line'>// john.fullName is "John Appleseedâ€</span></code></pre></td></tr></table></div></figure>


<p>Swift reports an error at compile-time if a protocol requirement is not fulfilled.</p>

<p>Hereâ€™s a more complex class, which also adopts and conforms to the FullyNamed
protocol:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Starship: FullyNamed {
</span><span class='line'>    var prefix: String?
</span><span class='line'>    var name: String
</span><span class='line'>    init(name: String, prefix: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.prefix = prefix
</span><span class='line'>    }
</span><span class='line'>    var fullName: String {
</span><span class='line'>    return (prefix ? prefix! + " " : "") + name
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
</span><span class='line'>// ncc1701.fullName is "USS Enterpriseâ€</span></code></pre></td></tr></table></div></figure>


<h5>Method Requirements</h5>

<p>Protocols can require specific instance methods and type methods to be implemented by conforming types. These methods are written as part of the protocolâ€™s definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body. Variadic parameters are allowed, subject to the same rules as for normal methods.</p>

<p><code>æ³¨æ„</code></p>

<p>Protocols use the same syntax as normal methods, but are not allowed to specify default values for method parameters.</p>

<p>As with type property requirements, you always prefix type method requirements with the class keyword when they are defined in a protocol. This is true even though type method requirements are prefixed with the static keyword when implemented by a structure or enumeration:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol SomeProtocol {
</span><span class='line'>    class func someTypeMethod()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>æ¥çœ‹ä¸€ä¸ªdemo</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol RandomNumberGenerator {
</span><span class='line'>    func random() -&gt; Double
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class LinearCongruentialGenerator: RandomNumberGenerator {
</span><span class='line'>    var lastRandom = 42.0
</span><span class='line'>    let m = 139968.0
</span><span class='line'>    let a = 3877.0
</span><span class='line'>    let c = 29573.0
</span><span class='line'>    func random() -&gt; Double {
</span><span class='line'>        lastRandom = ((lastRandom * a + c) % m)
</span><span class='line'>        return lastRandom / m
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let generator = LinearCongruentialGenerator()
</span><span class='line'>println("Here's a random number: \(generator.random())")
</span><span class='line'>// prints "Here's a random number: 0.37464991998171"
</span><span class='line'>println("And another one: \(generator.random())")
</span><span class='line'>// prints "And another one: 0.729023776863283â€</span></code></pre></td></tr></table></div></figure>


<h5>Mutating Method Requirements</h5>

<p>It is sometimes necessary for a method to modify (or mutate) the instance it belongs to</p>

<p><code>æ³¨æ„</code></p>

<p>If you mark a protocol instance method requirement as mutating, you do not need to write the mutating keyword when writing an implementation of that method for a class. The mutating keyword is only used by structures and enumerations.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Togglable {
</span><span class='line'>    mutating func toggle()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>enum OnOffSwitch: Togglable {
</span><span class='line'>    case Off, On
</span><span class='line'>    mutating func toggle() {
</span><span class='line'>        switch self {
</span><span class='line'>        case Off:
</span><span class='line'>            self = On
</span><span class='line'>        case On:
</span><span class='line'>            self = Off
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>var lightSwitch = OnOffSwitch.Off
</span><span class='line'>lightSwitch.toggle()
</span><span class='line'>// lightSwitch is now equal to .Onâ€</span></code></pre></td></tr></table></div></figure>


<h5>Protocols as Types</h5>

<p>Protocols do not actually implement any functionality themselves. Nonetheless, any protocol you create will become a fully-fledged type for use in your code.
Because it is a type, you can use a protocol in many places where other types are allowed, including:</p>

<ul>
<li>As a parameter type or return type in a function, method, or initializer</li>
<li>As the type of a constant, variable, or property</li>
<li>As the type of items in an array, dictionary, or other container</li>
</ul>


<p>Hereâ€™s an example of a protocol used as a type:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Dice {
</span><span class='line'>    let sides: Int
</span><span class='line'>    let generator: RandomNumberGenerator
</span><span class='line'>    init(sides: Int, generator: RandomNumberGenerator) {
</span><span class='line'>        self.sides = sides
</span><span class='line'>        self.generator = generator
</span><span class='line'>    }
</span><span class='line'>    func roll() -&gt; Int {
</span><span class='line'>        return Int(generator.random() * Double(sides)) + 1
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
</span><span class='line'>for _ in 1...5 {
</span><span class='line'>    println("Random dice roll is \(d6.roll())")
</span><span class='line'>}
</span><span class='line'>// Random dice roll is 3
</span><span class='line'>// Random dice roll is 5
</span><span class='line'>// Random dice roll is 4
</span><span class='line'>// Random dice roll is 5
</span><span class='line'>// Random dice roll is 4</span></code></pre></td></tr></table></div></figure>


<h4>Delegation</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol DiceGame {
</span><span class='line'>    var dice: Dice { get }
</span><span class='line'>    func play()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>protocol DiceGameDelegate {
</span><span class='line'>    func gameDidStart(game: DiceGame)
</span><span class='line'>    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
</span><span class='line'>    func gameDidEnd(game: DiceGame)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class SnakesAndLadders: DiceGame {
</span><span class='line'>    let finalSquare = 25
</span><span class='line'>    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
</span><span class='line'>    var square = 0
</span><span class='line'>    var board: Int[]
</span><span class='line'>    init() {
</span><span class='line'>        board = Int[](count: finalSquare + 1, repeatedValue: 0)
</span><span class='line'>        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
</span><span class='line'>        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
</span><span class='line'>    }
</span><span class='line'>    var delegate: DiceGameDelegate?
</span><span class='line'>    func play() {
</span><span class='line'>        square = 0
</span><span class='line'>        delegate?.gameDidStart(self)
</span><span class='line'>        gameLoop: while square != finalSquare {
</span><span class='line'>            let diceRoll = dice.roll()
</span><span class='line'>            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
</span><span class='line'>            switch square + diceRoll {
</span><span class='line'>            case finalSquare:
</span><span class='line'>                break gameLoop
</span><span class='line'>            case let newSquare where newSquare &gt; finalSquare:
</span><span class='line'>                continue gameLoop
</span><span class='line'>            default:
</span><span class='line'>                square += diceRoll
</span><span class='line'>                square += board[square]
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        delegate?.gameDidEnd(self)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class DiceGameTracker: DiceGameDelegate {
</span><span class='line'>    var numberOfTurns = 0
</span><span class='line'>    func gameDidStart(game: DiceGame) {
</span><span class='line'>        numberOfTurns = 0
</span><span class='line'>        if game is SnakesAndLadders {
</span><span class='line'>            println("Started a new game of Snakes and Ladders")
</span><span class='line'>        }
</span><span class='line'>        println("The game is using a \(game.dice.sides)-sided dice")
</span><span class='line'>    }
</span><span class='line'>    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
</span><span class='line'>        ++numberOfTurns
</span><span class='line'>        println("Rolled a \(diceRoll)")
</span><span class='line'>    }
</span><span class='line'>    func gameDidEnd(game: DiceGame) {
</span><span class='line'>        println("The game lasted for \(numberOfTurns) turns")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let tracker = DiceGameTracker()
</span><span class='line'>let game = SnakesAndLadders()
</span><span class='line'>game.delegate = tracker
</span><span class='line'>game.play()
</span><span class='line'>// Started a new game of Snakes and Ladders
</span><span class='line'>// The game is using a 6-sided dice
</span><span class='line'>// Rolled a 3
</span><span class='line'>// Rolled a 5
</span><span class='line'>// Rolled a 4
</span><span class='line'>// Rolled a 5
</span><span class='line'>// The game lasted for 4 turns</span></code></pre></td></tr></table></div></figure>


<h5>Adding Protocol Conformance with an Extension</h5>

<p><code>æ³¨æ„</code></p>

<p>Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instanceâ€™s type in an extension.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol TextRepresentable {
</span><span class='line'>    func asText() -&gt; String
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension Dice: TextRepresentable {
</span><span class='line'>    func asText() -&gt; String {
</span><span class='line'>        return "A \(sides)-sided dice"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
</span><span class='line'>println(d12.asText())
</span><span class='line'>// prints "A 12-sided diceâ€
</span><span class='line'>
</span><span class='line'>extension SnakesAndLadders: TextRepresentable {
</span><span class='line'>    func asText() -&gt; String {
</span><span class='line'>        return "A game of Snakes and Ladders with \(finalSquare) squares"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>println(game.asText())
</span><span class='line'>// prints "A game of Snakes and Ladders with 25 squaresâ€</span></code></pre></td></tr></table></div></figure>


<h5>Declaring Protocol Adoption with an Extension</h5>

<p>If a type already conforms to all of the requirements of a protocol, but has not yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Hamster {
</span><span class='line'>    var name: String
</span><span class='line'>    func asText() -&gt; String {
</span><span class='line'>        return "A hamster named \(name)"
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>extension Hamster: TextRepresentable {}</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<p>Instances of Hamster can now be used wherever TextRepresentable is the required type:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let simonTheHamster = Hamster(name: "Simon")
</span><span class='line'>let somethingTextRepresentable: TextRepresentable = simonTheHamster
</span><span class='line'>println(somethingTextRepresentable.asText())
</span><span class='line'>// prints "A hamster named Simonâ€</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<pre><code>Types do not automatically adopt a protocol just by satisfying its requirements. They must always explicitly declare their adoption of the protocol.
</code></pre>

<h5>Collections of Protocol Types</h5>

<p>A protocol can be used as the type to be stored in a collection such as an array or a dictionary</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let things: TextRepresentable[] = [game, d12, simonTheHamster]
</span><span class='line'>
</span><span class='line'>for thing in things {
</span><span class='line'>    println(thing.asText())
</span><span class='line'>}
</span><span class='line'>// A game of Snakes and Ladders with 25 squares
</span><span class='line'>// A 12-sided dice
</span><span class='line'>// A hamster named Simon
</span></code></pre></td></tr></table></div></figure>


<h5>Protocol Inheritance</h5>

<p>A protocol can inherit one or more other protocols and can add further requirements on top of the requirements it inherits</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
</span><span class='line'>    // protocol definition goes here
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>protocol PrettyTextRepresentable: TextRepresentable {
</span><span class='line'>    func asPrettyText() -&gt; String
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension SnakesAndLadders: PrettyTextRepresentable {
</span><span class='line'>    func asPrettyText() -&gt; String {
</span><span class='line'>        var output = asText() + ":\n"
</span><span class='line'>        for index in 1...finalSquare {
</span><span class='line'>            switch board[index] {
</span><span class='line'>            case let ladder where ladder &gt; 0:
</span><span class='line'>                output += "â–² "
</span><span class='line'>            case let snake where snake &lt; 0:
</span><span class='line'>                output += "â–¼ "
</span><span class='line'>            default:
</span><span class='line'>                output += "â—‹ "
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return output
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>println(game.asPrettyText())
</span><span class='line'>// A game of Snakes and Ladders with 25 squares:
</span><span class='line'>// â—‹ â—‹ â–² â—‹ â—‹ â–² â—‹ â—‹ â–² â–² â—‹ â—‹ â—‹ â–¼ â—‹ â—‹ â—‹ â—‹ â–¼ â—‹ â—‹ â–¼ â—‹ â–¼ â—‹</span></code></pre></td></tr></table></div></figure>


<h5>Protocol Composition</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Named {
</span><span class='line'>    var name: String { get }
</span><span class='line'>}
</span><span class='line'>protocol Aged {
</span><span class='line'>    var age: Int { get }
</span><span class='line'>}
</span><span class='line'>struct Person: Named, Aged {
</span><span class='line'>    var name: String
</span><span class='line'>    var age: Int
</span><span class='line'>}
</span><span class='line'>func wishHappyBirthday(celebrator: protocol&lt;Named, Aged&gt;) {
</span><span class='line'>    println("Happy birthday \(celebrator.name) - you're \(celebrator.age)!")
</span><span class='line'>}
</span><span class='line'>let birthdayPerson = Person(name: "Malcolm", age: 21)
</span><span class='line'>wishHappyBirthday(birthdayPerson)
</span><span class='line'>// prints "Happy birthday Malcolm - you're 21!"</span></code></pre></td></tr></table></div></figure>


<h5>Checking for Protocol Conformance</h5>

<p>You can use the is and as operators described in Type Casting to check for protocol conformance, and to cast to a specific protocol.</p>

<ul>
<li>The is operator returns true if an instance conforms to a protocol and returns false if it does not.</li>
<li>The as? version of the downcast operator returns an optional value of the protocolâ€™s type, and this value is nil if the instance does not conform to that protocol.</li>
<li>The as version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast does not succeed.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@objc protocol HasArea {
</span><span class='line'>    var area: Double { get }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<p>You can check for protocol conformance <code>only if your protocol is marked with the @objc attribute</code>, as seen for the HasArea protocol above. This attribute indicates that the protocol should be exposed to Objective-C code and is described in Using Swift with Cocoa and Objective-C. Even if you are not interoperating with Objective-C, you need to mark your protocols with the @objc attribute if you want to be able to check for protocol conformance.</p>

<p>Note also that @objc protocols can be adopted <code>only by classes</code>, and not by structures or enumerations. If you mark your protocol as @objc in order to check for conformance, you will be able to apply that protocol only to class types.</p>

<p>Here are two classes, Circle and Country, both of which conform to the HasArea protocol:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Circle: HasArea {
</span><span class='line'>    let pi = 3.1415927
</span><span class='line'>    var radius: Double
</span><span class='line'>    var area: Double { return pi * radius * radius }
</span><span class='line'>    init(radius: Double) { self.radius = radius }
</span><span class='line'>}
</span><span class='line'>class Country: HasArea {
</span><span class='line'>    var area: Double
</span><span class='line'>    init(area: Double) { self.area = area }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Animal Class</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Animal {
</span><span class='line'>    var legs: Int
</span><span class='line'>    init(legs: Int) { self.legs = legs }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let objects: AnyObject[] = [
</span><span class='line'>    Circle(radius: 2.0),
</span><span class='line'>    Country(area: 243_610),
</span><span class='line'>    Animal(legs: 4)
</span><span class='line'>]
</span><span class='line'>
</span><span class='line'>for object in objects {
</span><span class='line'>    if let objectWithArea = object as? HasArea {
</span><span class='line'>        println("Area is \(objectWithArea.area)")
</span><span class='line'>    } else {
</span><span class='line'>        println("Something that doesn't have an area")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>// Area is 12.5663708
</span><span class='line'>// Area is 243610.0
</span><span class='line'>// Something that doesn't have an area</span></code></pre></td></tr></table></div></figure>


<h5>Optional Protocol Requirements</h5>

<p>You can define optional requirements for protocols
Optional property requirements, and optional method requirements that return a value, will always return an optional value of the appropriate type when they are accessed or called</p>

<p>You check for an implementation of an optional requirement by writing a question mark after the name of the requirement when it is called, such as someOptionalMethod?(someArgument).</p>

<p><code>æ³¨æ„</code></p>

<pre><code>Optional protocol requirements can only be specified if your protocol is marked with the @objc attribute. Even if you are not interoperating with Objective-C, you need to mark your protocols with the @objc attribute if you want to specify optional requirements.
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@objc protocol CounterDataSource {
</span><span class='line'>    @optional func incrementForCount(count: Int) -&gt; Int
</span><span class='line'>    @optional var fixedIncrement: Int { get }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@objc class Counter {
</span><span class='line'>    var count = 0
</span><span class='line'>    var dataSource: CounterDataSource?
</span><span class='line'>    func increment() {
</span><span class='line'>        if let amount = dataSource?.incrementForCount?(count) {
</span><span class='line'>            count += amount
</span><span class='line'>        } else if let amount = dataSource?.fixedIncrement? {
</span><span class='line'>            count += amount
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class ThreeSource: CounterDataSource {
</span><span class='line'>    let fixedIncrement = 3
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var counter = Counter()
</span><span class='line'>counter.dataSource = ThreeSource()
</span><span class='line'>for _ in 1...4 {
</span><span class='line'>    counter.increment()
</span><span class='line'>    println(counter.count)
</span><span class='line'>}
</span><span class='line'>// 3
</span><span class='line'>// 6
</span><span class='line'>// 9
</span><span class='line'>// 12
</span></code></pre></td></tr></table></div></figure>


<p>å¦ä¸€ä¸ªä¾‹å­</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class TowardsZeroSource: CounterDataSource {
</span><span class='line'>    func incrementForCount(count: Int) -&gt; Int {
</span><span class='line'>        if count == 0 {
</span><span class='line'>            return 0
</span><span class='line'>        } else if count &lt; 0 {
</span><span class='line'>            return 1
</span><span class='line'>        } else {
</span><span class='line'>            return -1
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>counter.count = -4
</span><span class='line'>counter.dataSource = TowardsZeroSource()
</span><span class='line'>for _ in 1...5 {
</span><span class='line'>    counter.increment()
</span><span class='line'>    println(counter.count)
</span><span class='line'>}
</span><span class='line'>// -3
</span><span class='line'>// -2
</span><span class='line'>// -1
</span><span class='line'>// 0
</span><span class='line'>// 0</span></code></pre></td></tr></table></div></figure>


<h4>Generics</h4>

<p>äº¤æ¢ä¸¤ä¸ªå€¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoValues(&someInt, &anotherInt)
</span><span class='line'>// someInt is now 107, and anotherInt is now 3
</span><span class='line'> 
</span><span class='line'>var someString = "hello"
</span><span class='line'>var anotherString = "world"
</span><span class='line'>swapTwoValues(&someString, &anotherString)
</span><span class='line'>// someString is now "world", and anotherString is now "helloâ€
</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<pre><code>You can use Swiftâ€™s existing swap function rather than providing your own implementation.
</code></pre>

<h5>Type Parameters</h5>

<p>Type parameters specify and name a placeholder type, and are written immediately after the functionâ€™s name, between a pair of matching angle brackets (such as <T>).</p>

<p>You can provide more than one type parameter by writing multiple type parameter names within the angle brackets, separated by commas.</p>

<h5>Naming Type Parameters</h5>

<p>It is traditional to use the single-character name T for the type parameter. However, you are can use any valid identifier as the type parameter name.</p>

<p><code>æ³¨æ„</code></p>

<pre><code>Always give type parameters UpperCamelCase names (such as T and KeyType) to indicate that they are a placeholder for a type, not a value.
</code></pre>

<h5>Generic Types</h5>

<p>In addition to generic functions, Swift enables you to define your own generic types. These are custom classes, structures, and enumerations that can work with any type, in a similar way to Array and Dictionary.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Stack&lt;T&gt; {
</span><span class='line'>    var items = T[]()
</span><span class='line'>    mutating func push(item: T) {
</span><span class='line'>        items.append(item)
</span><span class='line'>    }
</span><span class='line'>    mutating func pop() -&gt; T {
</span><span class='line'>        return items.removeLast()
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var stackOfStrings = Stack&lt;String&gt;()
</span><span class='line'>stackOfStrings.push("uno")
</span><span class='line'>stackOfStrings.push("dos")
</span><span class='line'>stackOfStrings.push("tres")
</span><span class='line'>stackOfStrings.push("cuatro")
</span><span class='line'>// the stack now contains 4 stringsâ€
</span><span class='line'>
</span><span class='line'>let fromTheTop = stackOfStrings.pop()
</span><span class='line'>// fromTheTop is equal to "cuatro", and the stack now contains 3 strings</span></code></pre></td></tr></table></div></figure>


<h5>Type Constraints</h5>

<p>It is sometimes useful to enforce certain type constraints on the types that can be used with generic functions and generic types. <code>Type constraints specify that a type parameter must inherit from a specific class, or conform to a particular protocol or protocol composition.</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
</span><span class='line'>    // function body goes here
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Type Constraints in Action</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findIndex&lt;T&gt;(array: T[], valueToFind: T) -&gt; Int? {
</span><span class='line'>    for (index, value) in enumerate(array) {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>éœ€è¦æ³¨æ„çš„æ˜¯è¿™ä¸ªå‡½æ•°ç¼–è¯‘å¤±è´¥!é—®é¢˜å‡ºåœ¨ä»¥ä¸‹</p>

<pre><code>if value == valueToFind
</code></pre>

<p>Not every type in Swift can be compared with the equal to operator (==).
æˆ‘ä»¬å¯ä»¥å†™æˆå¦‚ä¸‹æ–¹å¼</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? {
</span><span class='line'>    for (index, value) in enumerate(array) {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Equatableè¡¨ç¤ºç±»å‹å¿…é¡»éµå¾ªEquatableåè®®,è¿™æ ·ç¼–è¯‘å°±èƒ½é¡ºåˆ©é€šè¿‡äº†</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
</span><span class='line'>// doubleIndex is an optional Int with no value, because 9.3 is not in the array
</span><span class='line'>let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
</span><span class='line'>// stringIndex is an optional Int containing a value of 2</span></code></pre></td></tr></table></div></figure>


<h5>Associated Types</h5>

<p>When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocolâ€™s definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted. Associated types are specified with the typealias keyword.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Container {
</span><span class='line'>    typealias ItemType
</span><span class='line'>    mutating func append(item: ItemType)
</span><span class='line'>    var count: Int { get }
</span><span class='line'>    subscript(i: Int) -&gt; ItemType { get }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct IntStack: Container {
</span><span class='line'>    // original IntStack implementation
</span><span class='line'>    var items = Int[]()
</span><span class='line'>    mutating func push(item: Int) {
</span><span class='line'>        items.append(item)
</span><span class='line'>    }
</span><span class='line'>    mutating func pop() -&gt; Int {
</span><span class='line'>        return items.removeLast()
</span><span class='line'>    }
</span><span class='line'>    // conformance to the Container protocol
</span><span class='line'>    typealias ItemType = Int
</span><span class='line'>    mutating func append(item: Int) {
</span><span class='line'>        self.push(item)
</span><span class='line'>    }
</span><span class='line'>    var count: Int {
</span><span class='line'>    return items.count
</span><span class='line'>    }
</span><span class='line'>    subscript(i: Int) -&gt; Int {
</span><span class='line'>        return items[i]
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>If you delete the typealias ItemType = Int line from the code above, everything still works, because it is clear what type should be used for ItemType.</p>

<p>You can also make the generic Stack type conform to the Container protocol:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Stack&lt;T&gt;: Container {
</span><span class='line'>    // original Stack&lt;T&gt; implementation
</span><span class='line'>    var items = T[]()
</span><span class='line'>    mutating func push(item: T) {
</span><span class='line'>        items.append(item)
</span><span class='line'>    }
</span><span class='line'>    mutating func pop() -&gt; T {
</span><span class='line'>        return items.removeLast()
</span><span class='line'>    }
</span><span class='line'>    // conformance to the Container protocol
</span><span class='line'>    mutating func append(item: T) {
</span><span class='line'>        self.push(item)
</span><span class='line'>    }
</span><span class='line'>    var count: Int {
</span><span class='line'>    return items.count
</span><span class='line'>    }
</span><span class='line'>    subscript(i: Int) -&gt; T {
</span><span class='line'>        return items[i]
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Extending an Existing Type to Specify an Associated Type</h5>

<p>Extending an Existing Type to Specify an Associated Type</p>

<p>Swiftâ€™s Array type already provides an append method, a count property, and a subscript with an Int index to retrieve its elements. These three capabilities match the requirements of the Container protocol. This means that you can extend Array to conform to the Container protocol simply by declaring that Array adopts the protocol. You do this with an empty extension</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Array: Container {}</span></code></pre></td></tr></table></div></figure>


<p>Arrayâ€™s existing append method and subscript enable Swift to infer the appropriate type to use for ItemType, just as for the generic Stack type above. After defining this extension, you can use any Array as a Container.</p>

<h5>Where Clauses</h5>

<p>The example below defines a generic function called allItemsMatch</p>

<p>The two containers to be checked <code>do not have to be the same type of container</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func allItemsMatch&lt;
</span><span class='line'>    C1: Container, C2: Container
</span><span class='line'>    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;
</span><span class='line'>    (someContainer: C1, anotherContainer: C2) -&gt; Bool {
</span><span class='line'>        
</span><span class='line'>        // check that both containers contain the same number of items
</span><span class='line'>        if someContainer.count != anotherContainer.count {
</span><span class='line'>            return false
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        // check each pair of items to see if they are equivalent
</span><span class='line'>        for i in 0..someContainer.count {
</span><span class='line'>            if someContainer[i] != anotherContainer[i] {
</span><span class='line'>                return false
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        // all items match, so return true
</span><span class='line'>        return true
</span><span class='line'>        
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var stackOfStrings = Stack&lt;String&gt;()
</span><span class='line'>stackOfStrings.push("uno")
</span><span class='line'>stackOfStrings.push("dos")
</span><span class='line'>stackOfStrings.push("tres")
</span><span class='line'> 
</span><span class='line'>var arrayOfStrings = ["uno", "dos", "tres"]
</span><span class='line'> 
</span><span class='line'>if allItemsMatch(stackOfStrings, arrayOfStrings) {
</span><span class='line'>    println("All items match.")
</span><span class='line'>} else {
</span><span class='line'>    println("Not all items match.")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>Advanced Operators</h4>

<p>These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.</p>

<p>Unlike arithmetic operators in C, arithmetic operators in Swift do not overflow by default. Overflow behavior is trapped and reported as an error</p>

<p>To opt in to overflow behavior, use Swiftâ€™s second set of arithmetic operators that overflow by default, such as the overflow addition operator (&amp;+). All of these overflow operators begin with an ampersand (&amp;).</p>

<p>When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types. Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create</p>

<p>Youâ€™re not just limited to the predefined operators. Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values. These operators can be used and adopted in your code just like any of the predefined operators, and you can even extend existing types to support the custom operators you define.</p>

<h5>Bitwise Operators</h5>

<ul>
<li>Bitwise NOT Operator</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let initialBits: UInt8 = 0b00001111
</span><span class='line'>let invertedBits = ~initialBits  // equals 11110000</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Bitwise AND Operator</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let firstSixBits: UInt8 = 0b11111100
</span><span class='line'>let lastSixBits: UInt8  = 0b00111111
</span><span class='line'>let middleFourBits = firstSixBits & lastSixBits  // equals 00111100</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Bitwise OR Operator</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someBits: UInt8 = 0b10110010
</span><span class='line'>let moreBits: UInt8 = 0b01011110
</span><span class='line'>let combinedbits = someBits | moreBits  // equals 11111110</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Bitwise XOR Operator</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>â€œlet firstBits: UInt8 = 0b00010100
</span><span class='line'>let otherBits: UInt8 = 0b00000101
</span><span class='line'>let outputBits = firstBits ^ otherBits  // equals 00010001</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Bitwise Left and Right Shift Operators

<ul>
<li>Shifting Behavior for Unsigned Integers</li>
<li>Any bits that are moved beyond the bounds of the integerâ€™s storage are discarded.</li>
<li>Zeroes are inserted in the spaces left behind after the original bits are moved to the left or right.</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let shiftBits: UInt8 = 4   // 00000100 in binary
</span><span class='line'>shiftBits &lt;&lt; 1             // 00001000
</span><span class='line'>shiftBits &lt;&lt; 2             // 00010000
</span><span class='line'>shiftBits &lt;&lt; 5             // 10000000
</span><span class='line'>shiftBits &lt;&lt; 6             // 00000000
</span><span class='line'>shiftBits &gt;&gt; 2             // 00000001</span></code></pre></td></tr></table></div></figure>


<p>You can use bit shifting to encode and decode values within other data types:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let pink: UInt32 = 0xCC6699
</span><span class='line'>let redComponent = (pink & 0xFF0000) &gt;&gt; 16    // redComponent is 0xCC, or 204
</span><span class='line'>let greenComponent = (pink & 0x00FF00) &gt;&gt; 8   // greenComponent is 0x66, or 102
</span><span class='line'>let blueComponent = pink & 0x0000FF           // blueComponent is 0x99, or 153</span></code></pre></td></tr></table></div></figure>


<h5>Shifting Behavior for Signed Integers</h5>

<ul>
<li>When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the sign bit, rather than with a zero.

<h5>Overflow Operators</h5></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var willOverflow = UInt8.max
</span><span class='line'>// willOverflow equals 255, which is the largest value a UInt8 can hold
</span><span class='line'>willOverflow = willOverflow &+ 1
</span><span class='line'>// willOverflow is now equal to 0</span></code></pre></td></tr></table></div></figure>


<p>Value Underflow</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var willUnderflow = UInt8.min
</span><span class='line'>// willUnderflow equals 0, which is the smallest value a UInt8 can hold
</span><span class='line'>willUnderflow = willUnderflow &- 1
</span><span class='line'>// willUnderflow is now equal to 255</span></code></pre></td></tr></table></div></figure>


<h5>Division by Zero</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let x = 1
</span><span class='line'>let y = x &/ 0
</span><span class='line'>// y is equal to 0</span></code></pre></td></tr></table></div></figure>


<h5>Operator Functions</h5>

<p>Classes and structures can provide their own implementations of existing operators. This is known as <code>overloading</code> the existing operators.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Vector2D {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}
</span><span class='line'>@infix func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {
</span><span class='line'>    return Vector2D(x: left.x + right.x, y: left.y + right.y)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The example above shows how to implement the arithmetic addition operator (+) for a custom structure. The arithmetic addition operator is a binary operator because it operates on two targets and is said to be <code>infix</code> because it appears in between those two targets.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vector = Vector2D(x: 3.0, y: 1.0)
</span><span class='line'>let anotherVector = Vector2D(x: 2.0, y: 4.0)
</span><span class='line'>let combinedVector = vector + anotherVector
</span><span class='line'>// combinedVector is a Vector2D instance with values of (5.0, 5.0)</span></code></pre></td></tr></table></div></figure>


<h5>Prefix and Postfix Operators</h5>

<p>Classes and structures can also provide implementations of the standard unary operators.You implement a prefix or postfix unary operator by writing the @prefix or @postfix attribute before the func keyword when declaring the operator function:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@prefix func - (vector: Vector2D) -&gt; Vector2D {
</span><span class='line'>    return Vector2D(x: -vector.x, y: -vector.y)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let positive = Vector2D(x: 3.0, y: 4.0)
</span><span class='line'>let negative = -positive
</span><span class='line'>// negative is a Vector2D instance with values of (-3.0, -4.0)
</span><span class='line'>let alsoPositive = -negative
</span><span class='line'>// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</span></code></pre></td></tr></table></div></figure>


<h5>Compound Assignment Operators</h5>

<p>You must  mark a compound assignment operatorâ€™s left input parameter as <code>inout</code>, because the parameterâ€™s value will be modified directly from within the operator function.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@assignment func += (inout left: Vector2D, right: Vector2D) {
</span><span class='line'>    left = left + right
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var original = Vector2D(x: 1.0, y: 2.0)
</span><span class='line'>let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
</span><span class='line'>original += vectorToAdd
</span><span class='line'>// original now has values of (4.0, 6.0)</span></code></pre></td></tr></table></div></figure>


<p>You can combine the @assignment attribute with either the @prefix or @postfix attribute, as in this implementation of the prefix increment operator (++a) for Vector2D instances:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@prefix @assignment func ++ (inout vector: Vector2D) -&gt; Vector2D {
</span><span class='line'>    vector += Vector2D(x: 1.0, y: 1.0)
</span><span class='line'>    return vector
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var toIncrement = Vector2D(x: 3.0, y: 4.0)
</span><span class='line'>let afterIncrement = ++toIncrement
</span><span class='line'>// toIncrement now has values of (4.0, 5.0)
</span><span class='line'>// afterIncrement also has values of (4.0, 5.0)</span></code></pre></td></tr></table></div></figure>


<p><code>æ³¨æ„</code></p>

<pre><code>It is not possible to overload the default assignment operator (=). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator (a ? b : c) cannot be overloaded.
</code></pre>

<h5>Equivalence Operators</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@infix func == (left: Vector2D, right: Vector2D) -&gt; Bool {
</span><span class='line'>    return (left.x == right.x) && (left.y == right.y)
</span><span class='line'>}
</span><span class='line'>@infix func != (left: Vector2D, right: Vector2D) -&gt; Bool {
</span><span class='line'>    return !(left == right)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let twoThree = Vector2D(x: 2.0, y: 3.0)
</span><span class='line'>let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
</span><span class='line'>if twoThree == anotherTwoThree {
</span><span class='line'>    println("These two vectors are equivalent.")
</span><span class='line'>}
</span><span class='line'>// prints "These two vectors are equivalent.</span></code></pre></td></tr></table></div></figure>


<h5>Custom Operators</h5>

<p>New operators are declared at a global level using the operator keyword, and can
be declared as prefix, infix or postfix:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>operator prefix +++ {}
</span><span class='line'>
</span><span class='line'>@prefix @assignment func +++ (inout vector: Vector2D) -&gt; Vector2D {
</span><span class='line'>    vector += vector
</span><span class='line'>    return vector
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
</span><span class='line'>let afterDoubling = +++toBeDoubled
</span><span class='line'>// toBeDoubled now has values of (2.0, 8.0)
</span><span class='line'>// afterDoubling also has values of (2.0, 8.0)</span></code></pre></td></tr></table></div></figure>


<h5>Precedence and Associativity for Custom Infix Operators</h5>

<p>Custom infix operators can also specify a precedence and an associativity.
The possible values for associativity are left, right, and none.</p>

<p>The possible values for associativity are left, right, and none. Left-associative operators associate to the left if written next to other left-associative operators of the same precedence. Similarly, right-associative operators associate to the right if written next to other right-associative operators of the same precedence. Non-associative operators cannot be written next to other operators with the same precedence.</p>

<p>The associativity value defaults to none if it is not specified. The precedence value defaults to 100 if it is not specified.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>operator infix +- { associativity left precedence 140 }
</span><span class='line'>func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {
</span><span class='line'>    return Vector2D(x: left.x + right.x, y: left.y - right.y)
</span><span class='line'>}
</span><span class='line'>let firstVector = Vector2D(x: 1.0, y: 2.0)
</span><span class='line'>let secondVector = Vector2D(x: 3.0, y: 4.0)
</span><span class='line'>let plusMinusVector = firstVector +- secondVector
</span><span class='line'>// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</span></code></pre></td></tr></table></div></figure>


<h4>æ€»ç»“</h4>

<h5>Type Identifier</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someValue: ExampleModule.MyType</span></code></pre></td></tr></table></div></figure>


<h5>Tuple Type</h5>

<p>Void is a typealias for the the empty tuple type, ()</p>

<h5>Function Type</h5>

<p>You can apply the auto_closure attribute to a function type that has a parameter type of () and that returns the type of an expression (see Type Attributes). An autoclosure function captures an <code>implicit closure over the specified expression</code>, instead of the expression itself.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func simpleAssert(condition: @auto_closure () -&gt; Bool, message: String) {
</span><span class='line'>    if !condition() {
</span><span class='line'>        println(message)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let testNumber = 5
</span><span class='line'>simpleAssert(testNumber % 2 == 0, "testNumber isn't an even number.")
</span><span class='line'>// prints "testNumber isn't an even number.</span></code></pre></td></tr></table></div></figure>


<p>You canâ€™t mark a variadic parameter or a return type with the inout keyword.</p>

<p>The type of a curried function is equivalent to a nested function type. For example, the type of the curried function addTwoNumbers()() below is Int &ndash;> Int &ndash;> Int:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func addTwoNumbers(a: Int)(b: Int) -&gt; Int {
</span><span class='line'>    return a + b
</span><span class='line'>}
</span><span class='line'>addTwoNumbers(4)(5) // Returns 9</span></code></pre></td></tr></table></div></figure>


<p>The function types of a curried function are grouped from right to left. For instance, the function type Int &ndash;> Int &ndash;> Int is understood as Int &ndash;> (Int &ndash;> Int)â€”that is, a function that takes an Int and returns another function that takes and return an Int</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func addTwoNumbers(a: Int) -&gt; (Int -&gt; Int) {
</span><span class='line'>    func addTheSecondNumber(b: Int) -&gt; Int {
</span><span class='line'>        return a + b
</span><span class='line'>    }
</span><span class='line'>    return addTheSecondNumber
</span><span class='line'>}
</span><span class='line'>addTwoNumbers(4)(5) // Returns 9</span></code></pre></td></tr></table></div></figure>


<h5>Array</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someArray: String[] = ["Alex", "Brian", "Dave"]
</span><span class='line'>let someArray: Array&lt;String&gt; = ["Alex", "Brian", "Dave"]
</span><span class='line'>
</span><span class='line'>var array3D: Int[][][] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]</span></code></pre></td></tr></table></div></figure>


<h5>Optional Type</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var optionalInteger: Int?
</span><span class='line'>var optionalInteger: Optional&lt;Int&gt;</span></code></pre></td></tr></table></div></figure>


<p>When declaring an optional type, be sure to use parentheses to properly scope the ? operator. As an example, to declare an optional array of integers, write the type annotation as (Int[])?; writing Int[]? produces an error.</p>

<h5>Implicitly Unwrapped Optional Type</h5>

<p>if you try to use an implicitly unwrapped optional that has a value of nil, youâ€™ll get a runtime error.</p>

<h5>Metatype Type</h5>

<p>A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types.</p>

<p>The metatype of a class, structure, or enumeration type is the name of that type followed by .Type. The metatype of a protocol typeâ€”not the concrete type that conforms to the protocol at runtimeâ€”is the name of that protocol followed by .Protocol. For example, the metatype of the class type SomeClass is SomeClass.Type and the metatype of the protocol SomeProtocol is SomeProtocol.Protocol.</p>

<p>You can use the postfix self expression to access a type as a value. For example, SomeClass.self returns SomeClass itself, not an instance of SomeClass. And SomeProtocol.self returns SomeProtocol itself, not an instance of a type that conforms to SomeProtocol at runtime. You can use a dynamicType expression with an instance of a type to access that instanceâ€™s runtime type as a value</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeBaseClass {
</span><span class='line'>    class func printClassName() {
</span><span class='line'>        println("SomeBaseClass")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>class SomeSubClass: SomeBaseClass {
</span><span class='line'>    override class func printClassName() {
</span><span class='line'>        println("SomeSubClass")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let someInstance: SomeBaseClass = SomeSubClass()
</span><span class='line'>// someInstance is of type SomeBaseClass at compile time, but
</span><span class='line'>// someInstance is of type SomeSubClass at runtime
</span><span class='line'>someInstance.dynamicType.printClassName()
</span><span class='line'>// prints "SomeSubClass"</span></code></pre></td></tr></table></div></figure>


<h5>Type Inheritance Clause</h5>

<p>When defining a class, the name of the superclass must appear first in the list of type identifiers, followed by any number of protocols the class must conform to.</p>

<h5>Assignment Operator</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(a, _, (b, c)) = ("test", 9.45, (12, 3))</span></code></pre></td></tr></table></div></figure>


<h5>Self Expression</h5>

<p>In a mutating method of value type, you can assign a new instance of that value type to self.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>    mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>        self = Point(x: x + deltaX, y: y + deltaY)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Closure Expression</h5>

<p>A closure expression can explicitly specify the values that it captures from the surrounding scope using a capture list. A capture list is written as a comma separated list surrounded by square brackets, before the list of parameters</p>

<p>Each entry in the capture list can be marked as weak or unowned to capture a weak or unowned reference to the value.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>myFunction { print(self.title) }                    // strong capture
</span><span class='line'>myFunction { [weak self] in print(self!.title) }    // weak capture
</span><span class='line'>myFunction { [unowned self] in print(self.title) }  // unowned capture</span></code></pre></td></tr></table></div></figure>


<p>You can also bind arbitrary expression to named values in the capture list. The expression is evaluated when the closure is formed, and captured with the specified strength</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Weak capture of "self.parent" as "parent"
</span><span class='line'>myFunction { [weak parent = self.parent] in print(parent!.title) }</span></code></pre></td></tr></table></div></figure>


<h5>Initializer Expression</h5>

<p>Unlike functions, an initializer canâ€™t be used as a value. For example:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var x = SomeClass.someClassFunction // ok
</span><span class='line'>var y = SomeClass.init              // error</span></code></pre></td></tr></table></div></figure>


<p>You also use an initializer expression to delegate to the initializer of a superclass.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeSubClass: SomeSuperClass {
</span><span class='line'>    init() {
</span><span class='line'>        // subclass initialization goes here
</span><span class='line'>        super.init()
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Explicit Member Expression</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var t = (10, 20, 30)
</span><span class='line'>t.0 = t.1
</span><span class='line'>// Now t is (20, 20, 30)</span></code></pre></td></tr></table></div></figure>


<p>A <code>fallthrough</code> statement can appear anywhere inside a switch statement, not just as the last statement of a case block, but it canâ€™t be used in the final case block.</p>

<h5>Parameter Names</h5>

<p>ä»¥ä¸‹ä¸‰ç§æ–¹å¼ç­‰ä»·</p>

<ul>
<li>external parameter name local parameter name: parameter type</li>
<li><code>#parameter name: parameter type</code></li>
<li>_ local parameter name: parameter type</li>
</ul>


<p>An underscore (_) before a local parameter name gives that parameter no name to be used in function calls. The corresponding argument must have no name in function or method calls.</p>

<h5>Enumerations with Raw Cases Values</h5>

<p>Each case must have a unique name and be assigned a unique raw value. If the raw value type is specified as Int and you donâ€™t assign a value to the cases explicitly, they are implicitly assigned the values 0, 1, 2, and so on. Each unassigned case of type Int is implicitly assigned a raw value that is automatically incremented from the raw value of the previous case.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum ExampleEnum: Int {
</span><span class='line'>    case A, B, C = 5, D
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Class Declaration</h5>

<p>When you declare either kind of initializer, you can require any subclass to override it by marking the initializer with the <code>required</code> attribute.</p>

<p>If the current class overrides all of the superclassâ€™s designated initializers, it inherits the superclassâ€™s convenience initializers.</p>

<h5>Protocol Declaration</h5>

<p>To restrict the adoption of a protocol to class types only, mark the entire protocol declaration with the <code>class_protocol</code> attribute</p>

<p><code>æ³¨æ„</code></p>

<p>If a protocol is already marked with the objc attribute, the class_protocol attribute is implicitly applied to that protocol; thereâ€™s no need to mark the protocol with the class_protocol attribute explicitly</p>

<h5>Protocol Property Declaration</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var property name: type { get set }</span></code></pre></td></tr></table></div></figure>


<p>That property declaration canâ€™t be implemented as a constant property or a read-only computed property</p>

<p>Protocol method declarations have the same form as function declarations, with two exceptions: They donâ€™t include a function body, and you canâ€™t provide any default parameter values as part of the function declaration</p>

<p>If youâ€™re implementing the method in an extension, use the class keyword if youâ€™re extending a class and the static keyword if youâ€™re extending a structure.</p>

<h5>Initializer Declaration</h5>

<p>Designated initializers can be declared in the context of a class declaration only and therefore canâ€™t be added to a class using an extension declaration.</p>

<h5>Extension Declaration</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension type: adopted protocols {
</span><span class='line'>    declarations
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Extension declarations canâ€™t contain destructor or protocol declarations, store properties, property observers, or other extension declarations.</p>

<p>Properties, methods, and initializers of an existing type canâ€™t be overridden in an extension of that type.</p>

<h5>Subscript Declaration</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subscript (parameters) -&gt; return type {
</span><span class='line'>    get {
</span><span class='line'>        statements
</span><span class='line'>    }
</span><span class='line'>    set(setter name) {
</span><span class='line'>        statements
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>Operator Declaration</h5>

<p>You can declare operators of three different fixities: infix, prefix, and postfix.
The fixity of an operator specifies the relative position of an operator to its operands.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>operator infix operatorName {
</span><span class='line'>    precedence precedence level
</span><span class='line'>    associativity associativity
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The precedence level can be any whole number (decimal integer) from 0 to 255; unlike decimal integer literals, it <code>canâ€™t contain any underscore characters</code>.</p>

<p>Infix operators that are declared without specifying a precedence or associativity are initialized with a precedence level of 100 and an associativity of none.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>operator prefix operatorName {}</span></code></pre></td></tr></table></div></figure>


<h4>Attributes</h4>

<p>Attributes provide more information about a declaration or type. There are two kinds of attributes in Swift, those that apply to <code>declarations</code> and those that apply to <code>types</code>,For instance, the <code>required</code> attributeâ€”when applied to a designated or convenience initializer declaration of a classâ€”indicates that every subclass <code>must</code> implement that initializer.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@attributeName
</span><span class='line'>@attributeName(attribute arguments)</span></code></pre></td></tr></table></div></figure>


<h5>Declaration Attributes</h5>

<p>You can apply a declaration attribute to declarations only. However, you can also apply the <code>noreturn</code> attribute to a function or method type.</p>

<ul>
<li><p>class_protocol</p>

<pre><code>  Apply this attribute to a protocol to indicate that the protocol can be adopted by class types only.If you apply the objc attribute to a protocol, the class_protocol attribute is implicitly applied to that protocol; thereâ€™s no need to mark the protocol with the class_protocol attribute explicitly.
</code></pre></li>
<li><p>exported</p>

<pre><code>  Apply this attribute to an import declaration to export the imported module, submodule, or declaration from the current module. If another module imports the current module, that other module can access the items exported by the current module.
</code></pre></li>
<li><p>noreturn</p>

<p>  Apply this attribute to a function or method declaration to indicate that the corresponding type of that function or method, T, is @noreturn T. You can mark a function or method type with this attribute to indicate that the function or method <code>doesnâ€™t return to its caller</code>.</p>

<p>  You can override a function or method that is not marked with the noreturn attribute with a function or method that is. That said, you canâ€™t override a function or method that is marked with the noreturn attribute with a function or method that is not. Similar rules apply when you implement a protocol method in a conforming type.</p></li>
<li><p>NSManaged</p>

<p>  Apply this attribute to a stored variable property of a class that inherits from NSManagedObject to indicate that the storage and implementation of the property are provided dynamically by Core Data at runtime based on the associated entity description.</p></li>
<li>objc</li>
</ul>


<p>Apply this attribute to any declaration that can be represented in Objective-Câ€”for example, non-nested classes, protocols, properties and methods (including getters and setters) of classes and protocols, initializers, deinitializers, and subscripts. <code>The objc attribute tells the compiler that a declaration is available to use in Objective-C code.</code></p>

<p>If you apply the objc attribute to a class or protocol, itâ€™s implicitly applied to the members of that class or protocol. The compiler also implicitly adds the objc attribute to a class that inherits from another class marked with the objc attribute. <code>Protocols marked with the objc attribute canâ€™t inherit from protocols that arenâ€™t.</code></p>

<p>The objc attribute optionally accepts a single attribute argument, which consists of an identifier. Use this attribute when you want to expose a different name to Objective-C for the entity the objc attribute applies to.You can use this argument to name classes, protocols, methods, getters, setters, and initializers. The example below exposes the getter for the enabled property of the ExampleClass to Objective-C code as isEnabled rather than just as the name of the property itself.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@objc
</span><span class='line'>class ExampleClass {
</span><span class='line'>    var enabled: Bool {
</span><span class='line'>    @objc(isEnabled) get {
</span><span class='line'>        // Return the appropriate value
</span><span class='line'>    }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>optional</p>

<p>  You can apply the <code>optional</code> attribute only to protocols that are marked with the objc attribute. As a result, only class types can adopt and conform to a protocol that contains optional member requirements.</p></li>
<li>required</li>
</ul>


<p>Apply this attribute to a designated or convenience initializer of a class to indicate that every subclass must implement that initializer.</p>

<p><code>Required designated initializers must be implemented explicitly</code>
<code>Required convenience initializers</code> can be either implemented explicitly or inherited when the subclass directly implements all of the superclassâ€™s designated initializers (or when the subclass overrides the designated initializers with convenience initializers).</p>

<h5>Declaration Attributes Used by Interface Builder</h5>

<p>Interface Builder attributes are declaration attributes used by Interface Builder to synchronize with Xcode. Swift provides the following Interface Builder attributes: <code>IBAction, IBDesignable, IBInspectable, and IBOutlet</code>. These attributes are conceptually the same as their Objective-C counterparts.</p>

<p>You apply the <code>IBOutlet</code> and <code>IBInspectable</code> attributes to property declarations of a class,You apply the IBAction attribute to method declarations of a class and the IBDesignable attribute to class</p>

<h5>Type Attributes</h5>

<p>You can apply type attributes to types only.However, you can also apply the <code>noreturn</code> attribute to a function or method declaration.</p>

<ul>
<li><p>auto_closure</p>

<p>  This attribute is used to delay the evaluation of an expression by automatically wrapping that expression in a closure with no arguments. Apply this attribute to a function or method type that takes no arguments and that returns the type of the expression.</p></li>
<li>noreturn

<h4>Patterns</h4></li>
<li><p>Wildcard Pattern</p>

<p>  A wildcard pattern matches and ignores any value and consists of an underscore (_).</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for _ in 1...3 {
</span><span class='line'>    // Do something three times.
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>Identifier Pattern
An identifier pattern matches any value and binds the matched value to a variable or constant name.</p></li>
<li><p>Value-Binding Pattern</p>

<p>  A value-binding pattern binds matched values to variable or constant names. Value-binding patterns that bind a matched value to the name of a constant begin with the keyword let; those that bind to the name of variable begin with the keyword var.
  Identifiers patterns within a value-binding pattern bind new named variables or constants to their matching values</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let point = (3, 2)
</span><span class='line'>switch point {
</span><span class='line'>    // Bind x and y to the elements of point.
</span><span class='line'>case let (x, y):
</span><span class='line'>    println("The point is at (\(x), \(y)).")
</span><span class='line'>}
</span><span class='line'>// prints "The point is at (3, 2).</span></code></pre></td></tr></table></div></figure>


<p>You can constrain a tuple pattern to match certain kinds of tuple types by using type annotations</p>

<ul>
<li><p>Tuple Pattern</p>

<p>  When a tuple pattern is used as the pattern in a for-in statement or in a variable or constant declaration, it can contain only wildcard patterns, identifier patterns, or other tuple patterns that contain those. For example, the following code <code>isnâ€™t valid</code> because the element 0 in the tuple pattern (x, 0) is an <code>expression pattern</code>:</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]
</span><span class='line'>// This code isn't valid.
</span><span class='line'>for (x, 0) in points {
</span><span class='line'>    /* ... */
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Type-Casting Patterns
There are two <code>type-casting</code> patterns, the is pattern and the as pattern. Both type-casting patterns appear only in switch statement case labels. The is and as patterns have the following form:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>is type
</span><span class='line'>pattern as type</span></code></pre></td></tr></table></div></figure>


<p>The is pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the is patternâ€”or a subclass of that type. <code>The is pattern behaves like the is operator</code> in that they both perform a type cast but discard the returned type.</p>

<ul>
<li><p>Expression Pattern</p>

<p>  An expression pattern represents the value of an expression. Expression patterns appear <code>only in switch</code> statement case labels.</p>

<p>  The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library ~= operator,By default, the ~= operator compares two values of the same type using the == operator. It can also match an integer value with a range of integers in an Range object, as the following example shows:</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let point = (1, 2)
</span><span class='line'>switch point {
</span><span class='line'>case (0, 0):
</span><span class='line'>    println("(0, 0) is at the origin.")
</span><span class='line'>case (-2...2, -2...2):
</span><span class='line'>    println("(\(point.0), \(point.1)) is near the origin.")
</span><span class='line'>default:
</span><span class='line'>    println("The point is at (\(point.0), \(point.1)).")
</span><span class='line'>}
</span><span class='line'>// prints "(1, 2) is near the origin.</span></code></pre></td></tr></table></div></figure>


<p>You can overload the ~= operator to provide custom expression matching behavior. For example, you can rewrite the above example to compare the point expression with a string representations of points.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Overload the ~= operator to match a string with an integer
</span><span class='line'>func ~=(pattern: String, value: Int) -&gt; Bool {
</span><span class='line'>    return pattern == "\(value)"
</span><span class='line'>}
</span><span class='line'>switch point {
</span><span class='line'>case ("0", "0"):
</span><span class='line'>    println("(0, 0) is at the origin.")
</span><span class='line'>case ("-2...2", "-2...2"):
</span><span class='line'>    println("(\(point.0), \(point.1)) is near the origin.")
</span><span class='line'>default:
</span><span class='line'>    println("The point is at (\(point.0), \(point.1)).")
</span><span class='line'>}
</span><span class='line'>// prints "(1, 2) is near the origin.</span></code></pre></td></tr></table></div></figure>


<h4>Generic Parameters and Arguments</h4>

<h5>Generic Parameter Clause</h5>

<ul>
<li><code>&lt;generic parameter list&gt;</code></li>
<li><code>&lt;generic parameter list where requirements&gt;</code></li>
</ul>


<p>The <code>generic parameter list</code> is a comma-separated list of generic parameters, each of which has the following form:</p>

<p><code>type parameter: constraint</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func simpleMin&lt;T: Comparable&gt;(x: T, y: T) -&gt; T {
</span><span class='line'>    if x &lt; y {
</span><span class='line'>        return y
</span><span class='line'>    }
</span><span class='line'>    return x
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>simpleMin(17, 42) // T is inferred to be Int
</span><span class='line'>simpleMin(3.14159, 2.71828) // T is inferred to be Double</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>Where Clauses</p>

<p>  You can specify additional requirements on type parameters and their associated types by including a where clause after the generic parameter list. A where clause consists of the keyword where, followed by a comma-separated list of one or more requirements.</p>

<p>  The requirements in a where clause specify that a type parameter inherits from a class or conforms to a protocol or protocol composition.</p>

<p>  you can express the constraints that a generic type T inherits from a class C and conforms to a protocol P as <T where T: C, T: P>.</p>

<p>  As mentioned above, you can constrain the associated types of type parameters to conform to protocols. For example, the generic parameter clause &lt;T: Generator where T.Element: Equatable> specifies that T conforms to the Generator protocol and the associated type of T, T.Element, conforms to the Equatable protocol (T has the associated type Element because Generator declares Element and T conforms to Generator).</p>

<p>  You can also specify the requirement that two types be identical, using the == operator. For example, the generic parameter clause &lt;T: Generator, U: Generator where T.Element == U.Element> expresses the constraints that T and U conform to the Generator protocol and that their associated types must be identical.</p>

<p>  You can subclass a generic class, but the subclass must also be a generic class.</p></li>
</ul>

</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>





  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"allentofight"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END --></div>
  </section>
</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2014 - AllenToFight -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
	

<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->







		</div>
	</div>
</body>
</html>
