
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Ruby.new - AllenToFight Blog</title>
	<meta name="author" content="AllenToFight">

	
	<meta name="description" content="Ruby.new Ruby中一切皆对象 创建对象，假设有一个Song的类，按如下方式创建实例 song1 = Song.new("Ruby Tuesday") song2 = Song.new("Enveloped in Python") 如何理解一切皆对象，看以下demo puts "gin &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="AllenToFight Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://xiekunRonaldo.github.io/blog/2014/07/22/ruby-dot-new/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<img src="http://www.gravatar.com/avatar/27a0140c11f18fab9bf284743d2b2b4c?s=160" alt="Profile Picture" style="width: 160px;" />
	
</div>
<hgroup>
  <h1><a href="/">AllenToFight Blog</a></h1>
  
    <h2>Life To Code.</h2>
  
</hgroup>

<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="weibo" href="http://www.weibo.com/1876496750" title="Weibo">Facebook</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">Ruby.new</h1>
	<div class="entry-content" itemprop="articleBody"><h4>Ruby中一切皆对象</h4>

<p>创建对象，假设有一个Song的类，按如下方式创建实例</p>

<pre><code>song1 = Song.new("Ruby Tuesday")    song2 = Song.new("Enveloped in Python")
</code></pre>

<p>如何理解一切皆对象，看以下demo</p>

<pre><code>puts "gin joint".length 
puts "Rick".index("c") 
puts 42.even?           //42是否是偶数 puts sam.play(song)
</code></pre>

<p>在java中，如果要算一个值的绝对值，可按如下方式</p>

<pre><code>num = Math.abs(num)
</code></pre>

<p>但在Ruby中，由于一切皆对象，可按如下方式</p>

<pre><code>um = -1234          # =&gt; -1234 
positive = num.abs  # =&gt; 1234
</code></pre>

<p>同样的规则适用于所有的Ruby对象，在C中，你可以写strlen(name)，但在ruby中，你可以写name.length,无比轻松</p>

<h5>Ruby中的方法</h5>

<p>形式如下</p>

<pre><code>def say_goodnight(name)     result = "Good night, " + name      return result   end
    # Time for bed...   puts say_goodnight("John-Boy")  puts say_goodnight("Mary-Ellen")无需分号表示每个语句的结尾，只要你把每一条语句都放在一单独的行上    puts say_goodnight("Mary-Ellen")
</code></pre>

<p>相当于</p>

<pre><code>puts(say_goodnight("Mary-Ellen"))
</code></pre>

<h5>字符串</h5>

<p>创建字符串有两种方法，一种是单引号括起来的，一种是双引号括起来的,双引号括起来的字符串，ruby需要做更多的工作，首先，ruby会寻找以反斜杠开头的序列，并将它替换为一个二进制的值,如&#8221;\n&#8221;,另外，双引号形式的字符串还需要做的将#{expression}序列替换成expression的值,我们能用它来替换之前我们写的程序</p>

<pre><code>def say_goodnight(name)     result = "Good night, #{name}"      return result   end puts say_goodnight('Pa') 
produces:   Good night, Pa
</code></pre>

<p>任意的复杂的表达式都能放在#{&hellip;}里，如下</p>

<pre><code>def say_goodnight(name)     result = "Good night, #{name.capitalize}"       return result   end puts say_goodnight('uncle')     produces:   Good night, Uncle
</code></pre>

<p>我们还能对以上方法进行简化，ruby方法返回的值是最一个表达式对应的值，所以我们可以不必写临时变量和return语句</p>

<pre><code>    def say_goodnight(name)     "Good night, #{name.capitalize}"    end puts say_goodnight('ma')    produces:   Good night, Ma
</code></pre>

<h4>Ruby的名字</h4>

<p>ruby的命名遵循以下惯例,第一个名字的首字符表示这个名字的使用场合</p>

<ul>
<li>局部变量，方法参数，方法名都 以一个小写字母或下划线开头</li>
<li>全局变量以一个$符开头，对象实例变量以@开头</li>
<li>类变量以两个@@开头</li>
<li><p>类名，模块名，常量必须以大写字母开头
使用的demo如下</p>

<pre><code>  Local Variable:     name fish_and_chips x_axis thx1138 _x _26
  Instance Variable:  @name @point_1 @X @_ @plan9
  Class Variable:     @@total @@symtab @@N @@x_pos @@SINGLE
  Global Variable:   $debug $CUSTOMER $_ $plan9 $Global
  Class Name:         String ActiveRecord MyClass     Constant Name:      FEET_PER_MILE DEBUG
</code></pre>

<h4>数组和哈希字典</h4>

<p>数组</p>

<pre><code>  a = [ 1, 'cat', 3.14 ] # array with three elements 
  puts "The first element is #{a[0]}"     # set the third element     a[2] = nil      puts "The array is now #{a.inspect}"        produces:        The first element is 1        The array is now [1, "cat", nil]
</code></pre>

<p>简便地创建数组的方法</p>

<pre><code>  a = %w{ ant bee cat dog elk } 
  a[0] # =&gt; "ant"     a[3] # =&gt; "dog"
</code></pre>

<p>哈希字典
  inst_section = {        &lsquo;cello&rsquo; => &lsquo;string&rsquo;,        &lsquo;clarinet&rsquo; => &lsquo;woodwind&rsquo;,       &lsquo;drum&rsquo; => &lsquo;percussion&rsquo;,         &lsquo;oboe&rsquo; => &lsquo;woodwind&rsquo;,       &lsquo;trumpet&rsquo; => &lsquo;brass&rsquo;,       &lsquo;violin&rsquo; => &lsquo;string&rsquo;    }<code>=&gt;</code>符号的左为key，右为value
在控制台上我们用p而不是puts，因为p可以更显式地打印nil值</p>

<p>  p inst_section[&lsquo;oboe&rsquo;]  p inst_section[&lsquo;cello&rsquo;] p inst_section[&lsquo;bassoon&rsquo;]</p>

<p>  produces:    &ldquo;woodwind&rdquo;    &ldquo;string&rdquo;    nil
默认情况下hash的key如果对应的value不存在，则value的值为nil，我们可以改变这个默认傎</p>

<p>  histogram = Hash.new(0)
  histogram[&lsquo;ruby&rsquo;] # => 0    histogram[&lsquo;ruby&rsquo;] = histogram[&lsquo;ruby&rsquo;] + 1   histogram[&lsquo;ruby&rsquo;] # => 1</p>

<h4>符号(Symbols)</h4>

<p>通常在编程的时候，你需要为某些重要的东西指定一个名字，比如，你也许想要用名字来指示指南针的方向，所以，你可以像以下这么写</p>

<p>  NORTH = 1
  EAST =2
  SOUTH = 3
  WEST =4
定义好之后，你就可以用这些名字而不是数字了</p>

<p>  walk(NORTH) look(EAST)
然而，很多时候，这些名字对应的数值是不相关的(只要它们是唯一的)你所要做的只是区分这四个方向而已
Ruby提供了一个很简单的替代方案:符号(Symbols).Symbols只是常量名字，不过你无需定义它，并且它们也保证是唯一的，一个符号常量以:开头，紧跟着字符串
walk(:north)
look(:east)
无须为一个symbol赋任何值,Ruby已经为你考虑好了.Ruby保证不管符号出现在你，一个特定和符号总量有相同的值，因此，你可以按如下方式使用symbol</p>

<p>  def walk(direction)     if direction == :north      # &hellip;   end end
symbols通常被用来当作hash的key，我们可以将我们之前写的hash写为以下形式
      inst_section = {        :cello => &lsquo;string&rsquo;,         :clarinet => &lsquo;woodwind&rsquo;,        :drum => &lsquo;percussion&rsquo;,      :oboe => &lsquo;woodwind&rsquo;,        :trumpet => &lsquo;brass&rsquo;,        :violin => &lsquo;string&rsquo; }
事实上，symbols是如此频繁地被当作hash的键，ruby提供了一个更简洁的语法，你可以用name:value的形式来创建hash，如果key是symbols的话</p>

<p>  inst_section = {        cello: &lsquo;string&rsquo;,        clarinet: &lsquo;woodwind&rsquo;,       drum: &lsquo;percussion&rsquo;,         oboe: &lsquo;woodwind&rsquo;,       trumpet: &lsquo;brass&rsquo;,       violin: &lsquo;string&rsquo;    }
  puts &ldquo;An oboe is a #{inst_section[:oboe]} instrument&rdquo;   produces:   An oboe is a woodwind instrument</p>

<h4>条件语句</h4>

<p>if语句</p>

<p>  today = Time.now    if today.saturday?      puts &ldquo;Do chores around the house&rdquo;   elsif today.sunday?      puts &ldquo;Relax&rdquo;   else         puts &ldquo;Go to work&rdquo; end  produces:   Go to work
较短的if语句也可以这么写</p>

<p>  puts &ldquo;Danger, Will Robinson&rdquo; if radiation > 3000
while语句</p>

<p>  while weight &lt; 100 and num_pallets &lt;= 5          pallet  = next_pallet()             weight += pallet.weight             num_pallets += 1   end
较短的while语句也可以这么写</p>

<p>  square = 4  square = square*square while square &lt; 1000ruby中的许多语句返回一个值，这意味着你可以用它们作为条件判断，比如,内核方法gets从标准输入流中返回下一行或者当到达文件的末尾时会返回nil，由于Ruby有条件语句中将nil视为假的，你可以用以下代码来处理文件对应的行</p>

<p>  while line = gets
      puts line.downcase  end####正则表达式</p>

<p>  /\d\d:\d\d:\d\d/    # a time such as 12:34:56   /Perl.<em>Python/      # Perl, zero or more other chars, then Python   /Perl Python/       # Perl, a space, and Python /Perl </em>Python/     # Perl, zero or more spaces, and Python  /Perl +Python/     # Perl, one or more spaces, and Python   /Perl\s+Python/   # Perl, whitespace characters, then Python    /Ruby (Perl|Python)/ # Ruby, a space, and either Perl or Python结果if语句使用
  line = gets if line =~ /Perl|Python/    puts &ldquo;Scripting language mentioned: #{line}&rdquo; end
正则表达式的替代方法</p>

<p>  line = gets newline = line.sub(/Perl/, &lsquo;Ruby&rsquo;) # replace first &lsquo;Perl&rsquo; with &lsquo;Ruby&rsquo; newerline =   newline.gsub(/Python/, &lsquo;Ruby&rsquo;) # replace every &lsquo;Python&rsquo; with &lsquo;Ruby&rsquo;</p>

<h4>Blocks和迭代器</h4>

<p>我们首先看看代码块(code blocks),code blocks是一串代码，你能将它与方法调用结合起来,就当它们是参数一样,这是难以置信的强大特性
你用代码块来实现回调(但比java中的匿名内部类简单),把它们像C中的函数指针那样来传递(比C函数指针更简单)，或者实现迭代器的功能
代码块的形式如下
  { puts &ldquo;Hello&rdquo; }
或</p>

<p>  do    club.enroll(person)     person.socialize  end
&ldquo;{}&#8221;block主要用在单行中,&#8221;do&hellip;.end&#8221;主要用在多行中
你可以将block放在一个调用方法的尾部</p>

<p>  greet { puts &ldquo;Hi&rdquo; } //greet是方法
如果方法有参数，则将block放在这些参数的最后</p>

<p>  verbose_greet(&ldquo;Dave&rdquo;, &ldquo;loyal customer&rdquo;) { puts &ldquo;Hi&rdquo; }
方法可以用Ruby提供的yield来调用block多次</p>

<p>  def call_block      puts &ldquo;Start of method&rdquo; yield        yield       puts &ldquo;End of method&rdquo;    end
      call_block { puts &ldquo;In the block&rdquo; }
打印结果
      Start of method     In the block        In the block        End of method
调用yield的时候可以带参数,这些参数将被传到block中去，在block中，你将这些被接收的参数用|params&hellip;|的形式列出来,如下</p>

<p>  def who_says_what yield(&ldquo;Dave&rdquo;, &ldquo;hello&rdquo;)
      yield(&ldquo;Andy&rdquo;, &ldquo;goodbye&rdquo;)    end
  who_says_what {|person, phrase| puts &ldquo;#{person} says #{phrase}&rdquo;}
打印结果</p>

<p>  Dave says hello Andy says goodbye
Code blocks广泛用在ruby的库中用来实现迭代器</p>

<pre><code>  animals = %w( ant bee cat dog ) # create an array   animals.each {|animal| puts animal }    # iterate over the contents
</code></pre>

<p>  produces:
  ant bee cat dog再来看几个例子
      [ &lsquo;cat&rsquo;, &lsquo;dog&rsquo;, &lsquo;horse&rsquo; ].each {|name| print name, &ldquo; &rdquo; }    5.times { print &ldquo;<em>&rdquo; }   3.upto(6) {|i| print i }    (&lsquo;a&rsquo;..&lsquo;e&rsquo;).each {|char| print char }    puts    produces:   cat dog horse </em>****3456abcde####读写</p>

<p>  printf(&ldquo;Number: %5.2f,\nString: %s\n&rdquo;, 1.23, &ldquo;hello&rdquo;)</p>

<p>  produces:    Number:  1.23,    String: hello有很多方法可以将输入读入程序中，最常见的gets方法，它返回标准输入流的下一行
  line = gets print line</p>

<h4>命令行参数</h4>

<p>当你从命令行运行一个Ruby程序时，你能传送一些参数给它，你能用两种不同的参数来访问这些参数
首先，ARGV就是这些参数组成的数组，假设有一个叫cmd_line.rb的程序如下</p>

<p>  puts &ldquo;You gave #{ARGV.size} arguments&rdquo;
  p ARGV
当我们向此程序传入这些参数时，我们参看到输出结果</p>

<p>  $ ruby cmd_line.rb ant bee cat dog
  You gave 4 arguments    [&ldquo;ant&rdquo;, &ldquo;bee&rdquo;, &ldquo;cat&rdquo;, &ldquo;dog&rdquo;]
通常，传入的参数是你要处理的文件的名字，这种情况下，你应该用第二种技巧,<code>ARGF</code>,它是一种特别的I/O对象，代表了通过命令行传入的文件名的所有内容, 我们之后再学习它</p></li>
</ul>

</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>





  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"allentofight"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END --></div>
  </section>
</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2014 - AllenToFight -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
	

<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->







		</div>
	</div>
</body>
</html>
