
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Ruby-new - AllenToFight Blog</title>
	<meta name="author" content="AllenToFight">

	
	<meta name="description" content="Ruby-new Ruby中一切皆对象
创建对象，假设有一个Song的类，按如下方式创建实例 song1 = Song.new("Ruby Tuesday") song2 = Song.new("Enveloped in Python") 如何理解一切皆对象，看以下demo puts "gin &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="AllenToFight Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://xiekunRonaldo.github.io/blog/2014/07/23/ruby-new/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<img src="http://www.gravatar.com/avatar/27a0140c11f18fab9bf284743d2b2b4c?s=160" alt="Profile Picture" style="width: 160px;" />
	
</div>
<hgroup>
  <h1><a href="/">AllenToFight Blog</a></h1>
  
    <h2>Life To Code.</h2>
  
</hgroup>

<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="weibo" href="http://www.weibo.com/1876496750" title="Weibo">Facebook</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">Ruby-new</h1>
	<div class="entry-content" itemprop="articleBody"><h4 id="ruby">Ruby中一切皆对象</h4>
<p>创建对象，假设有一个Song的类，按如下方式创建实例</p>

<pre><code>song1 = Song.new("Ruby Tuesday")

song2 = Song.new("Enveloped in Python")
</code></pre>

<p>如何理解一切皆对象，看以下demo	</p>

<pre><code>puts "gin joint".length 
puts "Rick".index("c") 
puts 42.even?			//42是否是偶数

puts sam.play(song)
</code></pre>

<p>在java中，如果要算一个值的绝对值，可按如下方式</p>

<pre><code>num = Math.abs(num) 但在Ruby中，由于一切皆对象，可按如下方式

um = -1234 			# =&gt; -1234 
positive = num.abs	# =&gt; 1234 同样的规则适用于所有的Ruby对象，在C中，你可以写strlen(name)，但在ruby中，你可以写name.length,无比轻松
</code></pre>

<h5 id="ruby-1">Ruby中的方法</h5>
<p>形式如下</p>

<pre><code>def say_goodnight(name)

	result = "Good night, " + name

	return result

end


# Time for bed...

puts say_goodnight("John-Boy") 

puts say_goodnight("Mary-Ellen")
</code></pre>

<p>无需分号表示每个语句的结尾，只要你把每一条语句都放在一单独的行上</p>

<pre><code>puts say_goodnight("Mary-Ellen") 相当于

puts(say_goodnight("Mary-Ellen")) #####字符串 创建字符串有两种方法，一种是单引号括起来的，一种是双引号括起来的,双引号括起来的字符串，ruby需要做更多的工作，首先，ruby会寻找以反斜杠开头的序列，并将它替换为一个二进制的值,如"\n",另外，双引号形式的字符串还需要做的将#{expression}序列替换成expression的值,我们能用它来替换之前我们写的程序

def say_goodnight(name)

	result = "Good night, #{name}" 

	return result

end

puts say_goodnight('Pa') 

produces:
Good night, Pa 任意的复杂的表达式都能放在#{...}里，如下

def say_goodnight(name)

	result = "Good night, #{name.capitalize}" 

	return result

end

puts say_goodnight('uncle') 

produces:

Good night, Uncle
</code></pre>

<p>我们还能对以上方法进行简化，ruby方法返回的值是最一个表达式对应的值，所以我们可以不必写临时变量和return语句</p>

<pre><code>def say_goodnight(name)

	"Good night, #{name.capitalize}"

end

puts say_goodnight('ma') 

produces:

Good night, Ma
</code></pre>

<h4 id="ruby-2">Ruby的名字</h4>
<p>ruby的命名遵循以下惯例,第一个名字的首字符表示这个名字的使用场合</p>

<ul>
  <li>局部变量，方法参数，方法名都 以一个小写字母或下划线开头</li>
  <li>全局变量以一个$符开头，对象实例变量以@开头</li>
  <li>类变量以两个@@开头</li>
  <li>
    <p>类名，模块名，常量必须以大写字母开头
使用的demo如下</p>

    <pre><code>  Local Variable:		name fish_and_chips x_axis thx1138 _x _26
  Instance Variable:	@name @point_1 @X @_ @plan9
  Class Variable:		@@total @@symtab @@N @@x_pos @@SINGLE
  Global Variable:   $debug $CUSTOMER $_ $plan9 $Global
  Class Name:			String ActiveRecord MyClass
  Constant Name:		FEET_PER_MILE DEBUG ####数组和哈希字典 数组

  a = [ 1, 'cat', 3.14 ] # array with three elements 
  puts "The first element is #{a[0]}"

  # set the third element

  a[2] = nil

  puts "The array is now #{a.inspect}"

  produces:

  The first element is 1

  The array is now [1, "cat", nil] 简便地创建数组的方法

  a = %w{ ant bee cat dog elk } 
  a[0] # =&gt; "ant"

  a[3] # =&gt; "dog"
</code></pre>
  </li>
</ul>

<p>哈希字典</p>

<pre><code>	inst_section = {

	'cello' =&gt; 'string', 

	'clarinet' =&gt; 'woodwind', 

	'drum' =&gt; 'percussion', 

	'oboe' =&gt; 'woodwind', 

	'trumpet' =&gt; 'brass', 

	'violin' =&gt; 'string'
}
</code></pre>

<p><code>=&gt;</code>符号的左为key，右为value
在控制台上我们用p而不是puts，因为p可以更显式地打印nil值</p>

<pre><code>	p inst_section['oboe']

	p inst_section['cello']

	p inst_section['bassoon']
</code></pre>

<p>produces:</p>

<pre><code>    "woodwind"

    "string"

    nil 默认情况下hash的key如果对应的value不存在，则value的值为nil，我们可以改变这个默认傎


histogram = Hash.new(0)
histogram['ruby'] # =&gt; 0

histogram['ruby'] = histogram['ruby'] + 1 

histogram['ruby'] # =&gt; 1 ####符号(Symbols) 通常在编程的时候，你需要为某些重要的东西指定一个名字，比如，你也许想要用名字来指示指南针的方向，所以，你可以像以下这么写

NORTH = 1 
EAST =2 
SOUTH = 3 
WEST =4
</code></pre>

<p>定义好之后，你就可以用这些名字而不是数字了</p>

<pre><code>walk(NORTH)

look(EAST) 然而，很多时候，这些名字对应的数值是不相关的(只要它们是唯一的)你所要做的只是区分这四个方向而已 Ruby提供了一个很简单的替代方案:符号(Symbols).Symbols只是常量名字，不过你无需定义它，并且它们也保证是唯一的，一个符号常量以:开头，紧跟着字符串 walk(:north) look(:east) 无须为一个symbol赋任何值,Ruby已经为你考虑好了.Ruby保证不管符号出现在你，一个特定和符号总量有相同的值，因此，你可以按如下方式使用symbol

def walk(direction)

	if direction == :north

	# ...

	end
 end symbols通常被用来当作hash的key，我们可以将我们之前写的hash写为以下形式

inst_section = {

	:cello =&gt; 'string', 

	:clarinet =&gt; 'woodwind', 

	:drum =&gt; 'percussion', 

	:oboe =&gt; 'woodwind', 

	:trumpet =&gt; 'brass', 

	:violin =&gt; 'string'

}
</code></pre>

<p>事实上，symbols是如此频繁地被当作hash的键，ruby提供了一个更简洁的语法，你可以用name:value的形式来创建hash，如果key是symbols的话</p>

<pre><code>inst_section = {

	cello: 'string', 

	clarinet: 'woodwind', 

	drum: 'percussion', 

	oboe: 'woodwind', 

	trumpet: 'brass', 

	violin: 'string'

}

puts "An oboe is a #{inst_section[:oboe]} instrument"

produces:

An oboe is a woodwind instrument ####条件语句 if语句 

today = Time.now

if today.saturday?

	puts "Do chores around the house"

elsif today.sunday?

	 puts "Relax"

else

	 puts "Go to work" 
end
</code></pre>

<p>produces:</p>

<pre><code>Go to work 较短的if语句也可以这么写

puts "Danger, Will Robinson" if radiation &gt; 3000 while语句

while weight &lt; 100 and num_pallets &lt;= 5

         pallet  = next_pallet()

         weight += pallet.weight

         num_pallets += 1

end 较短的while语句也可以这么写

	square = 4

	square = square*square while square &lt; 1000
</code></pre>

<p>ruby中的许多语句返回一个值，这意味着你可以用它们作为条件判断，比如,内核方法gets从标准输入流中返回下一行或者当到达文件的末尾时会返回nil，由于Ruby有条件语句中将nil视为假的，你可以用以下代码来处理文件对应的行</p>

<pre><code>while line = gets 
	puts line.downcase

end
</code></pre>

<h4 id="section">正则表达式</h4>

<pre><code>/\d\d:\d\d:\d\d/	# a time such as 12:34:56

/Perl.*Python/		# Perl, zero or more other chars, then Python

/Perl Python/		# Perl, a space, and Python

/Perl *Python/     # Perl, zero or more spaces, and Python

/Perl +Python/	   # Perl, one or more spaces, and Python

/Perl\s+Python/   # Perl, whitespace characters, then Python

/Ruby (Perl|Python)/ # Ruby, a space, and either Perl or Python
</code></pre>

<p>结果if语句使用</p>

<pre><code>line = gets

if line =~ /Perl|Python/

	puts "Scripting language mentioned: #{line}" 
end
</code></pre>

<p>正则表达式的替代方法</p>

<pre><code>line = gets

newline = line.sub(/Perl/, 'Ruby') # replace first 'Perl' with 'Ruby' 	newerline = 	newline.gsub(/Python/, 'Ruby') # replace every 'Python' with 'Ruby' ####Blocks和迭代器 我们首先看看代码块(code blocks),code blocks是一串代码，你能将它与方法调用结合起来,就当它们是参数一样,这是难以置信的强大特性 你用代码块来实现回调(但比java中的匿名内部类简单),把它们像C中的函数指针那样来传递(比C函数指针更简单)，或者实现迭代器的功能 代码块的形式如下

{ puts "Hello" } 或

do

  club.enroll(person)

  person.socialize

end "{}"block主要用在单行中,"do....end"主要用在多行中 你可以将block放在一个调用方法的尾部

greet { puts "Hi" }	//greet是方法 如果方法有参数，则将block放在这些参数的最后

verbose_greet("Dave", "loyal customer") { puts "Hi" } 方法可以用Ruby提供的yield来调用block多次

def call_block


	puts "Start of method" 

	yield

	yield

	puts "End of method"

end


call_block { puts "In the block" }
</code></pre>

<p>打印结果</p>

<pre><code>	Start of method

	In the block

	In the block

	End of method
</code></pre>

<table>
  <tbody>
    <tr>
      <td>调用yield的时候可以带参数,这些参数将被传到block中去，在block中，你将这些被接收的参数用</td>
      <td>params…</td>
      <td>的形式列出来,如下</td>
    </tr>
  </tbody>
</table>

<pre><code>def who_says_what yield("Dave", "hello") 
	yield("Andy", "goodbye")


end

who_says_what {|person, phrase| puts "#{person} says #{phrase}"} 打印结果

Dave says hello
Andy says goodbye Code blocks广泛用在ruby的库中用来实现迭代器


animals = %w( ant bee cat dog ) # create an array

animals.each {|animal| puts animal } 	# iterate over the contents
</code></pre>

<p>produces:</p>

<pre><code>ant

bee

cat

dog
</code></pre>

<p>再来看几个例子</p>

<pre><code>[ 'cat', 'dog', 'horse' ].each {|name| print name, " " } 

5.times { print "*" }

3.upto(6) {|i| print i }

('a'..'e').each {|char| print char }

puts
</code></pre>

<p>produces:</p>

<pre><code>cat dog horse *****3456abcde ####读写

printf("Number: %5.2f,\nString: %s\n", 1.23, "hello")
</code></pre>

<p>produces:</p>

<pre><code>Number:  1.23,
String: hello 有很多方法可以将输入读入程序中，最常见的gets方法，它返回标准输入流的下一行

line = gets
print line
</code></pre>

<h4 id="section-1">命令行参数</h4>
<p>当你从命令行运行一个Ruby程序时，你能传送一些参数给它，你能用两种不同的参数来访问这些参数
首先，ARGV就是这些参数组成的数组，假设有一个叫cmd_line.rb的程序如下</p>

<pre><code>puts "You gave #{ARGV.size} arguments" 
p ARGV 当我们向此程序传入这些参数时，我们参看到输出结果

$ ruby cmd_line.rb ant bee cat dog 
You gave 4 arguments

["ant", "bee", "cat", "dog"] 通常，传入的参数是你要处理的文件的名字，这种情况下，你应该用第二种技巧,`ARGF`,它是一种特别的I/O对象，代表了通过命令行传入的文件名的所有内容, 我们之后再学习它
</code></pre>

</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>





  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"allentofight"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END --></div>
  </section>
</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2014 - AllenToFight -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
	

<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->







		</div>
	</div>
</body>
</html>
