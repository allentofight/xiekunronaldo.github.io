<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | AllenToFight Blog]]></title>
  <link href="http://xiekunRonaldo.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://xiekunRonaldo.github.io/"/>
  <updated>2014-07-28T13:34:46+08:00</updated>
  <id>http://xiekunRonaldo.github.io/</id>
  <author>
    <name><![CDATA[AllenToFight]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Standard Types]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/28/standard-types/"/>
    <updated>2014-07-28T08:10:44+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/28/standard-types</id>
    <content type="html"><![CDATA[<p> 这一章主要介绍Ruby中的几个标准类型:numbers,strings,ranges,regular expressions</p>

<h4>Numbers</h4>

<p>Integers可以是任何长度(内存有多大，长度就有多大),在一定范围内(通常是pow(-2,30)&hellip;pow(2,30)-1或是pow(-2,62)&hellip;pow(2,62)-1)的Integers是类Fixnum的对象,超出此范围的则是类Bignum的对象,这个转化过程由Ruby自动来处理</p>

<pre><code>num = 10001 4.times do
    puts "#{num.class}: #{num}" num *= num
end
    produces:
       Fixnum: 10001
       Fixnum: 100020001
       Fixnum: 10004000600040001
       Bignum: 100080028005600700056002800080001
</code></pre>

<p>我们可以在数字前添加0x,0b等前缀,或是下划线</p>

<pre><code>123456 =&gt; 123456    # Fixnum
0d123456 =&gt; 123456      # Fixnum
123_456 =&gt; 123456       # Fixnum - underscore ignored
-543 =&gt; -543            # Fixnum - negative number
0xaabb =&gt; 43707         # Fixnum - hexadecimal
0377 =&gt; 255             # Fixnum - octal
-0b10_1010 =&gt; -42       # Fixnum - binary (negated)
123_456_789_123_456_789 =&gt; 123456789123456789 # Bignum
</code></pre>

<p>Ruby支持rational和complex number,Rational numbers是两个整数的比</p>

<pre><code>Rational(3, 4) * Rational(2, 3) # =&gt; (1/2) Rational("3/4") * Rational("2/3") # =&gt; (1/2)
Complex(1, 2) * Complex(3, 4) # =&gt; (-5+10i) Complex("1+2i") * Complex("3+4i") # =&gt; (-5+10i)
</code></pre>

<p>需要注意的是,不像Perl，在表达式计算时，Strings中的数字并不会自动转为数字
假设有一个文字如下，我们需要计算每行两个数字的和</p>

<pre><code>3   4 

5   6 

7   8
</code></pre>

<p>以下的代码并不工作</p>

<pre><code>some_file.each do |line| 

v1, v2 = line.split         # split line on spaces

print v1 + v2, " "
    end
produces:
34 56 78
</code></pre>

<p>应该先把strings转为integers</p>

<pre><code>some_file.each do |line|
    v1, v2 = line.split
print Integer(v1) + Integer(v2), " "
end
produces:
7 11 15
</code></pre>

<h5>How Number interact</h5>

<pre><code>1 + 2                   # =&gt; 3
1 + 2.0                 # =&gt; 3.0
1.0+2                   # =&gt; 3.0

1.0 + Complex(1,2)      # =&gt; (2.0+2i)
1 + Rational(2,3)       # =&gt; (5/3)
1.0 + Rational(2,3)     # =&gt; 1.6666666666666665
</code></pre>

<p>如果你需要除法能返回 一个Rational number,则需引入mathn库,这个库能帮我们以最<code>自然</code>的方式展示两数运算的结果</p>

<pre><code>22 / 7 # =&gt; 3

Complex::I * Complex::I # =&gt; (-1+0i)
require 'mathn' 22 / 7 # =&gt; (22/7) 
Complex::I * Complex::I # =&gt; -1
</code></pre>

<h5>Looping Using Numbers</h5>

<pre><code>3.times { print "X " } 

1.upto(5) {|i| print i, " " } 

99.downto(95) {|i| print i, " " } 

50.step(80, 5) {|i| print i, " " }

produces:
    X X X 1 2 3 4 5 99 98 97 96 95 50 55 60 65 70 75 80
</code></pre>

<p>同其他迭代器一样，如果其后没有block，则会返回一个Enumerator对象</p>

<pre><code>10.downto(7).with_index {|num, index| puts "#{index}: #{num}"}
produces:
   0: 10
   1: 9
   2: 8
   3: 7
</code></pre>

<h4>Strings</h4>

<p>String有两种组成方式，单引号和双引号组成的string
单引号</p>

<pre><code> 'escape using "\\"'   # =&gt; escape using "\"
      'That\'s right'       # =&gt; That's right
</code></pre>

<p>如果是双引号,你可以用#{expr}来替换strings里的值,如果expr是个全局变量，类变量，或是一个类的实例,花括号可以省略</p>

<pre><code>"Seconds/day: #{24*60*60}" 

"#{'Ho! '*3}Merry Christmas!" "Safe level is #$SAFE"
    # =&gt; Seconds/day: 86400
# =&gt; Ho! Ho! Ho! Merry Christmas!
    # =&gt; Safe level is 0
</code></pre>

<p>{}里的代码不一定只是一个表达式，也可以由多条语句构成</p>

<pre><code>puts "now is #{ def the(a)
                 'the ' + a
                end
                the('time')
                } for all bad coders..."
produces:
now is the time for all bad coders...
</code></pre>

<p>你还可以用另外三种方式来构建一个string常量:%q,%Q以及here documents
你可以把%q看成是单引号,%Q看成是双引号</p>

<pre><code>%q/general single-quoted string/        # =&gt; general single-quoted string

%Q!general double-quoted string!        # =&gt; general double-quoted string

%Q{Seconds/day: #{24*60*60}}            # =&gt; Seconds/day: 86400
</code></pre>

<p>实际上Q是可有可无的</p>

<pre><code>%!general double-quoted string! # =&gt; general double-quoted string 

%{Seconds/day: #{24*60*60}} # =&gt; Seconds/day: 86400
</code></pre>

<p>实际上紧跟在q或Q后的是分隔符,分隔符可以由任何<code>nonalphanumeric</code> 或 <code>nonmultibyte</code>字符组成
最后,我们来看看如何用<code>here document</code>来创建string</p>

<pre><code>string = &lt;&lt;END_OF_STRING
    The body of the string is the input lines up to     one starting with the same text that followed the '&lt;&lt;'  END_OF_STRING
</code></pre>

<p>通常terminator从第一行开始，不过，如果你把一个负号放在&lt;&lt;后，你可以对terminator进行缩进，创建的string也会进行缩进</p>

<pre><code>string = &lt;&lt;-END_OF_STRING
    The body of the string is the input lines up to     one starting with the same text that followed the '&lt;&lt;'  END_OF_STRING
</code></pre>

<p>你也可以将多个here documents放在同一行上，每一个代表一个单独的string,here document的bodies从source lines中依次获取</p>

<pre><code>print &lt;&lt;-STRING1, &lt;&lt;-STRING2 
Concat
STRING1
      enate
      STRING2
produces:
Concat 
    enate
</code></pre>

<p> 注意在此情况下Ruby并不会将enate前的空格给去掉</p>

<h4>Strings and Encodings</h4>

<p>每一个string都有一个对应的encoding,一个string的默认的encoding取决于包含它的源文件的encoding,如果没有指明显式的encoding,一个源文件(和它的string)在Ruby 1.9用的是US-ASCII编码，Ruby 2则是UTF-8</p>

<pre><code>plain_string = "dog"
    puts RUBY_VERSION
puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}"

produces:
2.0.0
Encoding of "dog" is UTF-8
</code></pre>

<p>如果你在文件的开头指明用了哪个encoding,文件中所有的string都 会用此encoding</p>

<pre><code>#encoding: utf-8
plain_string = "dog"
puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}" utf_string = "δog"
puts "Encoding of #{utf_string.inspect} is #{utf_string.encoding}"
produces:
Encoding of "dog" is UTF-8
Encoding of "δog" is UTF-8
</code></pre>

<h6>Working with Strings</h6>

<p>假设一个文件有以下格式</p>

<pre><code>/jazz/j00132.mp3  | 3:45 | Fats     Waller     | Ain't Misbehavin'  /jazz/j00319.mp3  | 2:58 | Louis    Armstrong  | Wonderful World    /bgrass/bg0732.mp3| 4:09 | Strength in Numbers | Texas Red
</code></pre>

<p>现在我们要做以下三件事情</p>

<ol>
<li>将每一行分解成fields</li>
<li>将时间从mm:ss转为秒</li>
<li><p>移除artist中名字中的空格
先来看看第一步</p>

<pre><code>  Song = Struct.new(:title, :name, :length)
  File.open("songdata") do |song_file| songs = []
  song_file.each do |line|
  file, length, name, title = line.chomp.split(/\s*\|\s*/) 
  name.squeeze!(" ")      songs &lt;&lt; Song.new(title, name, length)
  end
    puts songs[1]
  end
  produces:
  #&lt;struct Song title="Wonderful World", name="Louis Armstrong", length="2:58"&gt;
</code></pre>

<p>注意上面的line.chomp,因为每一行都有一个换行符，所以必须把它去掉
来看下如何处理时间,用split也可以，但我们用更好的方式scan</p>

<pre><code>  Song = Struct.new(:title, :name, :length) 

  File.open("songdata") do |song_file|
  songs = []
  song_file.each do |line|
  file, length, name, title = line.chomp.split(/\s*\|\s*/)        name.squeeze!(" ")
  mins, secs = length.scan(/\d+/)
  songs &lt;&lt; Song.new(title, name, mins.to_i*60 + secs.to_i)
  end
  puts songs[1]
  end
  produces:
  #&lt;struct Song title="Wonderful World", name="Louis Armstrong", length=178&gt;####Ranges
</code></pre>

<p>ranges主要用在以下三个方面:sequences, conditions和intervals</p></li>
</ol>


<p>1.Ranges as Sequences</p>

<pre><code>1..10   'a'..'z' 0..."cat".length
</code></pre>

<p>你可以用to_a将一个range转为一个数组,用to_enum将它转为一个Enumberator</p>

<pre><code>(1..10).to_a # =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 

('bar'..'bat').to_a # =&gt; ["bar", "bas", "bat"]  enum = ('bar'..'bat').to_enum   enum.next # =&gt; "bar"    enum.next # =&gt; "bas"
</code></pre>

<p>Ranges有很多方法能让你遍历它们并且用很多方法测试它们</p>

<pre><code>digits = 0..9
digits.include?(5) # =&gt; true
digits.max # =&gt; 9
digits.reject {|i| i &lt; 5 } # =&gt; [5, 6, 7, 8, 9] 
</code></pre>

<p>digits.inject(:+) # => 45
目前我们已经看到了numbers和strings的ranges，实际上，ranges也可以基于你定义的对象来创建,惟一的要求是对象必须定义succ方法，这个方法返回了序列中的下一个对象，这个对象还必须实现<code>&lt;=&gt;</code>(有时称为<code>spaceship operator</code>),允许对象之间的比较,返回-1,0, 1</p>

<pre><code>class PowerOfTwo 
    attr_reader :value 
    def initialize(value)
        @value = value
    end
    def &lt;=&gt;(other)
        @value &lt;=&gt; other.value
    end
    def succ
        PowerOfTwo.new(@value + @value)
    end
    def to_s
    @value.to_s
    end 

end
p1 = PowerOfTwo.new(4)
p2 = PowerOfTwo.new(32)
puts (p1..p2).to_a
produces:
4 
8 
16 
32
</code></pre>

<h5>Ranges as Conditions</h5>

<pre><code>while line = gets
    puts line if line =~ /start/ .. line =~ /end/
end
</code></pre>

<h5>Ranges as Intervals</h5>

<p>可以借此来查看某些值是否在range间,注意必须用<code>===</code></p>

<pre><code>(1..10) === 5 # =&gt; true

(1..10) === 15 # =&gt; false 

(1..10) === 3.14159 # =&gt; true 

('a'..'j') === 'c' # =&gt; true 

('a'..'j') === 'z' # =&gt; false还可用在case中
car_age = gets.to_f # let's assume it's 9.5 
case car_age
when 0...1
    puts "Mmm.. new car smell" 
when 1...3
puts "Nice and new" 
when 3...10
    puts "Reliable but slightly dinged" 
when 10...30
    puts "Clunker" 
else
    puts "Vintage gem" 

end
produces:
Reliable but slightly dinged
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类-对象-变量]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/23/lei-dui-xiang-bian-liang/"/>
    <updated>2014-07-23T21:41:14+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/23/lei-dui-xiang-bian-liang</id>
    <content type="html"><![CDATA[<p>假设有以下文件</p>

<pre><code>        //data.csv

        "Date","ISBN","Price"
        "2013-04-12","978-1-9343561-0-4",39.45
        "2013-04-13","978-1-9343561-6-6",45.67
        "2013-04-14","978-1-9343560-7-4",36.95
</code></pre>

<p>现在我们的任务就是从这个CSV文件中计算出有相同title的书各有多少本，以及书的总价
我们设计了一个BookInStock的类</p>

<pre><code>class BookInStock

end
</code></pre>

<p>用new来创建对象</p>

<pre><code>a_book = BookInStock.new
</code></pre>

<p>以此创建的类无任何信息，我们可以为此类提供一个initialize的方法，此方法能让我们在每个对象都创建好后就设置对象的状态，我们将此状态存储在实例变量中(以@开头),现在我们更新如下</p>

<pre><code>class BookInStock       def initialize(isbn, price)         @isbn = isbn            @price = Float(price)       end     end
</code></pre>

<p>initialize是一个特别的方法，当你调用BookInStore.new去创建一个对象的时候,Ruby分配了一些内存给此未初始化的对象，然后调用了initialize的方法，传递了任何传递给new方法的参数，这样就给了你一次设置对象状态的机会</p>

<pre><code>    b1 = BookInStock.new("isbn1", 3) 
p b1

produces:
    #&lt;BookInStock:0x007fac4910f3e0 @isbn="isbn1", @price=3.0&gt;
</code></pre>

<p>p方法能打印出一个对象的内部表示形式(如@isbn, @price)而puts方法只是简单地将字符串输出到标准输出上，当你将一个对象传给puts时，由于puts不知道如何处理，所以它作了一个简单地处理:对象类的名字+:+对象的内存地址,我们可以改变puts的这种输出形式，只要重写to_s即可</p>

<pre><code>class BookInStock       def initialize(isbn, price)             @isbn = isbn                @price = Float(price)       end
        def to_s        "ISBN: #{@isbn}, price: #{@price}"      end end
        b1 = BookInStock.new("isbn1", 3)    puts b1
结果  ISBN: isbn1, price: 3.0
</code></pre>

<h5>对象和属性</h5>

<p>以上的@isbn, @price不能访问，无任何意义，可以为它添加get方法</p>

<pre><code>class BookInStock       def initialize(isbn, price)         @isbn = isbn            @price = Float(price)       end     def isbn            @isbn       end
    def price           @price      end # ..    end
book = BookInStock.new("isbn1", 12.34) 
puts "ISBN = #{book.isbn}"  puts "Price = #{book.price}"
结果
    ISBN   = isbn1
Price  = 12.34
</code></pre>

<p>由于get方法的使用是如此频繁,Ruby提供了一个简便的方法，attr_reader能为你创建这些属性的get方法</p>

<pre><code>class BookInStock   
  attr_reader :isbn, :price     def initialize(isbn, price)             @isbn = isbn            @price = Float(price)       end     # ..    end book = BookInStock.new("isbn1", 12.34) 

puts "ISBN = #{book.isbn}"
    puts "Price = #{book.price}"
结果: ISBN   = isbn1  Price  = 12.34对应,attr_reader后面跟的是symbols
</code></pre>

<p>这里通常有一个误解，特别是那些学过Java和C#的人,他们认为attr_reader在某种程序上声明了实例变量，实际上是没有的，它只是生成了访问方法，但无声明任何变量，这些变量只有在你使用它们的时候才出现，Ruby是完全让实例变量与访问方法解藕的</p>

<h4>可写属性</h4>

<p>以上我们只是设置了只读方法,现在我看看如何设置可写方法</p>

<pre><code>class BookInStock       attr_reader :isbn, :price       def initialize(isbn, price) 
        @isbn = isbn            @price = Float(price)       end     def price=(new_price)           @price = new_price      end # ...   end

book = BookInStock.new("isbn1", 33.80)  puts "ISBN = #{book.isbn}"  puts "Price = #{book.price}" book.price = book.price * 0.75 puts "New price = #{book.price}"    结果: ISBN      = isbn1   Price     = 33.8    New price = 25.349999999999998
</code></pre>

<p>同样的,Ruby也提供了一个创建属性设置方法的捷径，如果你想有一个只写不可读的方法，可以使用attr_writer,不过这种情况极其罕见，如果你想为某个属性设置可读可写的方法，你可以用attr_accessor</p>

<pre><code>    class BookInStock       attr_reader :isbn 
    attr_accessor :price
    def initialize(isbn, price)             @isbn = isbn            @price = Float(price)       end # ...   end book = BookInStock.new("isbn1", 33.80) 
puts "ISBN = #{book.isbn}"
puts "Price = #{book.price}" 
book.price = book.price * 0.75
puts "New price = #{book.price}"
结果: ISBN      = isbn1
Price     = 33.8
New price = 25.349999999999998
</code></pre>

<h4>虚属性</h4>

<pre><code>class BookInStock 
    attr_reader :isbn       attr_accessor :price        def initialize(isbn, price) 
        @isbn = isbn            @price = Float(price)       end     def price_in_cents          Integer(price*100 + 0.5)        end # ...   end我们看看以下会输出什么
puts "Price in cents = #{book.price_in_cents}"  结果
rice in cents = 3380
</code></pre>

<p><code>book.price_in_cents</code>表示的就是虚属性，由于<code>price_in_cents</code>不对应任何对象的属性，但我们却提供了访问方法，依然可以通过.的形式访问它,同样的，我们也可以提供一个它的写方法</p>

<pre><code>def price_in_cents=(cents) 
    @price = cents / 100.0  end

book = BookInStock.new("isbn1", 33.80)
puts "Price = #{book.price}"
puts "Price in cents = #{book.price_in_cents}" 

book.price_in_cents = 1234  puts "Price = #{book.price}"    puts "Price in cents = #{book.price_in_cents}"  produces:   Price          = 33.8   Price in cents = 3380   Price          = 12.34  Price in cents = 1234####类与其他类的协同工作
</code></pre>

<p>已知BookInStock定义如上,现在不少csv文件，我们需要将csv文件的每一行转为一个BookInStock,并将每一个BookInStock保存到一个数组中，然后计算所有书的总价,所计算的几个csv文件我们通过命令行传入,现在我们将这个程序分成三个rb文件来操作(假设这三个文件在同一目录下)</p>

<ol>
<li><p>book_in_stock.rb</p>

<pre><code> class BookInStock 
     attr_reader :isbn, :price           def initialize(isbn, price)                 @isbn = isbn                @price = Float(price)           end end
</code></pre></li>
</ol>


<p>2.csv_reader.rb
此文件有两个外部信赖，它需要标准的CSV的库，也需要存储在book_in_stock.rb中的BookInStock的类,我们用require来加载Ruby的CSV库，用require_relative来加载book_in_stock文件</p>

<pre><code>require 'csv'   require_relative 'book_in_stock'
class CsvReader 
    def initialize          @books_in_stock = []        end     def read_in_csv_data(csv_file_name)             CSV.foreach(csv_file_name, headers: true) do |row|          @books_in_stock &lt;&lt; BookInStock.new(row["ISBN"], row["Price"]) 
        end end end
</code></pre>

<p>3.stock_stats.rb
这是我们的主程序</p>

<pre><code>require_relative 'csv_reader'   reader = CsvReader.new
ARGV.each do |csv_file_name|        STDERR.puts "Processing #{csv_file_name}" 
    reader.read_in_csv_data(csv_file_name)  end ￼￼￼puts "Total value = #{reader.total_value_in_stock}"
</code></pre>

<p>运行程序如下</p>

<pre><code>$ ruby stock_stats.rb data.csv  Processing data.csv Total value = 122.07000000000001
</code></pre>

<h5>访问控制</h5>

<p>Ruby给你三种访问控制权限</p>

<ul>
<li>Public</li>
<li>Protected</li>
<li>Private
三种访问控制权限与其他语言的一样，不过有一点与其他面向对象的语言很不一样，那就是，Ruby中的访问控制是程序运行后才被确定的，是动态的，而不是静态的，只有当代码执行了访问受限的代码才能知道是否有访问不合法的错误发生

<h6>如何指定访问控制</h6>

<p>有以下两种方法</p>

<pre><code>  class MyClass
      def method1     # 默认是 'public'
          #...
      end
  protected
      def method2
          #....
      end
  private 
      def method3
          #...
      end
  end
</code></pre>

<p>或</p>

<pre><code>      class MyClass 
          def method1 

          end             def method2                 end     # ... and so on           public    :method1, :method4            protected :method2              private   :method3        end
</code></pre>

<h4>变量</h4>

<pre><code>  person = "Tim"      puts "The object in 'person' is a #{person.class}" 
  puts "The object has an id of #{person.object_id}" 
  puts "and a value of '#{person}'"       produces:          The object in 'person' is a String          The object has an id of 70230663692980          and a value of 'Tim'
</code></pre>

<p>那么，变量是否是一个对象呢，答案是否定的，一个变量只是一个对象的引用,来看以下例子，一目了然</p>

<pre><code>  person1 = "Tim"
  person2 = person1 
  person1[0] = 'J'        puts "person1 is #{person1}" 
  puts "person2 is #{person2}"        produces:                      person1 is Jim              person2 is Jim
</code></pre></li>
</ul>


<p>你可以用String的
dup方法来创建一个全新的对象</p>

<pre><code>    person1 = "Tim"     person2 = person1.dup person1[0] = "J"      puts "person1 is #{person1}" puts "person2 is #{person2}"       produces:       person1 is Jim      person2 is Tim我们也可以冻结一个对象来避免对它作出修改
    person1 = "Tim"     person2 = person1       person1.freeze # prevent modifications to the object person2[0] = "J"       produces:               from prog.rb:4:in `&lt;main&gt;'      prog.rb:4:in `[]=': can't modify frozen String (RuntimeError)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby-new]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/23/ruby-new/"/>
    <updated>2014-07-23T20:11:08+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/23/ruby-new</id>
    <content type="html"><![CDATA[<h4>Ruby中一切皆对象</h4>

<p>创建对象，假设有一个Song的类，按如下方式创建实例</p>

<pre><code>song1 = Song.new("Ruby Tuesday")
song2 = Song.new("Enveloped in Python")
</code></pre>

<p>如何理解一切皆对象，看以下demo</p>

<pre><code>puts "gin joint".length 
puts "Rick".index("c") 
puts 42.even?           //42是否是偶数
puts sam.play(song)
</code></pre>

<p>在java中，如果要算一个值的绝对值，可按如下方式</p>

<pre><code>num = Math.abs(num)
</code></pre>

<p>但在Ruby中，由于一切皆对象，可按如下方式</p>

<pre><code>um = -1234          # =&gt; -1234 
positive = num.abs  # =&gt; 1234
</code></pre>

<p>同样的规则适用于所有的Ruby对象，在C中，你可以写strlen(name)，但在ruby中，你可以写name.length,无比轻松</p>

<h5>Ruby中的方法</h5>

<p>形式如下</p>

<pre><code>def say_goodnight(name)     result = "Good night, " + name      return result   end
    # Time for bed...
puts say_goodnight("John-Boy") 
puts say_goodnight("Mary-Ellen")
</code></pre>

<p>无需分号表示每个语句的结尾，只要你把每一条语句都放在一单独的行上    puts say_goodnight(&ldquo;Mary-Ellen&rdquo;)
相当于</p>

<pre><code>puts(say_goodnight("Mary-Ellen"))
</code></pre>

<h5>字符串</h5>

<p>创建字符串有两种方法，一种是单引号括起来的，一种是双引号括起来的,双引号括起来的字符串，ruby需要做更多的工作，首先，ruby会寻找以反斜杠开头的序列，并将它替换为一个二进制的值,如"\n",另外，双引号形式的字符串还需要做的将#{expression}序列替换成expression的值,我们能用它来替换之前我们写的程序</p>

<pre><code>def say_goodnight(name)
    result = "Good night, #{name}" 
    return result
end
puts say_goodnight('Pa') 
produces:   Good night, Pa
</code></pre>

<p>任意的复杂的表达式都能放在#{&hellip;}里，如下</p>

<pre><code>def say_goodnight(name)     result = "Good night, #{name.capitalize}"       return result   end puts say_goodnight('uncle')     produces:   Good night, Uncle
</code></pre>

<p>我们还能对以上方法进行简化，ruby方法返回的值是最一个表达式对应的值，所以我们可以不必写临时变量和return语句</p>

<pre><code>    def say_goodnight(name)
    "Good night, #{name.capitalize}"
end
puts say_goodnight('ma') 
produces:   Good night, Ma
</code></pre>

<h4>Ruby的名字</h4>

<p>ruby的命名遵循以下惯例,第一个名字的首字符表示这个名字的使用场合</p>

<ul>
<li>局部变量，方法参数，方法名都 以一个小写字母或下划线开头</li>
<li>全局变量以一个$符开头，对象实例变量以@开头</li>
<li>类变量以两个@@开头</li>
<li><p>类名，模块名，常量必须以大写字母开头
使用的demo如下</p>

<pre><code>  Local Variable:     name fish_and_chips x_axis thx1138 _x _26
  Instance Variable:  @name @point_1 @X @_ @plan9
  Class Variable:     @@total @@symtab @@N @@x_pos @@SINGLE
  Global Variable:   $debug $CUSTOMER $_ $plan9 $Global
  Class Name:         String ActiveRecord MyClass     Constant Name:      FEET_PER_MILE DEBUG
</code></pre>

<h4>数组和哈希字典</h4>

<p>数组</p>

<pre><code>  a = [ 1, 'cat', 3.14 ] # array with three elements 
  puts "The first element is #{a[0]}"
  # set the third element
  a[2] = nil
  puts "The array is now #{a.inspect}"
  produces:
  The first element is 1
  The array is now [1, "cat", nil]
</code></pre>

<p>简便地创建数组的方法</p>

<pre><code>  a = %w{ ant bee cat dog elk } 
  a[0] # =&gt; "ant"
  a[3] # =&gt; "dog"
</code></pre>

<p>哈希字典</p>

<pre><code>  inst_section = {
  'cello' =&gt; 'string', 
  'clarinet' =&gt; 'woodwind', 
  'drum' =&gt; 'percussion', 
  'oboe' =&gt; 'woodwind', 
  'trumpet' =&gt; 'brass', 
  'violin' =&gt; 'string'    }
</code></pre>

<p><code>=&gt;</code>符号的左为key，右为value
在控制台上我们用p而不是puts，因为p可以更显式地打印nil值</p>

<pre><code>  p inst_section['oboe']
  p inst_section['cello']
  p inst_section['bassoon']
</code></pre></li>
</ul>


<p>produces:</p>

<pre><code>    "woodwind"
    "string"
    nil
</code></pre>

<p>默认情况下hash的key如果对应的value不存在，则value的值为nil，我们可以改变这个默认傎</p>

<pre><code>histogram = Hash.new(0)
histogram['ruby'] # =&gt; 0
histogram['ruby'] = histogram['ruby'] + 1 
histogram['ruby'] # =&gt; 1
</code></pre>

<h4>符号(Symbols)</h4>

<p>通常在编程的时候，你需要为某些重要的东西指定一个名字，比如，你也许想要用名字来指示指南针的方向，所以，你可以像以下这么写</p>

<pre><code>NORTH = 1 
EAST =2 
SOUTH = 3 
WEST =4
</code></pre>

<p>定义好之后，你就可以用这些名字而不是数字了</p>

<pre><code>walk(NORTH)
look(EAST)
</code></pre>

<p>然而，很多时候，这些名字对应的数值是不相关的(只要它们是唯一的)你所要做的只是区分这四个方向而已
Ruby提供了一个很简单的替代方案:符号(Symbols).Symbols只是常量名字，不过你无需定义它，并且它们也保证是唯一的，一个符号常量以:开头，紧跟着字符串
walk(:north)
look(:east)
无须为一个symbol赋任何值,Ruby已经为你考虑好了.Ruby保证不管符号出现在你，一个特定和符号总量有相同的值，因此，你可以按如下方式使用symbol</p>

<pre><code>def walk(direction)
    if direction == :north
    # ...
    end
 end
</code></pre>

<p>symbols通常被用来当作hash的key，我们可以将我们之前写的hash写为以下形式</p>

<pre><code>    inst_section = {
    :cello =&gt; 'string', 
    :clarinet =&gt; 'woodwind', 
    :drum =&gt; 'percussion', 
    :oboe =&gt; 'woodwind', 
    :trumpet =&gt; 'brass', 
    :violin =&gt; 'string'
}
</code></pre>

<p>事实上，symbols是如此频繁地被当作hash的键，ruby提供了一个更简洁的语法，你可以用name:value的形式来创建hash，如果key是symbols的话</p>

<pre><code>inst_section = {
    cello: 'string', 
    clarinet: 'woodwind', 
    drum: 'percussion', 
    oboe: 'woodwind', 
    trumpet: 'brass', 
    violin: 'string'
}
puts "An oboe is a #{inst_section[:oboe]} instrument"
produces:
An oboe is a woodwind instrument
</code></pre>

<h4>条件语句</h4>

<p>if语句</p>

<pre><code>today = Time.now
if today.saturday?
    puts "Do chores around the house"
elsif today.sunday?
     puts "Relax"
else
     puts "Go to work" 
end
</code></pre>

<p>produces:</p>

<pre><code>Go to work
</code></pre>

<p>较短的if语句也可以这么写</p>

<pre><code>puts "Danger, Will Robinson" if radiation &gt; 3000
</code></pre>

<p>while语句</p>

<pre><code>while weight &lt; 100 and num_pallets &lt;= 5
         pallet  = next_pallet()
         weight += pallet.weight
         num_pallets += 1
end
</code></pre>

<p>较短的while语句也可以这么写</p>

<pre><code>    square = 4
    square = square*square while square &lt; 1000
</code></pre>

<p>ruby中的许多语句返回一个值，这意味着你可以用它们作为条件判断，比如,内核方法gets从标准输入流中返回下一行或者当到达文件的末尾时会返回nil，由于Ruby有条件语句中将nil视为假的，你可以用以下代码来处理文件对应的行</p>

<pre><code>while line = gets 
    puts line.downcase
end
</code></pre>

<h4>正则表达式</h4>

<pre><code>/\d\d:\d\d:\d\d/    # a time such as 12:34:56
/Perl.*Python/      # Perl, zero or more other chars, then Python
/Perl Python/       # Perl, a space, and Python
/Perl *Python/     # Perl, zero or more spaces, and Python
/Perl +Python/     # Perl, one or more spaces, and Python
/Perl\s+Python/   # Perl, whitespace characters, then Python
/Ruby (Perl|Python)/ # Ruby, a space, and either Perl or Python
</code></pre>

<p>结果if语句使用</p>

<pre><code>line = gets
if line =~ /Perl|Python/
    puts "Scripting language mentioned: #{line}" 
end
</code></pre>

<p>正则表达式的替代方法</p>

<pre><code>line = gets
newline = line.sub(/Perl/, 'Ruby') # replace first 'Perl' with 'Ruby'   newerline =     newline.gsub(/Python/, 'Ruby') # replace every 'Python' with 'Ruby'
</code></pre>

<h4>Blocks和迭代器</h4>

<p>我们首先看看代码块(code blocks),code blocks是一串代码，你能将它与方法调用结合起来,就当它们是参数一样,这是难以置信的强大特性
你用代码块来实现回调(但比java中的匿名内部类简单),把它们像C中的函数指针那样来传递(比C函数指针更简单)，或者实现迭代器的功能
代码块的形式如下</p>

<pre><code>{ puts "Hello" }
</code></pre>

<p>或</p>

<pre><code>do
  club.enroll(person)
  person.socialize
end
</code></pre>

<p>&ldquo;{}"block主要用在单行中,"do&hellip;.end"主要用在多行中
你可以将block放在一个调用方法的尾部</p>

<pre><code>greet { puts "Hi" } //greet是方法
</code></pre>

<p>如果方法有参数，则将block放在这些参数的最后</p>

<pre><code>verbose_greet("Dave", "loyal customer") { puts "Hi" }
</code></pre>

<p>方法可以用Ruby提供的yield来调用block多次</p>

<pre><code>def call_block      puts "Start of method" yield        yield       puts "End of method"    end
    call_block { puts "In the block" }
</code></pre>

<p>打印结果</p>

<pre><code>    Start of method
    In the block
    In the block
    End of method
</code></pre>

<p>调用yield的时候可以带参数,这些参数将被传到block中去，在block中，你将这些被接收的参数用|params&hellip;|的形式列出来,如下</p>

<pre><code>def who_says_what yield("Dave", "hello") 
    yield("Andy", "goodbye")    end
who_says_what {|person, phrase| puts "#{person} says #{phrase}"}
</code></pre>

<p>打印结果</p>

<pre><code>Dave says hello Andy says goodbye
</code></pre>

<p>Code blocks广泛用在ruby的库中用来实现迭代器</p>

<pre><code>    animals = %w( ant bee cat dog ) # create an array
animals.each {|animal| puts animal }    # iterate over the contents
</code></pre>

<p>produces:</p>

<pre><code>ant bee cat dog再来看几个例子
    [ 'cat', 'dog', 'horse' ].each {|name| print name, " " } 
5.times { print "*" }
3.upto(6) {|i| print i }
('a'..'e').each {|char| print char }
puts
</code></pre>

<p>produces:</p>

<pre><code>cat dog horse *****3456abcde####读写

printf("Number: %5.2f,\nString: %s\n", 1.23, "hello")
</code></pre>

<p>produces:    Number:  1.23,    String: hello有很多方法可以将输入读入程序中，最常见的gets方法，它返回标准输入流的下一行</p>

<pre><code>line = gets print line
</code></pre>

<h4>命令行参数</h4>

<p>当你从命令行运行一个Ruby程序时，你能传送一些参数给它，你能用两种不同的参数来访问这些参数
首先，ARGV就是这些参数组成的数组，假设有一个叫cmd_line.rb的程序如下</p>

<pre><code>puts "You gave #{ARGV.size} arguments" 
p ARGV
</code></pre>

<p>当我们向此程序传入这些参数时，我们参看到输出结果</p>

<pre><code>$ ruby cmd_line.rb ant bee cat dog 
You gave 4 arguments    ["ant", "bee", "cat", "dog"]
</code></pre>

<p>通常，传入的参数是你要处理的文件的名字，这种情况下，你应该用第二种技巧,<code>ARGF</code>,它是一种特别的I/O对象，代表了通过命令行传入的文件名的所有内容, 我们之后再学习它</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Ruby]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/07/21/chu-shi-ruby/"/>
    <updated>2014-07-21T22:23:15+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/07/21/chu-shi-ruby</id>
    <content type="html"><![CDATA[<p>在终端中输入irb与ruby交互</p>

<pre><code>    2.1.2 :002 &gt; def sum(n1, n2)
    2.1.2 :003?&gt;   n1+n2
    2.1.2 :004?&gt;   end
     =&gt; :sum
    2.1.2 :005 &gt; sum(3, 4)
     =&gt; 7
</code></pre>

<p>通常我们将ruby程序写在文件里，假设现在有一个myprog.rb的程序如下</p>

<pre><code>    gettingstarted/myprog.rb        puts "Hello, Ruby Programmer"       puts "It is now #{Time.now}"
</code></pre>

<p>现在我们可以敲入以下命令来运行程序</p>

<pre><code>    $ ruby myprog.rb        Hello, Ruby Programmer)     It is noew 2014-07-21 22:27:47 +0800
</code></pre>

<p>在Unix中，我们可以在程序的第一行添加"shebang"的符号，如下</p>

<pre><code>    #! /usr/bin/ruby
    puts "Hello, Ruby Programmer" 
    puts "It is now #{Time.now}"
</code></pre>

<p>如果你用<code>chmod+x myprog.rb</code>命令让此文件成为可执行程序，Unix能让你将此文件作为一个程序来运行</p>

<pre><code>    $ ./myprog.rb       Hello, Ruby Programmer      It is now 2013-05-27 12:30:36 -0500####Ruby文档:RDoc和ri
</code></pre>

<p>Ruby库越来越大，已经不可能将有关它们的文档写进一本书中了，ruby的标准库有9000多个！幸运的是，一种为这些方法(类，模块)提供文档的方法是存在的，许多在它们内部写文档的方法是采用一个RDoc的工具
如果一个源文件用RDoc来文档注释，那么它的文档是可以被提取出来并被转化成HTML和ri的形式的
ri是一个浏览本地RDoc的，命令行浏览器，许多ruby的发行版现在用ri程序来安装文档资源
要发现针对某个类的文档，我们可以在命令行敲入<code>ri ClassName</code>的形式来查看,如以下</p>

<pre><code>$ ri GC
----------------------------------------------------------------------------------- 
The GC module provides an interface to Ruby's garbage collection mechanism. Some of the underlying  methods are also available via the ObjectSpace module.           You may obtain information about the operation of the GC through GC::Profiler.    -----------------------------------------------------------------------------------    Class methods:      count, disable, enable, malloc_allocated_size, malloc_allocations,      start, stat, stress, stress=    Instance methods:      garbage_collect
</code></pre>

<p>查看某个指定类的方法</p>

<pre><code>ri GC::enable
--------------------------------------------------------------- GC::enable GC.enable =&gt; true or false   --------------------------------------------------------------------------- Enables garbage collection, returning true if garbage collection was    disabled.   GC.disable  GC.enable   GC.enable   #=&gt; false   #=&gt; true    #=&gt; false   
</code></pre>
]]></content>
  </entry>
  
</feed>
