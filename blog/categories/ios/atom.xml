<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | AllenToFight Blog]]></title>
  <link href="http://xiekunRonaldo.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://xiekunRonaldo.github.io/"/>
  <updated>2014-08-13T10:39:25+08:00</updated>
  <id>http://xiekunRonaldo.github.io/</id>
  <author>
    <name><![CDATA[AllenToFight]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift]]></title>
    <link href="http://xiekunRonaldo.github.io/blog/2014/08/12/swift/"/>
    <updated>2014-08-12T21:29:29+08:00</updated>
    <id>http://xiekunRonaldo.github.io/blog/2014/08/12/swift</id>
    <content type="html"><![CDATA[<h4>变量定义</h4>

<p>常量用let,变量用var</p>

<p>```
var myVariable = 42
myVariable = 50
let myConstant = 42
let explicitDouble: Double = 70</p>

<p>```</p>

<p>变量的值不会自动转化为其他类型的</p>

<p><code>
let label = "The width is "
let width = 94
let widthLabel = label+String(width)
</code>
String内的值替换</p>

<p><code>
let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples.”
</code>
数组和字典</p>

<p>```
var shoppingList = [&ldquo;catfish&rdquo;, &ldquo;water&rdquo;, &ldquo;tulips&rdquo;, &ldquo;blue paint&rdquo;]</p>

<p>shoppingList[1] = &ldquo;bottle of water&rdquo;</p>

<p>var occupations = [</p>

<pre><code>"Malcolm": "Captain",

"Kaylee": "Mechanic",
</code></pre>

<p>]
occupations[&ldquo;Jayne&rdquo;] = &ldquo;Public Relations”</p>

<p>let emptyArray = String<a href=""></a>
let emptyDictionary = Dictionary&lt;String, Float>()</p>

<p>```
如果类型是能推断的，可以用[]创建一个空数组，用[:]创建一个空字典</p>

<h4>条件语句</h4>

<p>if&hellip;else&hellip;</p>

<p>```
let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {</p>

<pre><code>if score &gt; 50 {
    teamScore += 3
} else {
    teamScore += 1
}
</code></pre>

<p>}
teamScore
<code>``
注意，在if条件语句中，condition必须是bool表达式，所以类似</code>if score {&hellip;}`这样的代码是错误的
if和optional value组成的条件表达式</p>

<p>```
var optionalString: String? = &ldquo;Hello&rdquo;
optionalString == nil</p>

<p>var optionalName: String? = &ldquo;John Appleseed&rdquo;
var greeting = &ldquo;Hello!&rdquo;
if let name = optionalName {</p>

<pre><code>greeting = "Hello, \(name)"
</code></pre>

<p>}
```
switch和case语句支持多种类型的比较,不限于integer</p>

<p>```
let vegetable = &ldquo;red pepper&rdquo;
switch vegetable {
case &ldquo;celery&rdquo;:</p>

<pre><code>let vegetableComment = "Add some raisins and make ants on a log."
</code></pre>

<p>case &ldquo;cucumber&rdquo;, &ldquo;watercress&rdquo;:</p>

<pre><code>let vegetableComment = "That would make a good tea sandwich."
</code></pre>

<p>case let x where x.hasSuffix(&ldquo;pepper&rdquo;):</p>

<pre><code>let vegetableComment = "Is it a spicy \(x)?"
</code></pre>

<p>default:</p>

<pre><code>let vegetableComment = "Everything tastes good in soup."
</code></pre>

<p>}
```
注意:执行完case语句，程序就从switch语句里终止了，所以无需break!</p>

<p>遍历dictionary</p>

<p>```
let interestingNumbers = [</p>

<pre><code>"Prime": [2, 3, 5, 7, 11, 13],
"Fibonacci": [1, 1, 2, 3, 5, 8],
"Square": [1, 4, 9, 16, 25],
</code></pre>

<p>]
var largest = 0
for (kind, numbers) in interestingNumbers {</p>

<pre><code>for number in numbers {
    if number &gt; largest {
        largest = number
    }
}
</code></pre>

<p>}
largest
```
while语句</p>

<p>```
var n = 2
while n &lt; 100 {</p>

<pre><code>n = n * 2
</code></pre>

<p>}
n</p>

<p>var m = 2
do {</p>

<pre><code>m = m * 2
</code></pre>

<p>} while m &lt; 100
m
<code>``
</code>..`的妙用,以下两个循环是等价的</p>

<p>```
var firstForLoop = 0
for i in 0..3 {</p>

<pre><code>firstForLoop += i
</code></pre>

<p>}
firstForLoop</p>

<p>var secondForLoop = 0
for var i = 0; i &lt; 3; ++i {</p>

<pre><code>secondForLoop += 1
</code></pre>

<p>}
secondForLoop
```</p>

<h4>函数和闭包</h4>

<p>函数的声明
用->将参数与返回值区分开来</p>

<p>```
func greet(name: String, day: String) &ndash;> String {</p>

<pre><code>return "Hello \(name), today is \(day)."
</code></pre>

<p>}
greet(&ldquo;Bob&rdquo;, &ldquo;Tuesday&rdquo;)
<code>
用tuple从函数中返回多个值
</code>
func getGasPrices() &ndash;> (Double, Double, Double) {</p>

<pre><code>return (3.59, 3.69, 3.79)
</code></pre>

<p>}
getGasPrices()
```
函数也能接收不定数量的参数，将它们封成到一个数组里</p>

<p>```
func sumOf(numbers: Int&hellip;) &ndash;> Int {</p>

<pre><code>var sum = 0
for number in numbers {
    sum += number
}
return sum
</code></pre>

<p>}
sumOf()
sumOf(42, 597, 12)
<code>
函数也能嵌套，内嵌的函数能访问声明在外部函数的变量
</code>
func returnFifteen() &ndash;> Int {</p>

<pre><code>var y = 10
func add() {
    y += 5
}
add()
return y
</code></pre>

<p>}
returnFifteen()
```
函数是first-class类型，这意味着函数也能返回另一个函数</p>

<p>```
func makeIncrementer() &ndash;> (Int &ndash;> Int) {</p>

<pre><code>func addOne(number: Int) -&gt; Int {
    return 1 + number
}
return addOne
</code></pre>

<p>}
var increment = makeIncrementer()
increment(7)
```
函数的参数也能是函数</p>

<p>```
func hasAnyMatches(list: Int[], condition: Int &ndash;> Bool) &ndash;> Bool {</p>

<pre><code>for item in list {
    if condition(item) {
        return true
    }
}
return false
</code></pre>

<p>}
func lessThanTen(number: Int) &ndash;> Bool {</p>

<pre><code>return number &lt; 10
</code></pre>

<p>}
var numbers = [20, 19, 7, 12]
hasAnyMatches(numbers, lessThanTen)
```
函数实际上是闭包的一种特殊形式，我们可以用{}来写一个匿名的闭包,用in来将参数和返回类型区分开来</p>

<p>```
numbers.map({</p>

<pre><code>(number: Int) -&gt; Int in
let result = 3 * number
return result
})
</code></pre>

<p>```
如果一个closure的类型是已知的，比如已知一个delegate的回调，我们可以省略参数的类型，返回类型或两者都省略,以上可以改写成以下</p>

<p><code>
numbers.map({ number in 3 * number })
</code>
我们也可以用数字而不是名字来表示参数</p>

<p><code>
sort([1, 5, 3, 12, 2]) { $0 &gt; $1 }
</code></p>

<h4>对象和类</h4>

<p>```
class Shape {</p>

<pre><code>var numberOfSides = 0
func simpleDescription() -&gt; String {
    return "A shape with \(numberOfSides) sides."
}
</code></pre>

<p>}</p>

<p>var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
```</p>

<p><code>init</code>的使用</p>

<p>```
class NamedShape {</p>

<pre><code>var numberOfSides: Int = 0
var name: String

init(name: String) {
    self.name = name
}

func simpleDescription() -&gt; String {
    return "A shape with \(numberOfSides) sides."
}
</code></pre>

<p>}
```
每一个property都需要赋值，可以在它声明的时候(如numberOfSlides)也可以在initializer里(如name)
定义deinit来创建一个deinitializer如果你需要在对象被释放前做一些清理工作的话
继承时，如果要重写superclass的方法，必须要在重写的方法前加override</p>

<p>```
class Square: NamedShape {</p>

<pre><code>var sideLength: Double

init(sideLength: Double, name: String) {
    self.sideLength = sideLength
    super.init(name: name)
    numberOfSides = 4
}

func area() -&gt;  Double {
    return sideLength * sideLength
}

override func simpleDescription() -&gt; String {
    return "A square with sides of length \(sideLength)."
}
</code></pre>

<p>}
let test = Square(sideLength: 5.2, name: &ldquo;my test square&rdquo;)
test.area()
test.simpleDescription()
```
为property定义getter和setter</p>

<p>```
class EquilateralTriangle: NamedShape {</p>

<pre><code>var sideLength: Double = 0.0

init(sideLength: Double, name: String) {
    self.sideLength = sideLength
    super.init(name: name)
    numberOfSides = 3
}

var perimeter: Double {
get {
    return 3.0 * sideLength
}
set {
    sideLength = newValue / 3.0
}
</code></pre>

<p> }</p>

<p> override func simpleDescription() &ndash;> String {</p>

<pre><code>        return "An equilateral triagle with sides of length \(sideLength)."
    }
</code></pre>

<p> }
var triangle = EquilateralTriangle(sideLength: 3.1, name: &ldquo;a triangle&rdquo;)
triangle.perimeter
triangle.perimeter = 9.9
triangle.sideLength
```
在perimeter的setter方法中，新值有一个默认的名字newValue,我们可以在set后的括号里为这个值指定一个名字</p>
]]></content>
  </entry>
  
</feed>
